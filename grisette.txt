-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Symbolic evaluation as a library
--   
--   Grisette is a reusable symbolic evaluation library for Haskell. By
--   translating programs into constraints, Grisette can help the
--   development of program reasoning tools, including verification,
--   synthesis, and more.
--   
--   The <a>Grisette</a> module exports all the core APIs for building a
--   symbolic evaluation tool. A high-level overview of the module
--   structures are available there.
--   
--   A detailed introduction to Grisette is available at
--   <a>Grisette.Core</a>. More lifted libraries are provided in
--   <tt>Grisette.Lib.*</tt> modules.
--   
--   The <a>Grisette.Unified</a> module offers an experimental unified
--   interface for symbolic and concrete evaluation. This module should be
--   imported qualified.
--   
--   For more details, please checkout the README and <a>tutorials</a>.
@package grisette
@version 0.12.0.0


module Grisette.Internal.Core.Control.Exception

-- | Assertion error.
data AssertionError
AssertionError :: AssertionError

-- | Verification conditions. A crashed program path can terminate with
--   either assertion violation errors or assumption violation errors.
data VerificationConditions
AssertionViolation :: VerificationConditions
AssumptionViolation :: VerificationConditions
instance GHC.Classes.Eq Grisette.Internal.Core.Control.Exception.AssertionError
instance GHC.Classes.Eq Grisette.Internal.Core.Control.Exception.VerificationConditions
instance GHC.Internal.Generics.Generic Grisette.Internal.Core.Control.Exception.AssertionError
instance GHC.Internal.Generics.Generic Grisette.Internal.Core.Control.Exception.VerificationConditions
instance Control.DeepSeq.NFData Grisette.Internal.Core.Control.Exception.AssertionError
instance Control.DeepSeq.NFData Grisette.Internal.Core.Control.Exception.VerificationConditions
instance GHC.Classes.Ord Grisette.Internal.Core.Control.Exception.AssertionError
instance GHC.Classes.Ord Grisette.Internal.Core.Control.Exception.VerificationConditions
instance GHC.Internal.Show.Show Grisette.Internal.Core.Control.Exception.AssertionError
instance GHC.Internal.Show.Show Grisette.Internal.Core.Control.Exception.VerificationConditions


module Grisette.Internal.Core.Data.Class.BitCast

-- | Type class for bit-casting between types.
--   
--   <b>Special Considerations for Floating-Point Types:</b>
--   
--   Typically, bit-casting a value from type <tt>a</tt> to type <tt>b</tt>
--   and then back to type <tt>a</tt> should result in the original value.
--   However, this is not always true for floating-point values. In
--   SMT-LIB2, there is only one NaN value with multiple bit
--   representations.
--   
--   Given this, we do not provide <a>BitCast</a> for the <a>FP</a> type,
--   instead, we use the <a>bitCastOrCanonical</a> function to use a
--   canonical representation for the NaN values.
--   
--   If your application requires distinguishing between different NaN
--   values, it is recommended to define your own floating-point type using
--   bit-vectors. This allows you to check for NaN values and perform
--   operations by bitcasting back to the provided floating-point types
--   when they are not NaN values.
class BitCast from to
bitCast :: BitCast from to => from -> to

-- | The canonical value when the bitcast cannot be precisely performed.
--   
--   For example, with SMT-LIB2, there is only one NaN for floating point
--   numbers, with multiple bit representations. Our underlying <a>FP</a>
--   type also follows this convention. This means that we cannot precisely
--   bitcast a <a>FP</a> to other types. So instead, we bitcast the NaN
--   value to a canonical representation, defined with this type class.
class BitCastCanonical from to
bitCastCanonicalValue :: BitCastCanonical from to => proxy from -> to

-- | Bitcasting a value. If the value cannot be precisely bitcast, use the
--   default value.
class BitCastOr from to
bitCastOr :: BitCastOr from to => to -> from -> to

-- | Bitcasting a value and when the value cannot be precisely bitcast, use
--   the canonical value.
bitCastOrCanonical :: BitCastOrCanonical from to => from -> to

-- | Constraint for bitcasting a value and when the value cannot be
--   precisely bitcast, use the canonical value.
type BitCastOrCanonical a b = (BitCastCanonical a b, BitCastOr a b)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Double GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Double GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Float GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Float GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int32 GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int32 GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int64 GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int64 GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word32 GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word32 GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word64 GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word64 GHC.Internal.Int.Int64

module Grisette.Internal.Core.Data.Class.Concrete

-- | A tag for concrete types.
--   
--   Can be used in code to constrain types to concrete ones. For example,
--   when trying to support hash maps in Grisette, we may want to restrict
--   the key type to be concrete. The <a>Concrete</a> type class is handy.
class Concrete a
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Data.Semigroup.Internal.All
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Bits.And a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Data.Semigroup.Internal.Any
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Types.Char
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (Data.Complex.Complex a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete (f (g a)) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (Data.Functor.Compose.Compose f g a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Ord.Down a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Semigroup.Internal.Dual a)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Either.Either a b)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Monoid.First a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Functor.Identity.Identity a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Bits.Iff a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Types.Int
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Num.Integer.Integer
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Bits.Ior a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Monoid.Last a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete [a]
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (Data.Semigroup.Max a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Maybe.Maybe a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (Data.Semigroup.Min a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Num.Natural.Natural
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Base.NonEmpty a)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete (f a), Grisette.Internal.Core.Data.Class.Concrete.Concrete (g a)) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (Data.Functor.Product.Product f g a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Semigroup.Internal.Product a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Real.Ratio a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Tuple.Solo a)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete (f a), Grisette.Internal.Core.Data.Class.Concrete.Concrete (g a)) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (Data.Functor.Sum.Sum f g a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Semigroup.Internal.Sum a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete Data.Text.Internal.Lazy.Text
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete Data.Text.Internal.Text
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e, Grisette.Internal.Core.Data.Class.Concrete.Concrete f, Grisette.Internal.Core.Data.Class.Concrete.Concrete g, Grisette.Internal.Core.Data.Class.Concrete.Concrete h, Grisette.Internal.Core.Data.Class.Concrete.Concrete i, Grisette.Internal.Core.Data.Class.Concrete.Concrete j) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e, f, g, h, i, j)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e, Grisette.Internal.Core.Data.Class.Concrete.Concrete f, Grisette.Internal.Core.Data.Class.Concrete.Concrete g, Grisette.Internal.Core.Data.Class.Concrete.Concrete h, Grisette.Internal.Core.Data.Class.Concrete.Concrete i, Grisette.Internal.Core.Data.Class.Concrete.Concrete j, Grisette.Internal.Core.Data.Class.Concrete.Concrete k) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e, f, g, h, i, j, k)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e, Grisette.Internal.Core.Data.Class.Concrete.Concrete f) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e, f)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e, Grisette.Internal.Core.Data.Class.Concrete.Concrete f, Grisette.Internal.Core.Data.Class.Concrete.Concrete g) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e, f, g)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e, Grisette.Internal.Core.Data.Class.Concrete.Concrete f, Grisette.Internal.Core.Data.Class.Concrete.Concrete g, Grisette.Internal.Core.Data.Class.Concrete.Concrete h) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e, f, g, h)
instance (Grisette.Internal.Core.Data.Class.Concrete.Concrete a, Grisette.Internal.Core.Data.Class.Concrete.Concrete b, Grisette.Internal.Core.Data.Class.Concrete.Concrete c, Grisette.Internal.Core.Data.Class.Concrete.Concrete d, Grisette.Internal.Core.Data.Class.Concrete.Concrete e, Grisette.Internal.Core.Data.Class.Concrete.Concrete f, Grisette.Internal.Core.Data.Class.Concrete.Concrete g, Grisette.Internal.Core.Data.Class.Concrete.Concrete h, Grisette.Internal.Core.Data.Class.Concrete.Concrete i) => Grisette.Internal.Core.Data.Class.Concrete.Concrete (a, b, c, d, e, f, g, h, i)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Base.Void
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Types.Word
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete GHC.Internal.Word.Word8
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete a => Grisette.Internal.Core.Data.Class.Concrete.Concrete (GHC.Internal.Data.Bits.Xor a)


module Grisette.Internal.Core.Data.Class.Function

-- | Abstraction for function-like types.
class Function f arg ret | f -> arg ret

-- | Function application operator.
--   
--   The operator is not right associated (like <a>($)</a>). It is left
--   associated, and you can provide many arguments with this operator once
--   at a time.
--   
--   <pre>
--   &gt;&gt;&gt; (+1) # 2
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (+) # 2 # 3
--   5
--   </pre>
(#) :: Function f arg ret => f -> arg -> ret
infixl 9 #

-- | Applying an uninterpreted function.
--   
--   <pre>
--   &gt;&gt;&gt; let f = "f" :: SymInteger =~&gt; SymInteger =~&gt; SymInteger
--   
--   &gt;&gt;&gt; apply f "a" "b"
--   (apply (apply f a) b)
--   </pre>
--   
--   Note that for implementation reasons, you can also use <a>apply</a>
--   function on a non-function symbolic value. In this case, the function
--   is treated as an <a>id</a> function.
class Apply uf where {
    type FunType uf;
}
apply :: Apply uf => uf -> FunType uf
instance Grisette.Internal.Core.Data.Class.Function.Apply GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.Function.Apply b => Grisette.Internal.Core.Data.Class.Function.Apply (a -> b)
instance Grisette.Internal.Core.Data.Class.Function.Apply GHC.Num.Integer.Integer
instance Grisette.Internal.Core.Data.Class.Function.Function (a -> b) a b


module Grisette.Internal.Core.Data.Class.IEEEFP

-- | Check if a floating-point number is not-a-number.
fpIsNaN :: RealFloat a => a -> Bool

-- | Check if a floating-point number is positive zero.
fpIsPositiveZero :: RealFloat a => a -> Bool

-- | Check if a floating-point number is negative zero.
fpIsNegativeZero :: RealFloat a => a -> Bool

-- | Check if a floating-point number is positive infinite.
fpIsPositiveInfinite :: RealFloat a => a -> Bool

-- | Check if a floating-point number is negative infinite.
fpIsNegativeInfinite :: RealFloat a => a -> Bool

-- | Check if a floating-point number is positive. +0, +inf are considered
--   positive. nan, -0, -inf are not positive.
fpIsPositive :: RealFloat a => a -> Bool

-- | Check if a floating-point number is negative. -0, -inf are considered
--   negative. nan, +0, +inf are not negative.
fpIsNegative :: RealFloat a => a -> Bool

-- | Check if a floating-point number is infinite.
fpIsInfinite :: RealFloat a => a -> Bool

-- | Check if a floating-point number is zero.
fpIsZero :: RealFloat a => a -> Bool

-- | Check if a floating-point number is normal, i.e., not 0, not inf, not
--   nan, and not denormalized.
fpIsNormal :: RealFloat a => a -> Bool

-- | Check if a floating-point number is subnormal, i.e., denormalized. 0,
--   inf, or nan are not subnormal.
fpIsSubnormal :: RealFloat a => a -> Bool

-- | Check if a floating-point number is a point, i.e., not inf, not nan.
fpIsPoint :: RealFloat a => a -> Bool

-- | Constants for IEEE floating-point numbers.
class IEEEFPConstants a

-- | Positive infinity.
fpPositiveInfinite :: IEEEFPConstants a => a

-- | Negative infinity.
fpNegativeInfinite :: IEEEFPConstants a => a

-- | Not-a-number.
fpNaN :: IEEEFPConstants a => a

-- | Negative zero.
fpNegativeZero :: IEEEFPConstants a => a

-- | Positive zero.
fpPositiveZero :: IEEEFPConstants a => a

-- | Smallest positive normalized number.
fpMinNormalized :: IEEEFPConstants a => a

-- | Smallest positive subnormal number.
fpMinSubnormal :: IEEEFPConstants a => a

-- | Largest positive normalized number.
fpMaxNormalized :: IEEEFPConstants a => a

-- | Largest positive subnormal number.
fpMaxSubnormal :: IEEEFPConstants a => a

-- | Rounding modes for floating-point operations.
class IEEEFPRoundingMode mode

-- | Round to nearest, ties to even.
rne :: IEEEFPRoundingMode mode => mode

-- | Round to nearest, ties to away from zero.
rna :: IEEEFPRoundingMode mode => mode

-- | Round towards positive infinity.
rtp :: IEEEFPRoundingMode mode => mode

-- | Round towards negative infinity.
rtn :: IEEEFPRoundingMode mode => mode

-- | Round towards zero.
rtz :: IEEEFPRoundingMode mode => mode

-- | Operations on IEEE floating-point numbers, without rounding mode.
class IEEEFPOp a

-- | IEEE754-2019 abs operation.
fpAbs :: IEEEFPOp a => a -> a

-- | IEEE754-2019 negate operation.
fpNeg :: IEEEFPOp a => a -> a

-- | IEEE754-2019 remainder operation.
fpRem :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 minimum operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns NaN if one operand is NaN.</li>
--   </ul>
fpMinimum :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 minimumNumber operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns the other operand if one operand is NaN.</li>
--   </ul>
fpMinimumNumber :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 maximum operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns NaN if one operand is NaN.</li>
--   </ul>
fpMaximum :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 maximumNumber operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns the other operand if one operand is NaN.</li>
--   </ul>
fpMaximumNumber :: IEEEFPOp a => a -> a -> a

-- | Operations on IEEE floating-point numbers, with rounding mode.
class IEEEFPRoundingMode mode => IEEEFPRoundingOp a mode | a -> mode
fpAdd :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpSub :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpMul :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpDiv :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpFMA :: IEEEFPRoundingOp a mode => mode -> a -> a -> a -> a
fpSqrt :: IEEEFPRoundingOp a mode => mode -> a -> a
fpRoundToIntegral :: IEEEFPRoundingOp a mode => mode -> a -> a

-- | Conversion from and to FPs.
class IEEEFPConvertible a fp mode | fp -> mode
fromFPOr :: IEEEFPConvertible a fp mode => a -> mode -> fp -> a
toFP :: IEEEFPConvertible a fp mode => mode -> a -> fp

-- | Converting FP to real numbers.
class (IEEEFPConvertible a fp mode, IEEEFPRoundingMode mode) => IEEEFPToAlgReal a fp mode | fp -> mode

-- | Similar to <a>fromFPOr</a> for <a>AlgReal</a>, but dropped the ignored
--   rounding mode.
fpToAlgReal :: IEEEFPToAlgReal a fp mode => a -> fp -> a


module Grisette.Internal.Core.Data.Class.ModelOps

-- | The operations on symbolic constant sets
--   
--   Note that symbolic constants with different types are considered
--   different.
--   
--   <pre>
--   &gt;&gt;&gt; let aBool = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let bBool = "b" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let cBool = "c" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let aInteger = "a" :: TypedAnySymbol Integer
--   
--   &gt;&gt;&gt; emptySet :: AnySymbolSet
--   SymbolSet {}
--   
--   &gt;&gt;&gt; containsSymbol aBool (buildSymbolSet aBool :: AnySymbolSet)
--   True
--   
--   &gt;&gt;&gt; containsSymbol bBool (buildSymbolSet aBool :: AnySymbolSet)
--   False
--   
--   &gt;&gt;&gt; insertSymbol aBool (buildSymbolSet aBool :: AnySymbolSet)
--   SymbolSet {a :: Bool}
--   
--   &gt;&gt;&gt; insertSymbol aInteger (buildSymbolSet aBool :: AnySymbolSet)
--   SymbolSet {a :: Bool, a :: Integer}
--   
--   &gt;&gt;&gt; let abSet = buildSymbolSet (aBool, bBool) :: AnySymbolSet
--   
--   &gt;&gt;&gt; let acSet = buildSymbolSet (aBool, cBool) :: AnySymbolSet
--   
--   &gt;&gt;&gt; intersectionSet abSet acSet
--   SymbolSet {a :: Bool}
--   
--   &gt;&gt;&gt; unionSet abSet acSet
--   SymbolSet {a :: Bool, b :: Bool, c :: Bool}
--   
--   &gt;&gt;&gt; differenceSet abSet acSet
--   SymbolSet {b :: Bool}
--   </pre>
class Monoid symbolSet => SymbolSetOps symbolSet (typedSymbol :: Type -> Type) | symbolSet -> typedSymbol

-- | Construct an empty set
emptySet :: SymbolSetOps symbolSet typedSymbol => symbolSet

-- | Check if the set is empty
isEmptySet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> Bool

-- | Check if the set contains the given symbol
containsSymbol :: SymbolSetOps symbolSet typedSymbol => typedSymbol a -> symbolSet -> Bool

-- | Insert a symbol into the set
insertSymbol :: SymbolSetOps symbolSet typedSymbol => typedSymbol a -> symbolSet -> symbolSet

-- | Set intersection
intersectionSet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> symbolSet -> symbolSet

-- | Set union
unionSet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> symbolSet -> symbolSet

-- | Set difference
differenceSet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> symbolSet -> symbolSet

-- | A type class for building a symbolic constant set manually from a
--   symbolic constant set representation
--   
--   <pre>
--   &gt;&gt;&gt; buildSymbolSet ("a" :: TypedAnySymbol Bool, "b" :: TypedAnySymbol Bool) :: AnySymbolSet
--   SymbolSet {a :: Bool, b :: Bool}
--   </pre>
class SymbolSetOps symbolSet typedSymbol => SymbolSetRep rep symbolSet (typedSymbol :: Type -> Type)

-- | Build a symbolic constant set
buildSymbolSet :: SymbolSetRep rep symbolSet typedSymbol => rep -> symbolSet

-- | The operations on Models.
--   
--   Note that symbolic constants with different types are considered
--   different.
--   
--   <pre>
--   &gt;&gt;&gt; let aBool = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let bBool = "b" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let cBool = "c" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let aInteger = "a" :: TypedAnySymbol Integer
--   
--   &gt;&gt;&gt; emptyModel :: Model
--   Model {}
--   
--   &gt;&gt;&gt; valueOf aBool (buildModel (aBool ::= True) :: Model)
--   Just True
--   
--   &gt;&gt;&gt; valueOf bBool (buildModel (aBool ::= True) :: Model)
--   Nothing
--   
--   &gt;&gt;&gt; insertValue bBool False (buildModel (aBool ::= True) :: Model)
--   Model {a -&gt; true :: Bool, b -&gt; false :: Bool}
--   
--   &gt;&gt;&gt; let abModel = buildModel (aBool ::= True, bBool ::= False) :: Model
--   
--   &gt;&gt;&gt; let acSet = buildSymbolSet (aBool, cBool) :: AnySymbolSet
--   
--   &gt;&gt;&gt; exceptFor acSet abModel
--   Model {b -&gt; false :: Bool}
--   
--   &gt;&gt;&gt; restrictTo acSet abModel
--   Model {a -&gt; true :: Bool}
--   
--   &gt;&gt;&gt; extendTo acSet abModel
--   Model {a -&gt; true :: Bool, b -&gt; false :: Bool, c -&gt; false :: Bool}
--   
--   &gt;&gt;&gt; exact acSet abModel
--   Model {a -&gt; true :: Bool, c -&gt; false :: Bool}
--   </pre>
class SymbolSetOps symbolSet typedSymbol => ModelOps model symbolSet (typedSymbol :: Type -> Type) | model -> symbolSet typedSymbol

-- | Construct an empty model
emptyModel :: ModelOps model symbolSet typedSymbol => model

-- | Check if the model is empty
isEmptyModel :: ModelOps model symbolSet typedSymbol => model -> Bool

-- | Check if the model contains the given symbol
modelContains :: ModelOps model symbolSet typedSymbol => typedSymbol a -> model -> Bool

-- | Extract the assigned value for a given symbolic constant
valueOf :: ModelOps model symbolSet typedSymbol => typedSymbol t -> model -> Maybe t

-- | Insert an assignment into the model
insertValue :: ModelOps model symbolSet typedSymbol => typedSymbol t -> t -> model -> model

-- | Returns a model that removed all the assignments for the symbolic
--   constants in the set
exceptFor :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | Returns a model that removed the assignments for the symbolic
--   constants
exceptFor' :: ModelOps model symbolSet typedSymbol => typedSymbol t -> model -> model

-- | Returns a model that only keeps the assignments for the symbolic
--   constants in the set
restrictTo :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | Returns a model that extends the assignments for the symbolic
--   constants in the set by assigning default values to them
extendTo :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | Returns a model that contains the assignments for exactly the symbolic
--   constants in the set by removing assignments for the symbolic
--   constants that are not in the set and add assignments for the missing
--   symbolic constants by assigning default values to them.
exact :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | A type class for building a model manually from a model representation
class ModelRep rep model | rep -> model

-- | Build a model
--   
--   <pre>
--   &gt;&gt;&gt; let aBool = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let bBool = "b" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; buildModel (aBool ::= True, bBool ::= False) :: Model
--   Model {a -&gt; true :: Bool, b -&gt; false :: Bool}
--   </pre>
buildModel :: ModelRep rep model => rep -> model


module Grisette.Internal.Core.Data.Class.SignConversion

-- | Convert values between signed and unsigned.
class SignConversion ubv sbv | ubv -> sbv, sbv -> ubv

-- | Convert unsigned value to the corresponding signed value.
toSigned :: SignConversion ubv sbv => ubv -> sbv

-- | Convert signed value to the corresponding unsigned value.
toUnsigned :: SignConversion ubv sbv => sbv -> ubv
instance Grisette.Internal.Core.Data.Class.SignConversion.SignConversion GHC.Internal.Word.Word16 GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.SignConversion.SignConversion GHC.Internal.Word.Word32 GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.SignConversion.SignConversion GHC.Internal.Word.Word64 GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.SignConversion.SignConversion GHC.Internal.Word.Word8 GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.SignConversion.SignConversion GHC.Types.Word GHC.Types.Int


module Grisette.Internal.Core.Data.Class.SymRotate

-- | The <a>symRotate</a> is similar to <a>rotate</a>, but accepts the type
--   itself instead of <a>Int</a> for the rotate amount. The function works
--   on all inputs, including the rotate amounts that are beyond the bit
--   width of the value.
--   
--   The <a>symRotateNegated</a> function rotates to the opposite direction
--   of <a>symRotate</a>. This function is introduced to handle the
--   asymmetry of the range of values.
class Bits a => SymRotate a
symRotate :: SymRotate a => a -> a -> a
symRotateNegated :: SymRotate a => a -> a -> a

-- | A newtype wrapper. Use this to derive <a>SymRotate</a> for types that
--   have <a>FiniteBits</a> instances.
newtype DefaultFiniteBitsSymRotate a
DefaultFiniteBitsSymRotate :: a -> DefaultFiniteBitsSymRotate a
[unDefaultFiniteBitsSymRotate] :: DefaultFiniteBitsSymRotate a -> a
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (Grisette.Internal.Core.Data.Class.SymRotate.DefaultFiniteBitsSymRotate a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Grisette.Internal.Core.Data.Class.SymRotate.DefaultFiniteBitsSymRotate a)
instance (GHC.Internal.Real.Integral a, GHC.Internal.Bits.FiniteBits a) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (Grisette.Internal.Core.Data.Class.SymRotate.DefaultFiniteBitsSymRotate a)
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Types.Int
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Types.Word
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.SymRotate.SymRotate GHC.Internal.Word.Word8


module Grisette.Internal.Core.Data.Class.SymShift

-- | A class for shifting operations.
--   
--   The <a>symShift</a> function shifts the value to the left if the shift
--   amount is positive, and to the right if the shift amount is negative.
--   If shifting beyond the bit width of the value, the result is the same
--   as shifting with the bit width.
--   
--   The <a>symShiftNegated</a> function shifts the value to the right if
--   the shift amount is positive, and to the left if the shift amount is
--   negative. This function is introduced to handle the asymmetry of the
--   range of values.
class Bits a => SymShift a
symShift :: SymShift a => a -> a -> a
symShiftNegated :: SymShift a => a -> a -> a

-- | A newtype wrapper. Use this to derive <a>SymShift</a> for types that
--   have <a>FiniteBits</a> instances.
newtype DefaultFiniteBitsSymShift a
DefaultFiniteBitsSymShift :: a -> DefaultFiniteBitsSymShift a
[unDefaultFiniteBitsSymShift] :: DefaultFiniteBitsSymShift a -> a
instance GHC.Internal.Bits.Bits a => GHC.Internal.Bits.Bits (Grisette.Internal.Core.Data.Class.SymShift.DefaultFiniteBitsSymShift a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Grisette.Internal.Core.Data.Class.SymShift.DefaultFiniteBitsSymShift a)
instance (GHC.Internal.Real.Integral a, GHC.Internal.Bits.FiniteBits a) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (Grisette.Internal.Core.Data.Class.SymShift.DefaultFiniteBitsSymShift a)
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Types.Int
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Types.Word
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.SymShift.SymShift GHC.Internal.Word.Word8


module Grisette.Internal.Core.Data.MemoUtils

-- | Memoize a unary function.
stableMemo :: (a -> b) -> a -> b

-- | Curried memoization to share partial evaluation
stableMemo2 :: (a -> b -> c) -> a -> b -> c

-- | Curried memoization to share partial evaluation
stableMemo3 :: (a -> b -> c -> d) -> a -> b -> c -> d

-- | Lift a memoizer to work with one more argument.
stableMup :: (b -> c) -> (a -> b) -> a -> c

-- | Memoizing recursion. Use like <a>fix</a>.
stableMemoFix :: ((a -> b) -> a -> b) -> a -> b

-- | Memoize a unary function.
weakStableMemo :: (a -> b) -> a -> b

-- | Curried memoization to share partial evaluation
weakStableMemo2 :: (a -> b -> c) -> a -> b -> c

-- | Curried memoization to share partial evaluation
weakStableMemo3 :: (a -> b -> c -> d) -> a -> b -> c -> d

-- | Lift a memoizer to work with one more argument.
weakStableMup :: (b -> c) -> (a -> b) -> a -> c

-- | Memoizing recursion. Use like <a>fix</a>.
weakStableMemoFix :: ((a -> b) -> a -> b) -> a -> b

-- | Function memoizer with mutable hash table.
htmemo :: (Eq k, Hashable k) => (k -> a) -> k -> a

-- | Function memoizer with mutable hash table. Works on binary functions.
htmemo2 :: (Eq k1, Hashable k1, Eq k2, Hashable k2) => (k1 -> k2 -> a) -> k1 -> k2 -> a

-- | Function memoizer with mutable hash table. Works on ternary functions.
htmemo3 :: (Eq k1, Hashable k1, Eq k2, Hashable k2, Eq k3, Hashable k3) => (k1 -> k2 -> k3 -> a) -> k1 -> k2 -> k3 -> a

-- | Memoizing recursion. Use like <a>fix</a>.
htmemoFix :: (Eq k, Hashable k) => ((k -> a) -> k -> a) -> k -> a

-- | Lift a memoizer to work with one more argument.
htmup :: (Eq k, Hashable k) => (b -> c) -> (k -> b) -> k -> c
instance Grisette.Internal.Core.Data.MemoUtils.Ref Grisette.Internal.Core.Data.MemoUtils.Strong
instance Grisette.Internal.Core.Data.MemoUtils.Ref GHC.Internal.Weak.Weak


module Grisette.Internal.Core.Data.SExpr

-- | S-expression data type. Used for symbol metadata.
data SExpr
Atom :: Text -> SExpr
List :: [SExpr] -> SExpr
NumberAtom :: Integer -> SExpr
BoolAtom :: Bool -> SExpr

-- | Show an S-expression with specific parentheses.
showsSExprWithParens :: Char -> Char -> SExpr -> ShowS

-- | Parse a file location string into an S-expression.
parseFileLocation :: String -> SExpr

-- | Get the file location of the splice.
fileLocation :: SpliceQ SExpr
instance Data.Binary.Class.Binary Grisette.Internal.Core.Data.SExpr.SExpr
instance GHC.Classes.Eq Grisette.Internal.Core.Data.SExpr.SExpr
instance GHC.Internal.Generics.Generic Grisette.Internal.Core.Data.SExpr.SExpr
instance Data.Hashable.Class.Hashable Grisette.Internal.Core.Data.SExpr.SExpr
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.Core.Data.SExpr.SExpr
instance Control.DeepSeq.NFData Grisette.Internal.Core.Data.SExpr.SExpr
instance GHC.Classes.Ord Grisette.Internal.Core.Data.SExpr.SExpr
instance Data.Bytes.Serial.Serial Grisette.Internal.Core.Data.SExpr.SExpr
instance Data.Serialize.Serialize Grisette.Internal.Core.Data.SExpr.SExpr
instance GHC.Internal.Show.Show Grisette.Internal.Core.Data.SExpr.SExpr


module Grisette.Internal.Core.Data.Symbol

-- | Identifier type used for <a>GenSym</a>
--   
--   The constructor is hidden intentionally. You can construct an
--   identifier by:
--   
--   <ul>
--   <li>a raw identifier</li>
--   </ul>
--   
--   The following two expressions will refer to the same identifier (the
--   solver won't distinguish them and would assign the same value to
--   them). The user may need to use unique names to avoid unintentional
--   identifier collision.
--   
--   <pre>
--   &gt;&gt;&gt; identifier "a"
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "a" :: Identifier -- available when OverloadedStrings is enabled
--   a
--   </pre>
--   
--   <ul>
--   <li>bundle the identifier with some user provided metadata</li>
--   </ul>
--   
--   Identifiers created with different name or different additional
--   information will not be the same.
--   
--   <pre>
--   &gt;&gt;&gt; withMetadata "a" (NumberAtom 1)
--   a:1
--   </pre>
--   
--   <ul>
--   <li>bundle the calling file location with the identifier to ensure
--   global uniqueness</li>
--   </ul>
--   
--   Identifiers created at different locations will not be the same. The
--   identifiers created at the same location will be the same.
--   
--   <pre>
--   &gt;&gt;&gt; $$(withLocation "a") -- a sample result could be "a:[grisette-file-location &lt;interactive&gt; 18 (4 18)]"
--   a:[grisette-file-location &lt;interactive&gt;...]
--   </pre>
data Identifier
Identifier :: Text -> SExpr -> Identifier
[baseIdent] :: Identifier -> Text
[metadata] :: Identifier -> SExpr

-- | Simple identifier. The same identifier refers to the same symbolic
--   variable in the whole program.
--   
--   The user may need to use unique identifiers to avoid unintentional
--   identifier collision.
identifier :: Text -> Identifier

-- | Identifier with extra metadata.
--   
--   The same identifier with the same metadata refers to the same symbolic
--   variable in the whole program.
--   
--   The user may need to use unique identifiers or additional metadata to
--   avoid unintentional identifier collision.
withMetadata :: AsMetadata a => Text -> a -> Identifier

-- | Identifier with the file location.
withLocation :: Text -> SpliceQ Identifier

-- | Modify the metadata of an identifier.
mapMetadata :: AsMetadata a => (SExpr -> a) -> Identifier -> Identifier

-- | Get a globally unique identifier within the <a>IO</a> monad.
uniqueIdentifier :: Text -> IO Identifier

-- | Symbol types for a symbolic variable.
--   
--   The symbols can be indexed with an integer.
data Symbol
[SimpleSymbol] :: Identifier -> Symbol
[IndexedSymbol] :: Identifier -> Int -> Symbol

-- | Create a simple symbol.
simple :: Identifier -> Symbol

-- | Create an indexed symbol.
indexed :: Identifier -> Int -> Symbol

-- | Get the identifier of a symbol.
symbolIdentifier :: Symbol -> Identifier

-- | Modify the identifier of a symbol.
mapIdentifier :: (Identifier -> Identifier) -> Symbol -> Symbol

-- | A type class for embedding a type into a metadata represented as an
--   S-expression.
class AsMetadata a
asMetadata :: AsMetadata a => a -> SExpr
fromMetadata :: AsMetadata a => SExpr -> Maybe a

-- | A pattern for extracting a value from a metadata represented as an
--   S-expression.
pattern Metadata :: AsMetadata a => a -> SExpr
instance Grisette.Internal.Core.Data.Symbol.AsMetadata Grisette.Internal.Core.Data.SExpr.SExpr
instance Data.Binary.Class.Binary Grisette.Internal.Core.Data.Symbol.Identifier
instance Data.Binary.Class.Binary Grisette.Internal.Core.Data.Symbol.Symbol
instance GHC.Classes.Eq Grisette.Internal.Core.Data.Symbol.Identifier
instance GHC.Classes.Eq Grisette.Internal.Core.Data.Symbol.Symbol
instance GHC.Internal.Generics.Generic Grisette.Internal.Core.Data.Symbol.Identifier
instance GHC.Internal.Generics.Generic Grisette.Internal.Core.Data.Symbol.Symbol
instance Data.Hashable.Class.Hashable Grisette.Internal.Core.Data.Symbol.Identifier
instance Data.Hashable.Class.Hashable Grisette.Internal.Core.Data.Symbol.Symbol
instance GHC.Internal.Data.String.IsString Grisette.Internal.Core.Data.Symbol.Identifier
instance GHC.Internal.Data.String.IsString Grisette.Internal.Core.Data.Symbol.Symbol
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.Core.Data.Symbol.Identifier
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.Core.Data.Symbol.Symbol
instance Control.DeepSeq.NFData Grisette.Internal.Core.Data.Symbol.Identifier
instance Control.DeepSeq.NFData Grisette.Internal.Core.Data.Symbol.Symbol
instance GHC.Classes.Ord Grisette.Internal.Core.Data.Symbol.Identifier
instance GHC.Classes.Ord Grisette.Internal.Core.Data.Symbol.Symbol
instance Data.Bytes.Serial.Serial Grisette.Internal.Core.Data.Symbol.Identifier
instance Data.Bytes.Serial.Serial Grisette.Internal.Core.Data.Symbol.Symbol
instance Data.Serialize.Serialize Grisette.Internal.Core.Data.Symbol.Identifier
instance Data.Serialize.Serialize Grisette.Internal.Core.Data.Symbol.Symbol
instance GHC.Internal.Show.Show Grisette.Internal.Core.Data.Symbol.Identifier
instance GHC.Internal.Show.Show Grisette.Internal.Core.Data.Symbol.Symbol


module Grisette.Internal.SymPrim.AlgReal

-- | A univariate polynomial with integer coefficients.
--   
--   For instance, <tt>5x^3+2x-5</tt> is represented as
--   <tt><a>AlgRealPoly</a> [(5, 3), (2, 1), (-5, 0)]</tt>.
newtype AlgRealPoly
AlgRealPoly :: [(Integer, Integer)] -> AlgRealPoly

-- | Exception for unsupported operations on algebraic real numbers.
--   
--   We only support operations on exact rationals.
data UnsupportedAlgRealOperation
UnsupportedAlgRealOperation :: String -> String -> UnsupportedAlgRealOperation
[op] :: UnsupportedAlgRealOperation -> String
[msg] :: UnsupportedAlgRealOperation -> String

-- | Convert algebraic real numbers to SBV's algebraic real numbers.
toSBVAlgReal :: AlgReal -> AlgReal

-- | Convert SBV's algebraic real numbers to algebraic real numbers.
fromSBVAlgReal :: AlgReal -> AlgReal

-- | Boundary point for real intervals.
data RealPoint

-- | Open point.
OpenPoint :: Rational -> RealPoint

-- | Closed point.
ClosedPoint :: Rational -> RealPoint

-- | Algebraic real numbers. The representation can be abstract for
--   roots-of-polynomials or intervals.
data AlgReal

-- | Exact rational number.
[AlgExactRational] :: Rational -> AlgReal

-- | Inexact rational numbers. SMT-solver return it with ? at the end.
[AlgInexactRational] :: Rational -> AlgReal

-- | Algebraic real number as a root of a polynomial.
[AlgPolyRoot] :: Integer -> AlgRealPoly -> Maybe String -> AlgReal

-- | Interval with low and high bounds.
[AlgInterval] :: RealPoint -> RealPoint -> AlgReal
instance Grisette.Internal.Core.Data.Class.Function.Apply Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Test.QuickCheck.Arbitrary.Arbitrary Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.AlgReal.RealPoint
instance GHC.Classes.Eq Grisette.Internal.SymPrim.AlgReal.AlgReal
instance GHC.Classes.Eq Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance GHC.Classes.Eq Grisette.Internal.SymPrim.AlgReal.RealPoint
instance GHC.Internal.Exception.Type.Exception Grisette.Internal.SymPrim.AlgReal.UnsupportedAlgRealOperation
instance GHC.Internal.Real.Fractional Grisette.Internal.SymPrim.AlgReal.AlgReal
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.AlgReal.AlgReal
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.AlgReal.RealPoint
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.AlgReal.RealPoint
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.AlgReal.RealPoint
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.AlgReal.RealPoint
instance GHC.Internal.Num.Num Grisette.Internal.SymPrim.AlgReal.AlgReal
instance GHC.Classes.Ord Grisette.Internal.SymPrim.AlgReal.AlgReal
instance GHC.Internal.Real.Real Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.AlgReal.RealPoint
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.AlgReal.AlgRealPoly
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.AlgReal.RealPoint
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.AlgReal.AlgReal
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.AlgReal.UnsupportedAlgRealOperation


module Grisette.Internal.SymPrim.IntBitwidth

-- | Get the bitwidth of <a>Int</a>.
intBitwidthQ :: TypeQ


module Grisette.Internal.SymPrim.Prim.Internal.Utils

-- | Pattern synonym for dynamic type casting.
pattern Dyn :: (Typeable a, Typeable b) => a -> b

-- | Compare two values of different types.
cmpHetero :: (Typeable a, Typeable b) => (a -> a -> Bool) -> a -> b -> Bool

-- | Compare two values of different types for equality.
eqHetero :: (Typeable a, Typeable b, Eq a) => a -> b -> Bool

-- | Compare two values of different types, resolve the type equality using
--   the type representation.
cmpHeteroRep :: TypeRep a -> TypeRep b -> (a -> a -> Bool) -> a -> b -> Bool

-- | Compare two values of different types for equality, resolve the type
--   equality using the type representation.
eqHeteroRep :: Eq a => TypeRep a -> TypeRep b -> a -> b -> Bool

-- | Compare two type representations for equality.
eqTypeRepBool :: forall ka kb (a :: ka) (b :: kb). TypeRep a -> TypeRep b -> Bool

-- | A weak identifier to a thread id that doesn't prevent its garbage
--   collection.
type WeakThreadId = Word64

-- | Get an id of a thread that doesn't prevent its garbage collection.
weakThreadId :: ThreadId -> Word64

-- | A weak reference to a thread id that doesn't prevent its garbage
--   collection.
type WeakThreadIdRef = Weak ThreadId

-- | Get a weak identifier to the current thread id.
myWeakThreadId :: IO WeakThreadId

-- | Check if a weak reference to a thread id is still alive.
weakThreadRefAlive :: WeakThreadIdRef -> IO Bool

-- | Create a weak reference to a thread id with a finalizer.
mkWeakThreadIdRefWithFinalizer :: ThreadId -> IO () -> IO (Weak ThreadId)

-- | Add a finalizer to a stable name.
addStableNameFinalizer :: StableName a -> IO () -> IO ()

-- | Add a finalizer to a thread id.
addThreadIdFinalizer :: ThreadId -> IO () -> IO ()

-- | Create a weak reference to a stable name with a finalizer.
mkWeakStableNameRefWithFinalizer :: StableName a -> IO () -> IO (Weak (StableName a))

-- | A type-erased stable name.
data SomeStableName
[SomeStableName] :: forall a. StableName a -> SomeStableName

-- | Create a weak reference to a stable name with a finalizer.
mkWeakSomeStableNameRefWithFinalizer :: SomeStableName -> IO () -> IO (Weak SomeStableName)

-- | Create a weak reference to a stable name.
mkWeakSomeStableNameRef :: SomeStableName -> IO (Weak SomeStableName)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Utils.SomeStableName


module Grisette.Internal.SymPrim.Prim.Internal.Caches

-- | A type-erased stable name.
data SomeStableName
[SomeStableName] :: forall a. StableName a -> SomeStableName

-- | A unique identifier for a term.
type Id = Word32

-- | The identity of a term.
type StableIdent = StableName Any :: Type

-- | A digest of a term.
type Digest = Word32

-- | Information about a cached term.
data CachedInfo
CachedInfo :: {-# UNPACK #-} !WeakThreadId -> {-# UNPACK #-} !Digest -> {-# UNPACK #-} !Id -> {-# UNPACK #-} !StableIdent -> CachedInfo
[cachedThreadId] :: CachedInfo -> {-# UNPACK #-} !WeakThreadId
[cachedDigest] :: CachedInfo -> {-# UNPACK #-} !Digest
[cachedId] :: CachedInfo -> {-# UNPACK #-} !Id
[cachedStableIdent] :: CachedInfo -> {-# UNPACK #-} !StableIdent

-- | A class for interning terms.
class Interned t where {
    data Description t;
    type Uninterned t;
}
describe :: Interned t => Uninterned t -> Description t
identify :: Interned t => CachedInfo -> Uninterned t -> t
threadId :: Interned t => t -> WeakThreadId
descriptionDigest :: Interned t => Description t -> Digest

-- | Internalize a term.
intern :: (Interned t, Typeable t, Hashable (Description t), Eq (Description t)) => Uninterned t -> IO t

-- | Check if the current thread has a cache.
haveCache :: IO Bool

-- | Get the size of the current thread's cache.
threadCacheSize :: WeakThreadId -> IO Int

-- | Get the live size of the current thread's cache.
threadCacheLiveSize :: WeakThreadId -> IO Int


module Grisette.Internal.TH.Ctor.Common

-- | Generate smart constructor given a type name, using a name transformer
--   to transform constructor names.
withNameTransformer :: ([String] -> Name -> Q [Dec]) -> (String -> String) -> Name -> Q [Dec]

-- | A name transformer that prefixes a string to the constructor name
prefixTransformer :: String -> String -> String

-- | A name transformer that converts the first character to lowercase
decapitalizeTransformer :: String -> String


module Grisette.Internal.Unified.EvalModeTag

-- | Evaluation mode for unified types. <a>C</a> means concrete evaluation,
--   <a>S</a> means symbolic evaluation.
data EvalModeTag
C :: EvalModeTag
S :: EvalModeTag

-- | Type family to check if a mode is <a>C</a>.
type family IsConMode (mode :: EvalModeTag) = (r :: Bool) | r -> mode
instance GHC.Classes.Eq Grisette.Internal.Unified.EvalModeTag.EvalModeTag
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.Unified.EvalModeTag.EvalModeTag
instance GHC.Internal.Show.Show Grisette.Internal.Unified.EvalModeTag.EvalModeTag


module Grisette.Internal.TH.Util

-- | Convert a <a>ConstructorInfo</a> to a <a>Type</a> of the constructor.
constructorInfoToType :: DatatypeInfo -> ConstructorInfo -> Q Type

-- | Check if a type variable is of kind <a>EvalModeTag</a>.
tvIsMode :: TyVarBndr_ flag -> Bool

-- | Check if a type variable is of kind <a>Nat</a>.
tvIsNat :: TyVarBndr_ flag -> Bool

-- | Check if a type variable is of kind <a>Type</a>.
tvIsStar :: TyVarBndr_ flag -> Bool

-- | Check if a type variable is of kind 'Data.Kind.Type -&gt;
--   Data.Kind.Type'.
tvIsStarToStar :: TyVarBndr_ flag -> Bool

-- | Substitute the type variables in a <a>DatatypeInfo</a> with the given
--   substitution map.
substDataType :: DatatypeInfo -> Map Name Type -> DatatypeInfo

-- | Reify a datatype with fresh type variable names.
reifyDatatypeWithFreshNames :: Name -> Q DatatypeInfo

-- | Get the kind of the single type parameter of a class.
singleParamClassParamKind :: Name -> Q Kind

-- | Get the kind of the binary type parameter of a class.
binaryClassParamKind :: Name -> Q Kind

-- | Get a type with a possible substitution.
getTypeWithMaybeSubst :: TyVarBndrUnit -> Maybe Type -> Q Type

-- | Drop the last instantiated type parameter of a type.
dropLastTypeParam :: Type -> Q Type

-- | Drop the last N instantiated type parameters of a type.
dropNTypeParam :: Int -> Type -> Q Type

-- | Get the kinds of the type parameters of a class.
classParamKinds :: Name -> Q [Kind]

-- | Check if all type variables have the same kind.
allSameKind :: [TyVarBndrUnit] -> Bool

-- | Get the number of type parameters of a class.
classNumParam :: Name -> Q Int

-- | Get the number of type parameters of a kind.
kindNumParam :: Kind -> Q Int

-- | Concatenate two 'Maybe [Pred]'.
concatPreds :: Maybe [Pred] -> Maybe [Pred] -> Maybe [Pred]

-- | Put a haddock comment on a declaration.
putHaddock :: Name -> String -> Q ()

-- | Get the names used in an expression.
allUsedNamesMaybe :: Maybe Exp -> Set Name

-- | Get the names used in an expression.
allUsedNames :: Exp -> Set Name

-- | Check if a string is the data constructor name of a non-unit tuple.
isNonUnitTupleString :: String -> Bool

-- | Check if a name is the data constructor name of a non-unit tuple.
isNonUnitTuple :: Name -> Bool

-- | Convert an integer to an <a>Exp</a>.
integerE :: Integral a => a -> Q Exp

-- | Mangle a name string to contain only alphanumeric characters and
--   underscores.
mangleName :: Name -> String

-- | Check if a data type has existential variables in constructors.
dataTypeHasExistential :: Name -> Q Bool


module Grisette.Internal.Unified.Theories

-- | This data type is used to represent the theories that is unified.
--   
--   The <a>UFun</a> constructor is used to represent a specific
--   uninterpreted function type. The type is uncurried.
data TheoryToUnify
UBool :: TheoryToUnify
UIntN :: TheoryToUnify
UWordN :: TheoryToUnify
UInteger :: TheoryToUnify
UAlgReal :: TheoryToUnify
UFP :: TheoryToUnify
UFun :: [TheoryToUnify] -> TheoryToUnify

-- | Check if the theory is a uninterpreted function.
isUFun :: TheoryToUnify -> Bool
instance GHC.Classes.Eq Grisette.Internal.Unified.Theories.TheoryToUnify
instance GHC.Internal.Show.Show Grisette.Internal.Unified.Theories.TheoryToUnify


module Grisette.Internal.Utils.Derive

-- | Type-level tag for generic derivation with arity 0.
data Arity0

-- | Type-level tag for generic derivation with arity 1.
data Arity1


module Grisette.Internal.Utils.Parameterized

-- | Assert a proof of equality between two types. This is unsafe if used
--   improperly, so use this with caution!
unsafeAxiom :: forall {k} (a :: k) (b :: k). a :~: b

-- | Existential wrapper for <a>NatRepr</a>.
data SomeNatRepr
[SomeNatRepr] :: forall (n :: Nat). KnownNat n => NatRepr n -> SomeNatRepr

-- | Existential wrapper for <a>NatRepr</a> with the constraint that the
--   natural number is greater than 0.
data SomePositiveNatRepr
[SomePositiveNatRepr] :: forall (n :: Nat). (KnownNat n, 1 <= n) => NatRepr n -> SomePositiveNatRepr

-- | A runtime representation of type-level natural numbers. This can be
--   used for performing dynamic checks on type-level natural numbers.
data NatRepr (n :: Nat)

-- | Construct the <a>KnownNat</a> constraint when the runtime value is
--   known.
withKnownNat :: forall (n :: Nat) r. NatRepr n -> (KnownNat n => r) -> r

-- | The underlying runtime natural number value of a type-level natural
--   number.
natValue :: forall (n :: Nat). NatRepr n -> Natural

-- | Turn a <tt>Natural</tt> into the corresponding <tt>NatRepr</tt> with
--   the KnownNat constraint.
mkNatRepr :: Natural -> SomeNatRepr

-- | Turn a <tt>NatRepr</tt> into the corresponding <tt>NatRepr</tt> with
--   the KnownNat constraint and asserts that its greater than 0.
mkPositiveNatRepr :: Natural -> SomePositiveNatRepr

-- | Construct a runtime representation of a type-level natural number when
--   its runtime value is known.
natRepr :: forall (n :: Nat). KnownNat n => NatRepr n

-- | Decrement a <a>NatRepr</a> by 1.
decNat :: forall (n :: Natural). 1 <= n => NatRepr n -> NatRepr (n - 1)

-- | Predecessor of a <a>NatRepr</a>
predNat :: forall (n :: Natural). NatRepr (n + 1) -> NatRepr n

-- | Increment a <a>NatRepr</a> by 1.
incNat :: forall (n :: Nat). NatRepr n -> NatRepr (n + 1)

-- | Addition of two <a>NatRepr</a>s.
addNat :: forall (m :: Nat) (n :: Nat). NatRepr m -> NatRepr n -> NatRepr (m + n)

-- | Subtraction of two <a>NatRepr</a>s.
subNat :: forall (n :: Nat) (m :: Nat). n <= m => NatRepr m -> NatRepr n -> NatRepr (m - n)

-- | Division of two <a>NatRepr</a>s.
divNat :: forall (n :: Natural) (m :: Nat). 1 <= n => NatRepr m -> NatRepr n -> NatRepr (Div m n)

-- | Half of a <a>NatRepr</a>.
halfNat :: forall (n :: Natural). NatRepr (n + n) -> NatRepr n

-- | <tt>'KnownProof n'</tt> is a type whose values are only inhabited when
--   <tt>n</tt> has a known runtime value.
data KnownProof (n :: Nat)
[KnownProof] :: forall (n :: Nat). KnownNat n => KnownProof n

-- | Construct a <a>KnownProof</a> given the runtime representation.
hasRepr :: forall (n :: Nat). NatRepr n -> KnownProof n

-- | Introduces the <a>KnownNat</a> constraint when it's proven.
withKnownProof :: forall (n :: Nat) r. KnownProof n -> (KnownNat n => r) -> r

-- | Construct a <a>KnownProof</a> given the runtime value.
--   
--   <b>Note:</b> This function is unsafe, as it does not check that the
--   runtime representation is consistent with the type-level
--   representation. You should ensure the consistency yourself or the
--   program can crash or generate incorrect results.
unsafeKnownProof :: forall (n :: Nat). Natural -> KnownProof n

-- | Adding two type-level natural numbers with known runtime values gives
--   a type-level natural number with a known runtime value.
knownAdd :: forall (m :: Nat) (n :: Nat). KnownProof m -> KnownProof n -> KnownProof (m + n)

-- | Proof that the comparison of two type-level natural numbers is
--   consistent with the runtime comparison.
data CmpNatProof (m :: Nat) (n :: Nat) (o :: Ordering)
[CmpNatProof] :: forall (m :: Nat) (n :: Nat) (o :: Ordering). (CmpNat m n == o) ~ 'True => CmpNatProof m n o

-- | Construct a <a>CmpNatProof</a>.
unsafeCmpNatProof :: forall (m :: Nat) (n :: Nat) (o :: Ordering). CmpNatProof m n o

-- | Introduces the <tt><a>CmpNat</a> m n o</tt> constraint when it's
--   proven.
withCmpNatProof :: forall (m :: Nat) (n :: Nat) (o :: Ordering) r. CmpNatProof m n o -> ((CmpNat m n == o) ~ 'True => r) -> r

-- | <tt>'LeqProof m n'</tt> is a type whose values are only inhabited when
--   <tt>m &lt;= n</tt>.
data LeqProof (m :: Nat) (n :: Nat)
[LeqProof] :: forall (m :: Nat) (n :: Nat). m <= n => LeqProof m n

-- | Introduces the <tt>m &lt;= n</tt> constraint when it's proven.
withLeqProof :: forall (m :: Nat) (n :: Nat) r. LeqProof m n -> (m <= n => r) -> r

-- | Construct a <a>LeqProof</a>.
--   
--   <b>Note:</b> This function is unsafe, as it does not check that the
--   left-hand side is less than or equal to the right-hand side. You
--   should ensure the consistency yourself or the program can crash or
--   generate incorrect results.
unsafeLeqProof :: forall (m :: Nat) (n :: Nat). LeqProof m n

-- | Checks if a <a>NatRepr</a> is less than or equal to another
--   <a>NatRepr</a>.
testLeq :: forall (m :: Nat) (n :: Nat). NatRepr m -> NatRepr n -> Maybe (LeqProof m n)

-- | Apply reflexivity to <a>LeqProof</a>.
leqRefl :: forall f (n :: Nat). f n -> LeqProof n n

-- | A natural number is less than or equal to its successor.
leqSucc :: forall f (n :: Nat). f n -> LeqProof n (n + 1)

-- | Apply transitivity to <a>LeqProof</a>.
leqTrans :: forall (a :: Nat) (b :: Nat) (c :: Nat). LeqProof a b -> LeqProof b c -> LeqProof a c

-- | Zero is less than or equal to any natural number.
leqZero :: forall (n :: Nat). LeqProof 0 n

-- | Add both sides of two inequalities.
leqAdd2 :: forall (xl :: Nat) (xh :: Nat) (yl :: Nat) (yh :: Nat). LeqProof xl xh -> LeqProof yl yh -> LeqProof (xl + yl) (xh + yh)

-- | Produce proof that adding a value to the larger element in an
--   <a>LeqProof</a> is larger.
leqAdd :: forall (m :: Nat) (n :: Nat) f (o :: Natural). LeqProof m n -> f o -> LeqProof m (n + o)

-- | Adding two positive natural numbers is positive.
leqAddPos :: forall (m :: Natural) (n :: Natural) p q. (1 <= m, 1 <= n) => p m -> q n -> LeqProof 1 (m + n)


module Grisette.Internal.Unified.Util

-- | A class that provides the mode tag at runtime.
class DecideEvalMode (mode :: EvalModeTag)
decideEvalMode :: DecideEvalMode mode => EvalModeTag

-- | Case analysis on the mode.
withMode :: forall (mode :: EvalModeTag) r. DecideEvalMode mode => (mode ~ 'C => r) -> (mode ~ 'S => r) -> r

-- | A class saying that we can convert a value with one mode to another
--   mode.
--   
--   Allowed conversions:
--   
--   <ul>
--   <li><a>C</a> <a>-</a> <a>C</a></li>
--   <li><a>S</a> <a>-</a> <a>S</a></li>
--   <li><a>C</a> <a>-</a> <a>S</a></li>
--   </ul>
--   
--   Conversion from left to right uses <a>ToSym</a> class, and conversion
--   from right to left uses <a>ToCon</a> class.
class (DecideEvalMode c, DecideEvalMode s) => EvalModeConvertible (c :: EvalModeTag) (s :: EvalModeTag)
withModeConvertible :: EvalModeConvertible c s => (c ~ 'C => r) -> (s ~ 'S => r) -> r
withModeConvertible' :: EvalModeConvertible c s => ((c ~ 'C, s ~ 'C) => r) -> ((c ~ 'C, s ~ 'S) => r) -> ((c ~ 'S, s ~ 'S) => r) -> r
instance Grisette.Internal.Unified.Util.DecideEvalMode 'Grisette.Internal.Unified.EvalModeTag.C
instance Grisette.Internal.Unified.Util.DecideEvalMode 'Grisette.Internal.Unified.EvalModeTag.S
instance Grisette.Internal.Unified.Util.DecideEvalMode s => Grisette.Internal.Unified.Util.EvalModeConvertible 'Grisette.Internal.Unified.EvalModeTag.C s
instance Grisette.Internal.Unified.Util.DecideEvalMode c => Grisette.Internal.Unified.Util.EvalModeConvertible c 'Grisette.Internal.Unified.EvalModeTag.S
instance Grisette.Internal.Unified.Util.DecideEvalMode c => Grisette.Internal.Unified.Util.EvalModeConvertible c c


module Grisette.Internal.Core.Data.Class.BitVector

-- | Bit vector operations. Including concatenation (<a>bvConcat</a>),
--   extension (<a>bvZext</a>, <a>bvSext</a>, <a>bvExt</a>), and selection
--   (<a>bvSelect</a>).
class BV bv

-- | Concatenation of two bit vectors.
--   
--   <pre>
--   &gt;&gt;&gt; bvConcat (SomeSymWordN (0b101 :: SymWordN 3)) (SomeSymWordN (0b010 :: SymWordN 3))
--   0b101010
--   </pre>
bvConcat :: BV bv => bv -> bv -> bv

-- | Zero extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; bvZext 6 (SomeSymWordN (0b101 :: SymWordN 3))
--   0b000101
--   </pre>
bvZext :: BV bv => Int -> bv -> bv

-- | Sign extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; bvSext 6 (SomeSymWordN (0b101 :: SymWordN 3))
--   0b111101
--   </pre>
bvSext :: BV bv => Int -> bv -> bv

-- | Extension of a bit vector. Signedness is determined by the input bit
--   vector type.
--   
--   <pre>
--   &gt;&gt;&gt; bvExt 6 (SomeSymIntN (0b101 :: SymIntN 3))
--   0b111101
--   
--   &gt;&gt;&gt; bvExt 6 (SomeSymIntN (0b001 :: SymIntN 3))
--   0b000001
--   
--   &gt;&gt;&gt; bvExt 6 (SomeSymWordN (0b101 :: SymWordN 3))
--   0b000101
--   
--   &gt;&gt;&gt; bvExt 6 (SomeSymWordN (0b001 :: SymWordN 3))
--   0b000001
--   </pre>
bvExt :: BV bv => Int -> bv -> bv

-- | Slicing out a smaller bit vector from a larger one, selecting a slice
--   with width <tt>w</tt> starting from index <tt>ix</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; bvSelect 1 3 (SomeSymIntN (0b001010 :: SymIntN 6))
--   0b101
--   </pre>
bvSelect :: BV bv => Int -> Int -> bv -> bv

-- | Create a bit vector from an integer. The bit-width is the first
--   argument, which should not be zero.
--   
--   <pre>
--   &gt;&gt;&gt; bv 12 21 :: SomeSymIntN
--   0x015
--   </pre>
bv :: (BV bv, Integral a) => Int -> a -> bv

-- | Slicing out a smaller bit vector from a larger one, extract a slice
--   from bit <tt>i</tt> down to <tt>j</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; bvExtract 4 2 (SomeSymIntN (0b010100 :: SymIntN 6))
--   0b101
--   </pre>
bvExtract :: BV bv => Int -> Int -> bv -> bv

-- | Sized bit vector operations. Including concatenation
--   (<a>sizedBVConcat</a>), extension (<a>sizedBVZext</a>,
--   <a>sizedBVSext</a>, <a>sizedBVExt</a>), and selection
--   (<a>sizedBVSelect</a>).
class SizedBV (bv :: Nat -> Type)

-- | Concatenation of two bit vectors.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVConcat (0b101 :: SymIntN 3) (0b010 :: SymIntN 3)
--   0b101010
--   </pre>
sizedBVConcat :: forall (l :: Nat) (r :: Nat). (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r) => bv l -> bv r -> bv (l + r)

-- | Zero extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVZext (Proxy @6) (0b101 :: SymIntN 3)
--   0b000101
--   </pre>
sizedBVZext :: forall (l :: Nat) (r :: Nat) proxy. (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, KnownNat r, l <= r) => proxy r -> bv l -> bv r

-- | Signed extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVSext (Proxy @6) (0b101 :: SymIntN 3)
--   0b111101
--   </pre>
sizedBVSext :: forall (l :: Nat) (r :: Nat) proxy. (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, KnownNat r, l <= r) => proxy r -> bv l -> bv r

-- | Extension of a bit vector. Signedness is determined by the input bit
--   vector type.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: SymIntN 3)
--   0b111101
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b001 :: SymIntN 3)
--   0b000001
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: SymWordN 3)
--   0b000101
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b001 :: SymWordN 3)
--   0b000001
--   </pre>
sizedBVExt :: forall (l :: Nat) (r :: Nat) proxy. (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, KnownNat r, l <= r) => proxy r -> bv l -> bv r

-- | Slicing out a smaller bit vector from a larger one, selecting a slice
--   with width <tt>w</tt> starting from index <tt>ix</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVSelect (Proxy @2) (Proxy @3) (con 0b010100 :: SymIntN 6)
--   0b101
--   </pre>
sizedBVSelect :: forall (n :: Nat) (ix :: Nat) (w :: Nat) p q. (SizedBV bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n) => p ix -> q w -> bv n -> bv w
sizedBVFromIntegral :: forall a (n :: Nat). (SizedBV bv, Integral a, KnownNat n, 1 <= n) => a -> bv n
($dmsizedBVFromIntegral) :: forall (n :: Nat) a. (SizedBV bv, Num (bv n), Integral a, KnownNat n, 1 <= n) => a -> bv n

-- | Slicing out a smaller bit vector from a larger one, extract a slice
--   from bit <tt>i</tt> down to <tt>j</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVExtract (Proxy @4) (Proxy @2) (con 0b010100 :: SymIntN 6)
--   0b101
--   </pre>
sizedBVExtract :: forall p (i :: Nat) q (j :: Nat) (n :: Nat) bv. (SizedBV bv, KnownNat n, KnownNat i, KnownNat j, 1 <= n, (i + 1) <= n, j <= i) => p i -> q j -> bv n -> bv ((i - j) + 1)


module Grisette.Internal.SymPrim.BV

-- | Signed bit vector type. Indexed with the bit width. Signedness affects
--   the semantics of the operations, including comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; 3 + 5 :: IntN 5
--   0b01000
--   
--   &gt;&gt;&gt; sizedBVConcat (0b101 :: IntN 3) (0b110 :: IntN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: IntN 3)
--   0b111101
--   
--   &gt;&gt;&gt; (8 :: IntN 4) &lt; (7 :: IntN 4)
--   True
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype IntN (n :: Nat)
IntN :: Integer -> IntN (n :: Nat)
[unIntN] :: IntN (n :: Nat) -> Integer

-- | 8-bit signed bit-vector
type IntN8 = IntN 8

-- | 16-bit signed bit-vector
type IntN16 = IntN 16

-- | 32-bit signed bit-vector
type IntN32 = IntN 32

-- | 64-bit signed bit-vector
type IntN64 = IntN 64

-- | Unsigned bit vector type. Indexed with the bit width. Signedness
--   affect the semantics of the operations, including
--   comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; 3 + 5 :: WordN 5
--   0b01000
--   
--   &gt;&gt;&gt; sizedBVConcat (0b101 :: WordN 3) (0b110 :: WordN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: WordN 3)
--   0b000101
--   
--   &gt;&gt;&gt; (8 :: WordN 4) &lt; (7 :: WordN 4)
--   False
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype WordN (n :: Nat)
WordN :: Integer -> WordN (n :: Nat)
[unWordN] :: WordN (n :: Nat) -> Integer

-- | 8-bit unsigned bit-vector
type WordN8 = WordN 8

-- | 16-bit unsigned bit-vector
type WordN16 = WordN 16

-- | 32-bit unsigned bit-vector
type WordN32 = WordN 32

-- | 64-bit unsigned bit-vector
type WordN64 = WordN 64

-- | Read a binary number.
readBinary :: Num a => ReadPrec a
instance Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Test.QuickCheck.Arbitrary.Arbitrary (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Test.QuickCheck.Arbitrary.Arbitrary (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Bool (Grisette.Internal.SymPrim.BV.IntN 1)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Bool (Grisette.Internal.SymPrim.BV.WordN 1)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Double Grisette.Internal.SymPrim.BV.IntN64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Double Grisette.Internal.SymPrim.BV.WordN64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Float Grisette.Internal.SymPrim.BV.IntN32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Float Grisette.Internal.SymPrim.BV.WordN32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int16 (Grisette.Internal.SymPrim.BV.IntN 16)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int16 (Grisette.Internal.SymPrim.BV.WordN 16)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int32 (Grisette.Internal.SymPrim.BV.IntN 32)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int32 (Grisette.Internal.SymPrim.BV.WordN 32)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int64 (Grisette.Internal.SymPrim.BV.IntN 64)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int64 (Grisette.Internal.SymPrim.BV.WordN 64)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int8 (Grisette.Internal.SymPrim.BV.IntN 8)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int8 (Grisette.Internal.SymPrim.BV.WordN 8)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 1) GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast Grisette.Internal.SymPrim.BV.IntN64 GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast Grisette.Internal.SymPrim.BV.IntN32 GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 16) GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 32) GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 64) GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 8) GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 16) GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 32) GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 64) GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN 8) GHC.Internal.Word.Word8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word16 (Grisette.Internal.SymPrim.BV.IntN 16)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word16 (Grisette.Internal.SymPrim.BV.WordN 16)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word32 (Grisette.Internal.SymPrim.BV.IntN 32)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word32 (Grisette.Internal.SymPrim.BV.WordN 32)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word64 (Grisette.Internal.SymPrim.BV.IntN 64)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word64 (Grisette.Internal.SymPrim.BV.WordN 64)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word8 (Grisette.Internal.SymPrim.BV.IntN 8)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word8 (Grisette.Internal.SymPrim.BV.WordN 8)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 1) GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast Grisette.Internal.SymPrim.BV.WordN64 GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast Grisette.Internal.SymPrim.BV.WordN32 GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 16) GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 32) GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 64) GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 8) GHC.Internal.Int.Int8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 16) GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 32) GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 64) GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN 8) GHC.Internal.Word.Word8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.Bits (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.Bits (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Bounded (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Bounded (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Enum (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Enum (Grisette.Internal.SymPrim.BV.WordN n)
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.BV.IntN n)
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.FiniteBits (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.FiniteBits (Grisette.Internal.SymPrim.BV.WordN n)
instance GHC.Internal.Generics.Generic (Grisette.Internal.SymPrim.BV.IntN n)
instance GHC.Internal.Generics.Generic (Grisette.Internal.SymPrim.BV.WordN n)
instance Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.BV.IntN n)
instance Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Integral (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Integral (Grisette.Internal.SymPrim.BV.WordN n)
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.BV.IntN n)
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.BV.WordN n)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.BV.IntN n)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Ord (Grisette.Internal.SymPrim.BV.IntN n)
instance GHC.Classes.Ord (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Read.Read (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Read.Read (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Real (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Real (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Serialize.Serialize (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Serialize.Serialize (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SignConversion.SignConversion (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.BitVector.SizedBV Grisette.Internal.SymPrim.BV.IntN
instance Grisette.Internal.Core.Data.Class.BitVector.SizedBV Grisette.Internal.SymPrim.BV.WordN
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.SymPrim.FP

-- | A type-level proof that the given bit-widths are valid for a
--   floating-point number.
type ValidFP (eb :: Nat) (sb :: Nat) = ValidFloat eb sb

-- | IEEE 754 floating-point number with <tt>eb</tt> exponent bits and
--   <tt>sb</tt> significand bits.
--   
--   <pre>
--   &gt;&gt;&gt; 1.0 + 2.0 :: FP 11 53
--   3.0
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype FP (eb :: Nat) (sb :: Nat)
FP :: FloatingPoint eb sb -> FP (eb :: Nat) (sb :: Nat)
[unFP] :: FP (eb :: Nat) (sb :: Nat) -> FloatingPoint eb sb

-- | IEEE 754 half-precision floating-point number.
type FP16 = FP 5 11

-- | IEEE 754 single-precision floating-point number.
type FP32 = FP 8 24

-- | IEEE 754 double-precision floating-point number.
type FP64 = FP 11 53

-- | Some type-level witnesses that could be derived from <a>ValidFP</a>.
withValidFPProofs :: forall (eb :: Nat) (sb :: Nat) r. ValidFP eb sb => ((KnownNat (eb + sb), BVIsNonZero (eb + sb), 1 <= (eb + sb), 1 <= eb, 1 <= sb) => r) -> r

-- | Rounding mode for floating-point operations.
data FPRoundingMode

-- | Round to nearest, ties to even.
RNE :: FPRoundingMode

-- | Round to nearest, ties to away from zero.
RNA :: FPRoundingMode

-- | Round towards positive infinity.
RTP :: FPRoundingMode

-- | Round towards negative infinity.
RTN :: FPRoundingMode

-- | Round towards zero.
RTZ :: FPRoundingMode

-- | All IEEE 754 rounding modes.
allFPRoundingMode :: [FPRoundingMode]

-- | An error thrown when bitcasting or converting <a>FP</a> NaN to other
--   types.
data NotRepresentableFPError
NaNError :: NotRepresentableFPError
FPUnderflowError :: NotRepresentableFPError
FPOverflowError :: NotRepresentableFPError

-- | Bounds for converting bit vectors to floating-point numbers.
--   Out-of-range FP values cannot be converted to a representable
--   bit-vector.
class ConvertibleBound (bv :: Nat -> Type)
convertibleLowerBound :: forall (eb :: Nat) (sb :: Nat) (n :: Nat). (ConvertibleBound bv, ValidFP eb sb, KnownNat n, 1 <= n) => bv n -> FPRoundingMode -> FP eb sb
convertibleUpperBound :: forall (eb :: Nat) (sb :: Nat) (n :: Nat). (ConvertibleBound bv, ValidFP eb sb, KnownNat n, 1 <= n) => bv n -> FPRoundingMode -> FP eb sb

-- | Next representable floating-point number.
--   
--   Note:
--   
--   <pre>
--   nextFP(+inf) = +inf
--   nextFP(-inf) = -maxNormalized
--   nextFP(NaN) = NaN
--   </pre>
--   
--   The function do not distinguish between -0 and +0.
nextFP :: forall (eb :: Nat) (sb :: Nat). ValidFP eb sb => FP eb sb -> FP eb sb

-- | Previous representable floating-point number.
--   
--   Note:
--   
--   <pre>
--   prevFP(+inf) = +maxNormalized
--   prevFP(-inf) = -inf
--   prevFP(NaN) = NaN
--   </pre>
--   
--   The function do not distinguish between -0 and +0.
prevFP :: forall (eb :: Nat) (sb :: Nat). ValidFP eb sb => FP eb sb -> FP eb sb

-- | Provide an (unsafe) type-level proof that the given floating-point
--   type is valid.
withUnsafeValidFP :: forall (eb :: Nat) (sb :: Nat) r. (KnownNat eb, KnownNat sb) => (ValidFP eb sb => r) -> r

-- | Check if the given floating-point type is valid.
checkDynamicValidFP :: Natural -> Natural -> Bool

-- | A message thrown when the floating-point type is invalid.
invalidFPMessage :: String
instance Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.Function.Apply Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Data.SBV.Core.Kind.ValidFloat eb sb => Test.QuickCheck.Arbitrary.Arbitrary (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Test.QuickCheck.Arbitrary.Arbitrary Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP64 GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP32 GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP16 GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP32 GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP64 GHC.Internal.Int.Int64
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP16 GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP32 GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical Grisette.Internal.SymPrim.FP.FP64 GHC.Internal.Word.Word64
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP64 GHC.Types.Double
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP32 GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP16 GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP32 GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP64 GHC.Internal.Int.Int64
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP16 GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP32 GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr Grisette.Internal.SymPrim.FP.FP64 GHC.Internal.Word.Word64
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.WordN r)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Double Grisette.Internal.SymPrim.FP.FP64
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Types.Float Grisette.Internal.SymPrim.FP.FP32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int16 Grisette.Internal.SymPrim.FP.FP16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int32 Grisette.Internal.SymPrim.FP.FP32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Int.Int64 Grisette.Internal.SymPrim.FP.FP64
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.IntN r) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word16 Grisette.Internal.SymPrim.FP.FP16
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word32 Grisette.Internal.SymPrim.FP.FP32
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast GHC.Internal.Word.Word64 Grisette.Internal.SymPrim.FP.FP64
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.BV.WordN r) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.FP.ConvertibleBound Grisette.Internal.SymPrim.BV.IntN
instance Grisette.Internal.SymPrim.FP.ConvertibleBound Grisette.Internal.SymPrim.BV.WordN
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.FP.FP eb sb)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.FP.FPRoundingMode
instance GHC.Classes.Eq Grisette.Internal.SymPrim.FP.NotRepresentableFPError
instance GHC.Internal.Exception.Type.Exception Grisette.Internal.SymPrim.FP.NotRepresentableFPError
instance Data.SBV.Core.Kind.ValidFloat eb sb => GHC.Internal.Float.Floating (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Data.SBV.Core.Kind.ValidFloat eb sb => GHC.Internal.Real.Fractional (Grisette.Internal.SymPrim.FP.FP eb sb)
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.FP.FPRoundingMode
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.FP.NotRepresentableFPError
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConstants (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible Grisette.Internal.SymPrim.AlgReal.AlgReal (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, Grisette.Internal.SymPrim.FP.ValidFP eb' sb') => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.SymPrim.FP.FP eb' sb') (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPOp (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingMode Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingOp (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal Grisette.Internal.SymPrim.AlgReal.AlgReal (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Data.SBV.Core.Kind.ValidFloat eb sb => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Classes.Ord (Grisette.Internal.SymPrim.FP.FP eb sb)
instance GHC.Classes.Ord Grisette.Internal.SymPrim.FP.FPRoundingMode
instance GHC.Classes.Ord Grisette.Internal.SymPrim.FP.NotRepresentableFPError
instance Data.SBV.Core.Kind.ValidFloat eb sb => GHC.Internal.Real.Real (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Data.SBV.Core.Kind.ValidFloat eb sb => GHC.Internal.Float.RealFloat (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Data.SBV.Core.Kind.ValidFloat eb sb => GHC.Internal.Real.RealFrac (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Serialize.Serialize (Grisette.Internal.SymPrim.FP.FP eb sb)
instance GHC.Internal.Show.Show (Grisette.Internal.SymPrim.FP.FP eb sb)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.FP.FPRoundingMode
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.FP.NotRepresentableFPError


module Grisette.Internal.SymPrim.Prim.Internal.Term

-- | Type class for resolving the constraint for a supported primitive
--   type.
class SupportedPrimConstraint t where {
    type PrimConstraint t;
    type PrimConstraint t = ();
}

-- | Indicates that a type is supported, can be represented as a symbolic
--   term, and can be lowered to an SBV term.
class (Lift t, NFData t, Typeable t, SupportedPrimConstraint t, SBVRep t) => SupportedPrim t
primTypeRep :: SupportedPrim t => TypeRep t
($dmprimTypeRep) :: (SupportedPrim t, Typeable t) => TypeRep t
sameCon :: SupportedPrim t => t -> t -> Bool
($dmsameCon) :: (SupportedPrim t, Eq t) => t -> t -> Bool
hashConWithSalt :: SupportedPrim t => Int -> t -> Int
($dmhashConWithSalt) :: (SupportedPrim t, Hashable t) => Int -> t -> Int
pformatCon :: SupportedPrim t => t -> String
($dmpformatCon) :: (SupportedPrim t, Show t) => t -> String
defaultValue :: SupportedPrim t => t
pevalITETerm :: SupportedPrim t => Term Bool -> Term t -> Term t -> Term t
pevalEqTerm :: SupportedPrim t => Term t -> Term t -> Term Bool
pevalDistinctTerm :: SupportedPrim t => NonEmpty (Term t) -> Term Bool
conSBVTerm :: SupportedPrim t => t -> SBVType t
symSBVName :: SupportedPrim t => TypedSymbol 'AnyKind t -> Int -> String
symSBVTerm :: (SupportedPrim t, SBVFreshMonad m) => String -> m (SBVType t)
withPrim :: SupportedPrim t => ((PrimConstraint t, SMTDefinable (SBVType t), Mergeable (SBVType t), Typeable (SBVType t)) => a) -> a
($dmwithPrim) :: (SupportedPrim t, PrimConstraint t, SMTDefinable (SBVType t), Mergeable (SBVType t), Typeable (SBVType t)) => ((PrimConstraint t, SMTDefinable (SBVType t), Mergeable (SBVType t), Typeable (SBVType t)) => a) -> a
sbvIte :: SupportedPrim t => SBV Bool -> SBVType t -> SBVType t -> SBVType t
sbvEq :: SupportedPrim t => SBVType t -> SBVType t -> SBV Bool
($dmsbvEq) :: (SupportedPrim t, EqSymbolic (SBVType t)) => SBVType t -> SBVType t -> SBV Bool
sbvDistinct :: SupportedPrim t => NonEmpty (SBVType t) -> SBV Bool
($dmsbvDistinct) :: (SupportedPrim t, EqSymbolic (SBVType t)) => NonEmpty (SBVType t) -> SBV Bool
parseSMTModelResult :: SupportedPrim t => Int -> ([([CV], CV)], CV) -> t
castTypedSymbol :: forall (knd' :: SymbolKind) (knd :: SymbolKind). (SupportedPrim t, IsSymbolKind knd') => TypedSymbol knd t -> Maybe (TypedSymbol knd' t)
funcDummyConstraint :: SupportedPrim t => SBVType t -> SBV Bool

-- | Type family to resolve the symbolic type associated with a concrete
--   type.
class SupportedPrim con => SymRep con where {
    type SymType con;
}

-- | Type family to resolve the concrete type associated with a symbolic
--   type.
class ConRep sym where {
    type ConType sym;
}

-- | One-to-one mapping between symbolic types and concrete types.
class (ConRep sym, SymRep con, sym ~ SymType con, con ~ ConType sym) => LinkedRep con sym | con -> sym, sym -> con
underlyingTerm :: LinkedRep con sym => sym -> Term con
wrapTerm :: LinkedRep con sym => Term con -> sym

-- | Partial evaluation and lowering for function application terms.
class PEvalApplyTerm f a b | f -> a b
pevalApplyTerm :: PEvalApplyTerm f a b => Term f -> Term a -> Term b
sbvApplyTerm :: PEvalApplyTerm f a b => SBVType f -> SBVType a -> SBVType b

-- | Partial evaluation and lowering for bitwise operation terms.
class PEvalBitwiseTerm t
pevalAndBitsTerm :: PEvalBitwiseTerm t => Term t -> Term t -> Term t
pevalOrBitsTerm :: PEvalBitwiseTerm t => Term t -> Term t -> Term t
pevalXorBitsTerm :: PEvalBitwiseTerm t => Term t -> Term t -> Term t
pevalComplementBitsTerm :: PEvalBitwiseTerm t => Term t -> Term t
withSbvBitwiseTermConstraint :: PEvalBitwiseTerm t => (Bits (SBVType t) => r) -> r
sbvAndBitsTerm :: PEvalBitwiseTerm t => SBVType t -> SBVType t -> SBVType t
sbvOrBitsTerm :: PEvalBitwiseTerm t => SBVType t -> SBVType t -> SBVType t
sbvXorBitsTerm :: PEvalBitwiseTerm t => SBVType t -> SBVType t -> SBVType t
sbvComplementBitsTerm :: PEvalBitwiseTerm t => SBVType t -> SBVType t

-- | Partial evaluation and lowering for symbolic shifting terms.
class PEvalShiftTerm t
pevalShiftLeftTerm :: PEvalShiftTerm t => Term t -> Term t -> Term t
pevalShiftRightTerm :: PEvalShiftTerm t => Term t -> Term t -> Term t
withSbvShiftTermConstraint :: PEvalShiftTerm t => (SIntegral (NonFuncSBVBaseType t) => r) -> r
sbvShiftLeftTerm :: PEvalShiftTerm t => SBVType t -> SBVType t -> SBVType t
($dmsbvShiftLeftTerm) :: (PEvalShiftTerm t, SupportedNonFuncPrim t) => SBVType t -> SBVType t -> SBVType t
sbvShiftRightTerm :: PEvalShiftTerm t => SBVType t -> SBVType t -> SBVType t
($dmsbvShiftRightTerm) :: (PEvalShiftTerm t, SupportedNonFuncPrim t) => SBVType t -> SBVType t -> SBVType t

-- | Partial evaluation and lowering for symbolic rotate terms.
class PEvalRotateTerm t
pevalRotateLeftTerm :: PEvalRotateTerm t => Term t -> Term t -> Term t
pevalRotateRightTerm :: PEvalRotateTerm t => Term t -> Term t -> Term t
withSbvRotateTermConstraint :: PEvalRotateTerm t => (SIntegral (NonFuncSBVBaseType t) => r) -> r
sbvRotateLeftTerm :: PEvalRotateTerm t => SBVType t -> SBVType t -> SBVType t
($dmsbvRotateLeftTerm) :: (PEvalRotateTerm t, SupportedNonFuncPrim t) => SBVType t -> SBVType t -> SBVType t
sbvRotateRightTerm :: PEvalRotateTerm t => SBVType t -> SBVType t -> SBVType t
($dmsbvRotateRightTerm) :: (PEvalRotateTerm t, SupportedNonFuncPrim t) => SBVType t -> SBVType t -> SBVType t

-- | Partial evaluation and lowering for number terms.
class Num t => PEvalNumTerm t
pevalAddNumTerm :: PEvalNumTerm t => Term t -> Term t -> Term t
pevalNegNumTerm :: PEvalNumTerm t => Term t -> Term t
pevalMulNumTerm :: PEvalNumTerm t => Term t -> Term t -> Term t
pevalAbsNumTerm :: PEvalNumTerm t => Term t -> Term t
pevalSignumNumTerm :: PEvalNumTerm t => Term t -> Term t
withSbvNumTermConstraint :: PEvalNumTerm t => (Num (SBVType t) => r) -> r
sbvAddNumTerm :: PEvalNumTerm t => SBVType t -> SBVType t -> SBVType t
sbvNegNumTerm :: PEvalNumTerm t => SBVType t -> SBVType t
sbvMulNumTerm :: PEvalNumTerm t => SBVType t -> SBVType t -> SBVType t
sbvAbsNumTerm :: PEvalNumTerm t => SBVType t -> SBVType t
sbvSignumNumTerm :: PEvalNumTerm t => SBVType t -> SBVType t

-- | Partial evaluation for subtraction terms.
pevalSubNumTerm :: PEvalNumTerm a => Term a -> Term a -> Term a

-- | Partial evaluation and lowering for comparison terms.
class PEvalOrdTerm t
pevalLtOrdTerm :: PEvalOrdTerm t => Term t -> Term t -> Term Bool
pevalLeOrdTerm :: PEvalOrdTerm t => Term t -> Term t -> Term Bool
withSbvOrdTermConstraint :: PEvalOrdTerm t => (OrdSymbolic (SBVType t) => r) -> r
sbvLtOrdTerm :: PEvalOrdTerm t => SBVType t -> SBVType t -> SBV Bool
sbvLeOrdTerm :: PEvalOrdTerm t => SBVType t -> SBVType t -> SBV Bool

-- | Partial evaluation for greater than terms.
pevalGtOrdTerm :: PEvalOrdTerm a => Term a -> Term a -> Term Bool

-- | Partial evaluation for greater than or equal to terms.
pevalGeOrdTerm :: PEvalOrdTerm a => Term a -> Term a -> Term Bool

-- | Partial evaluation for inequality terms.
pevalNEqTerm :: SupportedPrim a => Term a -> Term a -> Term Bool

-- | Partial evaluation and lowering for integer division and modulo terms.
class PEvalDivModIntegralTerm t
pevalDivIntegralTerm :: PEvalDivModIntegralTerm t => Term t -> Term t -> Term t
pevalModIntegralTerm :: PEvalDivModIntegralTerm t => Term t -> Term t -> Term t
pevalQuotIntegralTerm :: PEvalDivModIntegralTerm t => Term t -> Term t -> Term t
pevalRemIntegralTerm :: PEvalDivModIntegralTerm t => Term t -> Term t -> Term t
withSbvDivModIntegralTermConstraint :: PEvalDivModIntegralTerm t => (SDivisible (SBVType t) => r) -> r
sbvDivIntegralTerm :: PEvalDivModIntegralTerm t => SBVType t -> SBVType t -> SBVType t
sbvModIntegralTerm :: PEvalDivModIntegralTerm t => SBVType t -> SBVType t -> SBVType t
sbvQuotIntegralTerm :: PEvalDivModIntegralTerm t => SBVType t -> SBVType t -> SBVType t
sbvRemIntegralTerm :: PEvalDivModIntegralTerm t => SBVType t -> SBVType t -> SBVType t

-- | Partial evaluation and lowering for bitcast terms.
class BitCast a b => PEvalBitCastTerm a b
pevalBitCastTerm :: PEvalBitCastTerm a b => Term a -> Term b
sbvBitCast :: PEvalBitCastTerm a b => SBVType a -> SBVType b

-- | Partial evaluation and lowering for bitcast or default value terms.
class BitCastOr a b => PEvalBitCastOrTerm a b
pevalBitCastOrTerm :: PEvalBitCastOrTerm a b => Term b -> Term a -> Term b
sbvBitCastOr :: PEvalBitCastOrTerm a b => SBVType b -> SBVType a -> SBVType b

-- | Partial evaluation and lowering for bit-vector terms.
class (SizedBV bv, forall (n :: Nat). (KnownNat n, 1 <= n) => PEvalNumTerm bv n, forall (n :: Nat). (KnownNat n, 1 <= n) => PEvalBitwiseTerm bv n, forall (n :: Nat). (KnownNat n, 1 <= n) => FiniteBits bv n, forall (n :: Nat). (KnownNat n, 1 <= n) => Num bv n) => PEvalBVTerm (bv :: Natural -> Type)
pevalBVConcatTerm :: forall (l :: Nat) (r :: Nat). (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r) => Term (bv l) -> Term (bv r) -> Term (bv (l + r))
pevalBVExtendTerm :: forall (l :: Nat) (r :: Nat) proxy. (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r) => Bool -> proxy r -> Term (bv l) -> Term (bv r)
pevalBVSelectTerm :: forall (n :: Nat) (ix :: Nat) (w :: Nat) p q. (PEvalBVTerm bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n) => p ix -> q w -> Term (bv n) -> Term (bv w)
sbvBVConcatTerm :: forall (l :: Nat) (r :: Nat) p1 p2. (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r) => p1 l -> p2 r -> SBVType (bv l) -> SBVType (bv r) -> SBVType (bv (l + r))
sbvBVExtendTerm :: forall (l :: Nat) (r :: Nat) p1 p2. (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r) => p1 l -> p2 r -> Bool -> SBVType (bv l) -> SBVType (bv r)
sbvBVSelectTerm :: forall (ix :: Nat) (w :: Nat) (n :: Nat) p1 p2 p3. (PEvalBVTerm bv, KnownNat ix, KnownNat w, KnownNat n, 1 <= n, 1 <= w, (ix + w) <= n) => p1 ix -> p2 w -> p3 n -> SBVType (bv n) -> SBVType (bv w)

-- | Partial evaluation and lowering for fractional terms.
class Fractional t => PEvalFractionalTerm t
pevalFdivTerm :: PEvalFractionalTerm t => Term t -> Term t -> Term t
pevalRecipTerm :: PEvalFractionalTerm t => Term t -> Term t
withSbvFractionalTermConstraint :: PEvalFractionalTerm t => (Fractional (SBVType t) => r) -> r
sbvFdivTerm :: PEvalFractionalTerm t => SBVType t -> SBVType t -> SBVType t
sbvRecipTerm :: PEvalFractionalTerm t => SBVType t -> SBVType t

-- | Partial evaluation and lowering for floating point terms.
class PEvalFPTerm (fp :: Nat -> Nat -> Type)
pevalFPTraitTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPTrait -> Term (fp eb sb) -> Term Bool
pevalFPUnaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPUnaryOp -> Term (fp eb sb) -> Term (fp eb sb)
pevalFPBinaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPBinaryOp -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb)
pevalFPRoundingUnaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPRoundingUnaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb)
pevalFPRoundingBinaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPRoundingBinaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb)
pevalFPFMATerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb)
sbvFPTraitTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPTrait -> SBVType (fp eb sb) -> SBVType Bool
sbvFPUnaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPUnaryOp -> SBVType (fp eb sb) -> SBVType (fp eb sb)
sbvFPBinaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPBinaryOp -> SBVType (fp eb sb) -> SBVType (fp eb sb) -> SBVType (fp eb sb)
sbvFPRoundingUnaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPRoundingUnaryOp -> SBVType FPRoundingMode -> SBVType (fp eb sb) -> SBVType (fp eb sb)
sbvFPRoundingBinaryTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => FPRoundingBinaryOp -> SBVType FPRoundingMode -> SBVType (fp eb sb) -> SBVType (fp eb sb) -> SBVType (fp eb sb)
sbvFPFMATerm :: forall (eb :: Nat) (sb :: Nat). (PEvalFPTerm fp, ValidFP eb sb) => SBVType FPRoundingMode -> SBVType (fp eb sb) -> SBVType (fp eb sb) -> SBVType (fp eb sb) -> SBVType (fp eb sb)

-- | Partial evaluation and lowering for floating point terms.
class PEvalFloatingTerm t
pevalFloatingUnaryTerm :: PEvalFloatingTerm t => FloatingUnaryOp -> Term t -> Term t
pevalPowerTerm :: PEvalFloatingTerm t => Term t -> Term t -> Term t
withSbvFloatingTermConstraint :: PEvalFloatingTerm t => (Floating (SBVType t) => r) -> r
sbvPowerTerm :: PEvalFloatingTerm t => SBVType t -> SBVType t -> SBVType t
sbvFloatingUnaryTerm :: PEvalFloatingTerm t => FloatingUnaryOp -> SBVType t -> SBVType t

-- | Partial evaluation and lowering for integral terms.
class (Integral a, Num b) => PEvalFromIntegralTerm a b
pevalFromIntegralTerm :: PEvalFromIntegralTerm a b => Term a -> Term b
sbvFromIntegralTerm :: PEvalFromIntegralTerm a b => SBVType a -> SBVType b

-- | Partial evaluation and lowering for converting from and to IEEE
--   floating point terms.
class PEvalIEEEFPConvertibleTerm a
pevalFromFPOrTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb) => Term a -> Term FPRoundingMode -> Term (FP eb sb) -> Term a
pevalToFPTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb) => Term FPRoundingMode -> Term a -> Term (FP eb sb)
sbvFromFPOrTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb) => SBVType a -> SBVType FPRoundingMode -> SBVType (FP eb sb) -> SBVType a
sbvToFPTerm :: forall (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb) => SBVType FPRoundingMode -> SBVType a -> SBVType (FP eb sb)

-- | The kind of a symbol.
--   
--   All symbols are <a>AnyKind</a>, and all symbols other than
--   general/tabular functions are <a>ConstantKind</a>.
data SymbolKind
ConstantKind :: SymbolKind
AnyKind :: SymbolKind

-- | A typed symbol is a symbol that is associated with a type. Note that
--   the same symbol bodies with different types are considered different
--   symbols and can coexist in a term.
--   
--   Simple symbols can be created with the <tt>OverloadedStrings</tt>
--   extension:
--   
--   <pre>
--   &gt;&gt;&gt; "a" :: TypedSymbol 'AnyKind Bool
--   a :: Bool
--   </pre>
data TypedSymbol (knd :: SymbolKind) t
[TypedSymbol] :: forall t (knd :: SymbolKind). (SupportedPrim t, SymbolKindConstraint knd t, IsSymbolKind knd) => Symbol -> TypedSymbol knd t

-- | Create a typed symbol with constant kinds.
typedConstantSymbol :: SupportedNonFuncPrim t => Symbol -> TypedSymbol 'ConstantKind t

-- | Create a typed symbol with any kinds.
typedAnySymbol :: SupportedPrim t => Symbol -> TypedSymbol 'AnyKind t

-- | Constant symbol
type TypedConstantSymbol = TypedSymbol 'ConstantKind

-- | Any symbol
type TypedAnySymbol = TypedSymbol 'AnyKind

-- | A non-indexed symbol. Type information are checked at runtime.
data SomeTypedSymbol (knd :: SymbolKind)
[SomeTypedSymbol] :: forall (knd :: SymbolKind) t. TypedSymbol knd t -> SomeTypedSymbol knd

-- | Non-indexed constant symbol
type SomeTypedConstantSymbol = SomeTypedSymbol 'ConstantKind

-- | Non-indexed any symbol
type SomeTypedAnySymbol = SomeTypedSymbol 'AnyKind

-- | Decision procedure for symbol kinds.
class IsSymbolKind (knd :: SymbolKind) where {
    type SymbolKindConstraint (knd :: SymbolKind) :: Type -> Constraint;
}
decideSymbolKind :: IsSymbolKind knd => Either (knd :~~: 'ConstantKind) (knd :~~: 'AnyKind)
withSymbolKindConstraint :: IsSymbolKind knd => TypedSymbol knd t -> (SymbolKindConstraint knd t => a) -> a

-- | Show a typed symbol without the type information.
showUntyped :: forall (knd :: SymbolKind) t. TypedSymbol knd t -> String

-- | Construct a <a>SomeTypedSymbol</a> from a <a>TypedSymbol</a>.
someTypedSymbol :: forall (knd :: SymbolKind) t. TypedSymbol knd t -> SomeTypedSymbol knd

-- | Compare two <a>TypedSymbol</a>s for equality.
eqHeteroSymbol :: forall (ta :: SymbolKind) a (tb :: SymbolKind) b. TypedSymbol ta a -> TypedSymbol tb b -> Bool

-- | Cast a typed symbol to a different kind. Check if the kind is
--   compatible.
castSomeTypedSymbol :: forall (knd' :: SymbolKind) (knd :: SymbolKind). IsSymbolKind knd' => SomeTypedSymbol knd -> Maybe (SomeTypedSymbol knd')

-- | Traits for IEEE floating point numbers.
data FPTrait
FPIsNaN :: FPTrait
FPIsPositive :: FPTrait
FPIsNegative :: FPTrait
FPIsPositiveInfinite :: FPTrait
FPIsNegativeInfinite :: FPTrait
FPIsInfinite :: FPTrait
FPIsPositiveZero :: FPTrait
FPIsNegativeZero :: FPTrait
FPIsZero :: FPTrait
FPIsNormal :: FPTrait
FPIsSubnormal :: FPTrait
FPIsPoint :: FPTrait

-- | Unary floating point operations.
data FPUnaryOp
FPAbs :: FPUnaryOp
FPNeg :: FPUnaryOp

-- | Binary floating point operations.
data FPBinaryOp
FPRem :: FPBinaryOp
FPMinimum :: FPBinaryOp
FPMinimumNumber :: FPBinaryOp
FPMaximum :: FPBinaryOp
FPMaximumNumber :: FPBinaryOp

-- | Unary floating point operations with rounding modes.
data FPRoundingUnaryOp
FPSqrt :: FPRoundingUnaryOp
FPRoundToIntegral :: FPRoundingUnaryOp

-- | Binary floating point operations with rounding modes.
data FPRoundingBinaryOp
FPAdd :: FPRoundingBinaryOp
FPSub :: FPRoundingBinaryOp
FPMul :: FPRoundingBinaryOp
FPDiv :: FPRoundingBinaryOp

-- | Unary floating point operations.
data FloatingUnaryOp
FloatingExp :: FloatingUnaryOp
FloatingLog :: FloatingUnaryOp
FloatingSqrt :: FloatingUnaryOp
FloatingSin :: FloatingUnaryOp
FloatingCos :: FloatingUnaryOp
FloatingTan :: FloatingUnaryOp
FloatingAsin :: FloatingUnaryOp
FloatingAcos :: FloatingUnaryOp
FloatingAtan :: FloatingUnaryOp
FloatingSinh :: FloatingUnaryOp
FloatingCosh :: FloatingUnaryOp
FloatingTanh :: FloatingUnaryOp
FloatingAsinh :: FloatingUnaryOp
FloatingAcosh :: FloatingUnaryOp
FloatingAtanh :: FloatingUnaryOp

-- | Internal representation for Grisette symbolic terms.
data Term t
[ConTerm'] :: forall t. SupportedPrim t => {-# UNPACK #-} !CachedInfo -> !t -> Term t
[SymTerm'] :: forall t. {-# UNPACK #-} !CachedInfo -> !TypedSymbol 'AnyKind t -> Term t
[ForallTerm'] :: forall t1. {-# UNPACK #-} !CachedInfo -> !TypedSymbol 'ConstantKind t1 -> !Term Bool -> Term Bool
[ExistsTerm'] :: forall t1. {-# UNPACK #-} !CachedInfo -> !TypedSymbol 'ConstantKind t1 -> !Term Bool -> Term Bool
[NotTerm'] :: {-# UNPACK #-} !CachedInfo -> !Term Bool -> Term Bool
[OrTerm'] :: {-# UNPACK #-} !CachedInfo -> !Term Bool -> !Term Bool -> !HashSet (Term Bool) -> Term Bool
[AndTerm'] :: {-# UNPACK #-} !CachedInfo -> !Term Bool -> !Term Bool -> !HashSet (Term Bool) -> Term Bool
[EqTerm'] :: forall t1. {-# UNPACK #-} !CachedInfo -> !Term t1 -> !Term t1 -> Term Bool
[DistinctTerm'] :: forall t1. {-# UNPACK #-} !CachedInfo -> !NonEmpty (Term t1) -> Term Bool
[ITETerm'] :: forall t. SupportedPrim t => {-# UNPACK #-} !CachedInfo -> !Term Bool -> !Term t -> !Term t -> Term t
[AddNumTerm'] :: forall t. (SupportedPrim t, PEvalNumTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[NegNumTerm'] :: forall t. (SupportedPrim t, PEvalNumTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> Term t
[MulNumTerm'] :: forall t. (SupportedPrim t, PEvalNumTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[AbsNumTerm'] :: forall t. (SupportedPrim t, PEvalNumTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> Term t
[SignumNumTerm'] :: forall t. (SupportedPrim t, PEvalNumTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> Term t
[LtOrdTerm'] :: forall t1. (SupportedPrim t1, PEvalOrdTerm t1) => {-# UNPACK #-} !CachedInfo -> !Term t1 -> !Term t1 -> Term Bool
[LeOrdTerm'] :: forall t1. (SupportedPrim t1, PEvalOrdTerm t1) => {-# UNPACK #-} !CachedInfo -> !Term t1 -> !Term t1 -> Term Bool
[AndBitsTerm'] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[OrBitsTerm'] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[XorBitsTerm'] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[ComplementBitsTerm'] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> Term t
[ShiftLeftTerm'] :: forall t. (SupportedPrim t, PEvalShiftTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[ShiftRightTerm'] :: forall t. (SupportedPrim t, PEvalShiftTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[RotateLeftTerm'] :: forall t. (SupportedPrim t, PEvalRotateTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[RotateRightTerm'] :: forall t. (SupportedPrim t, PEvalRotateTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[BitCastTerm'] :: forall t a. (SupportedPrim t, PEvalBitCastTerm a t) => {-# UNPACK #-} !CachedInfo -> !Term a -> Term t
[BitCastOrTerm'] :: forall t a. (SupportedPrim t, PEvalBitCastOrTerm a t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term a -> Term t
[BVConcatTerm'] :: forall (bv :: Natural -> Type) (l :: Nat) (r :: Nat). (PEvalBVTerm bv, KnownNat l, KnownNat r, KnownNat (l + r), 1 <= l, 1 <= r, 1 <= (l + r), SupportedPrim (bv (l + r))) => {-# UNPACK #-} !CachedInfo -> !Term (bv l) -> !Term (bv r) -> Term (bv (l + r))
[BVSelectTerm'] :: forall (bv :: Natural -> Type) (n :: Nat) (ix :: Nat) (w :: Nat). (PEvalBVTerm bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n, SupportedPrim (bv w)) => {-# UNPACK #-} !CachedInfo -> !Proxy ix -> !Proxy w -> !Term (bv n) -> Term (bv w)
[BVExtendTerm'] :: forall (bv :: Natural -> Type) (l :: Nat) (r :: Nat). (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv r)) => {-# UNPACK #-} !CachedInfo -> !Bool -> !Proxy r -> !Term (bv l) -> Term (bv r)
[ApplyTerm'] :: forall f a t. (PEvalApplyTerm f a t, SupportedPrim t) => {-# UNPACK #-} !CachedInfo -> !Term f -> !Term a -> Term t
[DivIntegralTerm'] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[ModIntegralTerm'] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[QuotIntegralTerm'] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[RemIntegralTerm'] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[FPTraitTerm'] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => {-# UNPACK #-} !CachedInfo -> !FPTrait -> !Term (fp eb sb) -> Term Bool
[FdivTerm'] :: forall t. (SupportedPrim t, PEvalFractionalTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[RecipTerm'] :: forall t. (SupportedPrim t, PEvalFractionalTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> Term t
[FloatingUnaryTerm'] :: forall t. (SupportedPrim t, PEvalFloatingTerm t) => {-# UNPACK #-} !CachedInfo -> !FloatingUnaryOp -> !Term t -> Term t
[PowerTerm'] :: forall t. (SupportedPrim t, PEvalFloatingTerm t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term t -> Term t
[FPUnaryTerm'] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => {-# UNPACK #-} !CachedInfo -> !FPUnaryOp -> !Term (fp eb sb) -> Term (fp eb sb)
[FPBinaryTerm'] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => {-# UNPACK #-} !CachedInfo -> !FPBinaryOp -> !Term (fp eb sb) -> !Term (fp eb sb) -> Term (fp eb sb)
[FPRoundingUnaryTerm'] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => {-# UNPACK #-} !CachedInfo -> !FPRoundingUnaryOp -> !Term FPRoundingMode -> !Term (fp eb sb) -> Term (fp eb sb)
[FPRoundingBinaryTerm'] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => {-# UNPACK #-} !CachedInfo -> !FPRoundingBinaryOp -> !Term FPRoundingMode -> !Term (fp eb sb) -> !Term (fp eb sb) -> Term (fp eb sb)
[FPFMATerm'] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => {-# UNPACK #-} !CachedInfo -> !Term FPRoundingMode -> !Term (fp eb sb) -> !Term (fp eb sb) -> !Term (fp eb sb) -> Term (fp eb sb)
[FromIntegralTerm'] :: forall a t. (PEvalFromIntegralTerm a t, SupportedPrim t) => {-# UNPACK #-} !CachedInfo -> !Term a -> Term t
[FromFPOrTerm'] :: forall t (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm t, ValidFP eb sb, SupportedPrim t) => {-# UNPACK #-} !CachedInfo -> !Term t -> !Term FPRoundingMode -> !Term (FP eb sb) -> Term t
[ToFPTerm'] :: forall a (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim (FP eb sb)) => {-# UNPACK #-} !CachedInfo -> !Term FPRoundingMode -> !Term a -> Proxy eb -> Proxy sb -> Term (FP eb sb)

-- | The default value in a dynamic <a>ModelValue</a>.
defaultValueDynamic :: SupportedPrim t => proxy t -> ModelValue

-- | Pattern for term with dynamic typing.
pattern DynTerm :: SupportedPrim a => Term a -> Term b

-- | Convert a term to the current thread.
toCurThread :: Term t -> IO (Term t)

-- | Information about a cached term.
data CachedInfo
CachedInfo :: {-# UNPACK #-} !WeakThreadId -> {-# UNPACK #-} !Digest -> {-# UNPACK #-} !Id -> {-# UNPACK #-} !StableIdent -> CachedInfo
[cachedThreadId] :: CachedInfo -> {-# UNPACK #-} !WeakThreadId
[cachedDigest] :: CachedInfo -> {-# UNPACK #-} !Digest
[cachedId] :: CachedInfo -> {-# UNPACK #-} !Id
[cachedStableIdent] :: CachedInfo -> {-# UNPACK #-} !StableIdent

-- | Get the cached information for a term.
termInfo :: Term t -> CachedInfo

-- | Get the thread ID for a term.
termThreadId :: Term t -> WeakThreadId

-- | Get the digest for a term.
termDigest :: Term t -> Digest

-- | Get the ID for a term.
termId :: Term t -> Id

-- | Get the stable identifier for a term.
termStableIdent :: Term t -> StableIdent

-- | Pretty-print a term.
pformatTerm :: Term t -> String

-- | A value with its type information.
data ModelValue
[ModelValue] :: forall v. SupportedPrim v => v -> ModelValue

-- | Convert to a model value.
toModelValue :: SupportedPrim a => a -> ModelValue

-- | Convert from a model value. Crashes if the types does not match.
unsafeFromModelValue :: Typeable a => ModelValue -> a

-- | Term without identity (before internalizing).
data UTerm t
[UConTerm] :: forall t. SupportedPrim t => !t -> UTerm t
[USymTerm] :: forall t. !TypedSymbol 'AnyKind t -> UTerm t
[UForallTerm] :: forall t1. !TypedSymbol 'ConstantKind t1 -> !Term Bool -> UTerm Bool
[UExistsTerm] :: forall t1. !TypedSymbol 'ConstantKind t1 -> !Term Bool -> UTerm Bool
[UNotTerm] :: !Term Bool -> UTerm Bool
[UOrTerm] :: !Term Bool -> !Term Bool -> !HashSet (Term Bool) -> UTerm Bool
[UAndTerm] :: !Term Bool -> !Term Bool -> !HashSet (Term Bool) -> UTerm Bool
[UEqTerm] :: forall t1. !Term t1 -> !Term t1 -> UTerm Bool
[UDistinctTerm] :: forall t1. !NonEmpty (Term t1) -> UTerm Bool
[UITETerm] :: forall t. SupportedPrim t => !Term Bool -> !Term t -> !Term t -> UTerm t
[UAddNumTerm] :: forall t. (SupportedPrim t, PEvalNumTerm t) => !Term t -> !Term t -> UTerm t
[UNegNumTerm] :: forall t. (SupportedPrim t, PEvalNumTerm t) => !Term t -> UTerm t
[UMulNumTerm] :: forall t. (SupportedPrim t, PEvalNumTerm t) => !Term t -> !Term t -> UTerm t
[UAbsNumTerm] :: forall t. (SupportedPrim t, PEvalNumTerm t) => !Term t -> UTerm t
[USignumNumTerm] :: forall t. (SupportedPrim t, PEvalNumTerm t) => !Term t -> UTerm t
[ULtOrdTerm] :: forall t1. (SupportedPrim t1, PEvalOrdTerm t1) => !Term t1 -> !Term t1 -> UTerm Bool
[ULeOrdTerm] :: forall t1. (SupportedPrim t1, PEvalOrdTerm t1) => !Term t1 -> !Term t1 -> UTerm Bool
[UAndBitsTerm] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => !Term t -> !Term t -> UTerm t
[UOrBitsTerm] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => !Term t -> !Term t -> UTerm t
[UXorBitsTerm] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => !Term t -> !Term t -> UTerm t
[UComplementBitsTerm] :: forall t. (SupportedPrim t, PEvalBitwiseTerm t) => !Term t -> UTerm t
[UShiftLeftTerm] :: forall t. (SupportedPrim t, PEvalShiftTerm t) => !Term t -> !Term t -> UTerm t
[UShiftRightTerm] :: forall t. (SupportedPrim t, PEvalShiftTerm t) => !Term t -> !Term t -> UTerm t
[URotateLeftTerm] :: forall t. (SupportedPrim t, PEvalRotateTerm t) => !Term t -> !Term t -> UTerm t
[URotateRightTerm] :: forall t. (SupportedPrim t, PEvalRotateTerm t) => !Term t -> !Term t -> UTerm t
[UBitCastTerm] :: forall t a. (SupportedPrim t, PEvalBitCastTerm a t) => !Term a -> UTerm t
[UBitCastOrTerm] :: forall t a. (SupportedPrim t, PEvalBitCastOrTerm a t) => !Term t -> !Term a -> UTerm t
[UBVConcatTerm] :: forall (bv :: Natural -> Type) (l :: Nat) (r :: Nat). (PEvalBVTerm bv, KnownNat l, KnownNat r, KnownNat (l + r), 1 <= l, 1 <= r, 1 <= (l + r), SupportedPrim (bv (l + r))) => !Term (bv l) -> !Term (bv r) -> UTerm (bv (l + r))
[UBVSelectTerm] :: forall (bv :: Natural -> Type) (n :: Nat) (ix :: Nat) (w :: Nat). (PEvalBVTerm bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n, SupportedPrim (bv w)) => !Proxy ix -> !Proxy w -> !Term (bv n) -> UTerm (bv w)
[UBVExtendTerm] :: forall (bv :: Natural -> Type) (l :: Nat) (r :: Nat). (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv r)) => !Bool -> !Proxy r -> !Term (bv l) -> UTerm (bv r)
[UApplyTerm] :: forall f a t. (PEvalApplyTerm f a t, SupportedPrim t) => Term f -> Term a -> UTerm t
[UDivIntegralTerm] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => !Term t -> !Term t -> UTerm t
[UModIntegralTerm] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => !Term t -> !Term t -> UTerm t
[UQuotIntegralTerm] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => !Term t -> !Term t -> UTerm t
[URemIntegralTerm] :: forall t. (SupportedPrim t, PEvalDivModIntegralTerm t) => !Term t -> !Term t -> UTerm t
[UFPTraitTerm] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => !FPTrait -> !Term (fp eb sb) -> UTerm Bool
[UFdivTerm] :: forall t. (SupportedPrim t, PEvalFractionalTerm t) => !Term t -> !Term t -> UTerm t
[URecipTerm] :: forall t. (SupportedPrim t, PEvalFractionalTerm t) => !Term t -> UTerm t
[UFloatingUnaryTerm] :: forall t. (SupportedPrim t, PEvalFloatingTerm t) => !FloatingUnaryOp -> !Term t -> UTerm t
[UPowerTerm] :: forall t. (SupportedPrim t, PEvalFloatingTerm t) => !Term t -> !Term t -> UTerm t
[UFPUnaryTerm] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => !FPUnaryOp -> !Term (fp eb sb) -> UTerm (fp eb sb)
[UFPBinaryTerm] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => !FPBinaryOp -> !Term (fp eb sb) -> !Term (fp eb sb) -> UTerm (fp eb sb)
[UFPRoundingUnaryTerm] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => !FPRoundingUnaryOp -> !Term FPRoundingMode -> !Term (fp eb sb) -> UTerm (fp eb sb)
[UFPRoundingBinaryTerm] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => !FPRoundingBinaryOp -> !Term FPRoundingMode -> !Term (fp eb sb) -> !Term (fp eb sb) -> UTerm (fp eb sb)
[UFPFMATerm] :: forall (eb :: Nat) (sb :: Nat) (fp :: Nat -> Nat -> Type). (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => !Term FPRoundingMode -> !Term (fp eb sb) -> !Term (fp eb sb) -> !Term (fp eb sb) -> UTerm (fp eb sb)
[UFromIntegralTerm] :: forall a t. (PEvalFromIntegralTerm a t, SupportedPrim t) => !Term a -> UTerm t
[UFromFPOrTerm] :: forall t (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm t, SupportedPrim t, ValidFP eb sb) => Term t -> !Term FPRoundingMode -> !Term (FP eb sb) -> UTerm t
[UToFPTerm] :: forall a (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim (FP eb sb)) => !Term FPRoundingMode -> !Term a -> Proxy eb -> Proxy sb -> UTerm (FP eb sb)

-- | Pretty-print a term, possibly eliding parts of it.
prettyPrintTerm :: Term t -> Doc ann

-- | Construct and internalizing a <a>ConTerm</a>.
conTerm :: SupportedPrim t => t -> Term t

-- | Construct and internalizing a <a>SymTerm</a>.
symTerm :: forall (knd :: SymbolKind) t. TypedSymbol knd t -> Term t

-- | Construct and internalizing a <a>SymTerm</a> with an identifier, using
--   simple symbols.
ssymTerm :: SupportedPrim t => Identifier -> Term t

-- | Construct and internalizing a <a>SymTerm</a> with an identifier and an
--   index, using indexed symbols.
isymTerm :: SupportedPrim t => Identifier -> Int -> Term t

-- | Construct and internalizing a <a>ForallTerm</a>.
forallTerm :: TypedSymbol 'ConstantKind t -> Term Bool -> Term Bool

-- | Construct and internalizing a <a>ExistsTerm</a>.
existsTerm :: TypedSymbol 'ConstantKind t -> Term Bool -> Term Bool

-- | Construct and internalizing a <a>NotTerm</a>.
notTerm :: Term Bool -> Term Bool

-- | Construct and internalizing a <a>OrTerm</a>.
orTerm :: Term Bool -> Term Bool -> Term Bool

-- | Construct and internalizing a <a>AndTerm</a>.
andTerm :: Term Bool -> Term Bool -> Term Bool

-- | Construct and internalizing a <a>EqTerm</a>.
eqTerm :: Term a -> Term a -> Term Bool

-- | Construct and internalizing a <a>DistinctTerm</a>.
distinctTerm :: NonEmpty (Term a) -> Term Bool

-- | Construct and internalizing a <a>ITETerm</a>.
iteTerm :: Term Bool -> Term a -> Term a -> Term a

-- | Construct and internalizing a <a>AddNumTerm</a>.
addNumTerm :: PEvalNumTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>NegNumTerm</a>.
negNumTerm :: PEvalNumTerm a => Term a -> Term a

-- | Construct and internalizing a <a>MulNumTerm</a>.
mulNumTerm :: PEvalNumTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>AbsNumTerm</a>.
absNumTerm :: PEvalNumTerm a => Term a -> Term a

-- | Construct and internalizing a <a>SignumNumTerm</a>.
signumNumTerm :: PEvalNumTerm a => Term a -> Term a

-- | Construct and internalizing a <a>LtOrdTerm</a>.
ltOrdTerm :: PEvalOrdTerm a => Term a -> Term a -> Term Bool

-- | Construct and internalizing a <a>LeOrdTerm</a>.
leOrdTerm :: PEvalOrdTerm a => Term a -> Term a -> Term Bool

-- | Construct and internalizing a <a>AndBitsTerm</a>.
andBitsTerm :: PEvalBitwiseTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>OrBitsTerm</a>.
orBitsTerm :: PEvalBitwiseTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>XorBitsTerm</a>.
xorBitsTerm :: PEvalBitwiseTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>ComplementBitsTerm</a>.
complementBitsTerm :: PEvalBitwiseTerm a => Term a -> Term a

-- | Construct and internalizing a <a>ShiftLeftTerm</a>.
shiftLeftTerm :: PEvalShiftTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>RotateLeftTerm</a>.
rotateLeftTerm :: PEvalRotateTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>ShiftRightTerm</a>.
shiftRightTerm :: PEvalShiftTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>RotateRightTerm</a>.
rotateRightTerm :: PEvalRotateTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>BitCastTerm</a>.
bitCastTerm :: (PEvalBitCastTerm a b, SupportedPrim b) => Term a -> Term b

-- | Construct and internalizing a <a>BitCastOrTerm</a>.
bitCastOrTerm :: PEvalBitCastOrTerm a b => Term b -> Term a -> Term b

-- | Construct and internalizing a <a>BVConcatTerm</a>.
bvConcatTerm :: forall bv (l :: Nat) (r :: Nat). (PEvalBVTerm bv, KnownNat l, KnownNat r, KnownNat (l + r), 1 <= l, 1 <= r, 1 <= (l + r), SupportedPrim (bv (l + r))) => Term (bv l) -> Term (bv r) -> Term (bv (l + r))

-- | Construct and internalizing a <a>BVSelectTerm</a>.
bvSelectTerm :: forall bv (n :: Nat) (ix :: Nat) (w :: Nat) p q. (PEvalBVTerm bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n, SupportedPrim (bv w)) => p ix -> q w -> Term (bv n) -> Term (bv w)

-- | Construct and internalizing a <a>BVExtendTerm</a>.
bvExtendTerm :: forall bv (l :: Nat) (r :: Nat) proxy. (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv r)) => Bool -> proxy r -> Term (bv l) -> Term (bv r)

-- | Construct and internalizing a <a>BVExtendTerm</a> with sign extension.
bvsignExtendTerm :: forall bv (l :: Nat) (r :: Nat) proxy. (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv r)) => proxy r -> Term (bv l) -> Term (bv r)

-- | Construct and internalizing a <a>BVExtendTerm</a> with zero extension.
bvzeroExtendTerm :: forall bv (l :: Nat) (r :: Nat) proxy. (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv r)) => proxy r -> Term (bv l) -> Term (bv r)

-- | Construct and internalizing a <a>ApplyTerm</a>.
applyTerm :: (PEvalApplyTerm f a b, SupportedPrim b) => Term f -> Term a -> Term b

-- | Construct and internalizing a <a>DivIntegralTerm</a>.
divIntegralTerm :: PEvalDivModIntegralTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>ModIntegralTerm</a>.
modIntegralTerm :: PEvalDivModIntegralTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>QuotIntegralTerm</a>.
quotIntegralTerm :: PEvalDivModIntegralTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>RemIntegralTerm</a>.
remIntegralTerm :: PEvalDivModIntegralTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>FPTraitTerm</a>.
fpTraitTerm :: forall (eb :: Nat) (sb :: Nat) fp. (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPTrait -> Term (fp eb sb) -> Term Bool

-- | Construct and internalizing a <a>FdivTerm</a>.
fdivTerm :: PEvalFractionalTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>RecipTerm</a>.
recipTerm :: PEvalFractionalTerm a => Term a -> Term a

-- | Construct and internalizing a <a>FloatingUnaryTerm</a>.
floatingUnaryTerm :: PEvalFloatingTerm a => FloatingUnaryOp -> Term a -> Term a

-- | Construct and internalizing a <a>PowerTerm</a>.
powerTerm :: PEvalFloatingTerm a => Term a -> Term a -> Term a

-- | Construct and internalizing a <a>FPUnaryTerm</a>.
fpUnaryTerm :: forall (eb :: Nat) (sb :: Nat) fp. (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPUnaryOp -> Term (fp eb sb) -> Term (fp eb sb)

-- | Construct and internalizing a <a>FPBinaryTerm</a>.
fpBinaryTerm :: forall (eb :: Nat) (sb :: Nat) fp. (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPBinaryOp -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb)

-- | Construct and internalizing a <a>FPRoundingUnaryTerm</a>.
fpRoundingUnaryTerm :: forall (eb :: Nat) (sb :: Nat) fp. (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPRoundingUnaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb)

-- | Construct and internalizing a <a>FPRoundingBinaryTerm</a>.
fpRoundingBinaryTerm :: forall (eb :: Nat) (sb :: Nat) fp. (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPRoundingBinaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb)

-- | Construct and internalizing a <a>FPFMATerm</a>.
fpFMATerm :: forall (eb :: Nat) (sb :: Nat) fp. (ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb)

-- | Construct and internalizing a <a>FromIntegralTerm</a>.
fromIntegralTerm :: (PEvalFromIntegralTerm a b, SupportedPrim b) => Term a -> Term b

-- | Construct and internalizing a <a>FromFPOrTerm</a>.
fromFPOrTerm :: forall a (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb) => Term a -> Term FPRoundingMode -> Term (FP eb sb) -> Term a

-- | Construct and internalizing a <a>ToFPTerm</a>.
toFPTerm :: forall a (eb :: Nat) (sb :: Nat). (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim (FP eb sb)) => Term FPRoundingMode -> Term a -> Term (FP eb sb)

-- | Pattern synonym to introduce the SupportedPrim constraint.
pattern SupportedTerm :: () => SupportedPrim t => Term t

-- | Pattern synonym to introduce constraints from a <a>TypedSymbol</a>.
pattern SupportedTypedSymbol :: () => (SupportedPrim t, SymbolKindConstraint k t, IsSymbolKind k) => TypedSymbol k t

-- | Pattern synonym to introduce constraints from a <a>TypedSymbol</a>.
--   Also checks that the symbol kind is <a>ConstantKind</a>.
pattern SupportedConstantTypedSymbol :: () => (SupportedPrim t, SymbolKindConstraint k t, IsSymbolKind k, k ~ 'ConstantKind) => TypedSymbol k t

-- | Pattern synonym for <a>ConTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ConTerm :: () => SupportedPrim t => t -> Term t

-- | Pattern synonym for <a>SymTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern SymTerm :: () => SupportedPrim t => TypedSymbol 'AnyKind t -> Term t

-- | Pattern synonym for <a>ForallTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern ForallTerm :: forall r t. () => (r ~ Bool, SupportedNonFuncPrim t) => TypedSymbol 'ConstantKind t -> Term Bool -> Term r

-- | Pattern synonym for <a>ExistsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern ExistsTerm :: forall r t. () => (r ~ Bool, SupportedNonFuncPrim t) => TypedSymbol 'ConstantKind t -> Term Bool -> Term r

-- | Pattern synonym for <a>NotTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern NotTerm :: () => r ~ Bool => Term Bool -> Term r

-- | Pattern synonym for <a>OrTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern OrTerm :: () => r ~ Bool => Term Bool -> Term Bool -> Term r

-- | Pattern synonym for <a>AndTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern AndTerm :: () => r ~ Bool => Term Bool -> Term Bool -> Term r

-- | Pattern synonym for <a>OrTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern OrTermAll :: () => r ~ Bool => Term Bool -> Term Bool -> HashSet (Term Bool) -> Term r

-- | Pattern synonym for <a>AndTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern AndTermAll :: () => r ~ Bool => Term Bool -> Term Bool -> HashSet (Term Bool) -> Term r

-- | Pattern synonym for <a>EqTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern EqTerm :: forall r t. () => (r ~ Bool, SupportedPrim t) => Term t -> Term t -> Term r

-- | Pattern synonym for <a>DistinctTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern DistinctTerm :: forall r t. () => (r ~ Bool, SupportedPrim t) => NonEmpty (Term t) -> Term r

-- | Pattern synonym for <a>ITETerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ITETerm :: () => SupportedPrim t => Term Bool -> Term t -> Term t -> Term t

-- | Pattern synonym for <a>AddNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern AddNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>NegNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern NegNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t

-- | Pattern synonym for <a>MulNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern MulNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>AbsNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern AbsNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t

-- | Pattern synonym for <a>SignumNumTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern SignumNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t

-- | Pattern synonym for <a>LtOrdTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern LtOrdTerm :: forall r t. () => (r ~ Bool, SupportedPrim t, PEvalOrdTerm t) => Term t -> Term t -> Term r

-- | Pattern synonym for <a>LeOrdTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern LeOrdTerm :: forall r t. () => (r ~ Bool, SupportedPrim t, PEvalOrdTerm t) => Term t -> Term t -> Term r

-- | Pattern synonym for <a>AndBitsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern AndBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>OrBitsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern OrBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>XorBitsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern XorBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>ComplementBitsTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ComplementBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t

-- | Pattern synonym for <a>ShiftLeftTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ShiftLeftTerm :: () => (SupportedPrim t, PEvalShiftTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RotateLeftTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern RotateLeftTerm :: () => (SupportedPrim t, PEvalRotateTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>ShiftRightTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ShiftRightTerm :: () => (SupportedPrim t, PEvalShiftTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RotateRightTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern RotateRightTerm :: () => (SupportedPrim t, PEvalRotateTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>BitCastTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BitCastTerm :: forall b a. () => (SupportedPrim a, SupportedPrim b, PEvalBitCastTerm a b) => Term a -> Term b

-- | Pattern synonym for <a>BitCastOrTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern BitCastOrTerm :: () => (SupportedPrim a, SupportedPrim b, PEvalBitCastOrTerm a b) => Term b -> Term a -> Term b

-- | Pattern synonym for <a>BVConcatTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BVConcatTerm :: forall ret bv (l :: Nat) (r :: Nat). () => (PEvalBVTerm bv, KnownNat l, KnownNat r, KnownNat (l + r), 1 <= l, 1 <= r, 1 <= (l + r), SupportedPrim (bv l), SupportedPrim (bv r), SupportedPrim (bv (l + r)), ret ~ bv (l + r)) => Term (bv l) -> Term (bv r) -> Term ret

-- | Pattern synonym for <a>BVSelectTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BVSelectTerm :: forall ret bv (w :: Nat) (n :: Nat) (ix :: Nat). () => (PEvalBVTerm bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n, SupportedPrim (bv n), SupportedPrim (bv w), ret ~ bv w) => Proxy ix -> Proxy w -> Term (bv n) -> Term ret

-- | Pattern synonym for <a>BVExtendTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BVExtendTerm :: forall ret bv (l :: Nat) (r :: Nat). () => (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv l), SupportedPrim (bv r), ret ~ bv r) => Bool -> Proxy r -> Term (bv l) -> Term ret

-- | Pattern synonym for <a>ApplyTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ApplyTerm :: forall b f a. () => (PEvalApplyTerm f a b, SupportedPrim f, SupportedPrim a, SupportedPrim b) => Term f -> Term a -> Term b

-- | Pattern synonym for <a>DivIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern DivIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>ModIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ModIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>QuotIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern QuotIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RemIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern RemIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>FPTraitTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FPTraitTerm :: forall r (eb :: Nat) (sb :: Nat) fp. () => (r ~ Bool, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPTrait -> Term (fp eb sb) -> Term r

-- | Pattern synonym for <a>FdivTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern FdivTerm :: () => (SupportedPrim t, PEvalFractionalTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RecipTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern RecipTerm :: () => (SupportedPrim t, PEvalFractionalTerm t) => Term t -> Term t

-- | Pattern synonym for <a>FloatingUnaryTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FloatingUnaryTerm :: () => (SupportedPrim t, PEvalFloatingTerm t) => FloatingUnaryOp -> Term t -> Term t

-- | Pattern synonym for <a>PowerTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern PowerTerm :: () => (SupportedPrim t, PEvalFloatingTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>FPUnaryTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FPUnaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPUnaryOp -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPBinaryTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FPBinaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPBinaryOp -> Term (fp eb sb) -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPRoundingUnaryTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FPRoundingUnaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPRoundingUnaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPRoundingBinaryTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FPRoundingBinaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPRoundingBinaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPFMATerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern FPFMATerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FromIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FromIntegralTerm :: forall b a. () => (PEvalFromIntegralTerm a b, SupportedPrim a, SupportedPrim b) => Term a -> Term b

-- | Pattern synonym for <a>FromFPOrTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FromFPOrTerm :: forall a (eb :: Nat) (sb :: Nat). () => (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim a) => Term a -> Term FPRoundingMode -> Term (FP eb sb) -> Term a

-- | Pattern synonym for <a>ToFPTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ToFPTerm :: forall ret (eb :: Nat) (sb :: Nat) a. () => (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim (FP eb sb), SupportedPrim a, ret ~ FP eb sb) => Term FPRoundingMode -> Term a -> Proxy eb -> Proxy sb -> Term ret

-- | Construct and internalizing <a>True</a> term.
trueTerm :: Term Bool

-- | Construct and internalizing <a>False</a> term.
falseTerm :: Term Bool

-- | Pattern matcher for concrete <a>Bool</a> terms.
pattern BoolConTerm :: Bool -> Term a

-- | Pattern matcher for <a>True</a> term.
pattern TrueTerm :: Term a

-- | Pattern matcher for <a>False</a> term.
pattern FalseTerm :: Term a

-- | Pattern matcher for <a>Bool</a> terms.
pattern BoolTerm :: Term Bool -> Term a

-- | Partial evaluation for not terms.
pevalNotTerm :: Term Bool -> Term Bool

-- | Partial evaluation for or terms.
pevalOrTerm :: Term Bool -> Term Bool -> Term Bool

-- | Partial evaluation for and terms.
pevalAndTerm :: Term Bool -> Term Bool -> Term Bool

-- | Partial evaluation for imply terms.
pevalImplyTerm :: Term Bool -> Term Bool -> Term Bool

-- | Partial evaluation for xor terms.
pevalXorTerm :: Term Bool -> Term Bool -> Term Bool

-- | Basic partial evaluation for ITE terms.
pevalITEBasic :: SupportedPrim a => Term Bool -> Term a -> Term a -> Maybe (Term a)

-- | Basic partial evaluation for ITE terms.
pevalITEBasicTerm :: SupportedPrim a => Term Bool -> Term a -> Term a -> Term a

-- | Default partial evaluation for equality terms.
pevalDefaultEqTerm :: SupportedNonFuncPrim a => Term a -> Term a -> Term Bool

-- | Type class for resolving the constraint for a supported non-function
--   primitive type.
type NonFuncPrimConstraint a = (SymVal NonFuncSBVBaseType a, EqSymbolic SBVType a, Mergeable SBVType a, SMTDefinable SBVType a, Mergeable SBVType a, SBVType a ~ SBV NonFuncSBVBaseType a, PrimConstraint a)

-- | Type class for resolving the base type for the SBV type for the
--   primitive type.
class (SupportedPrim a, Ord a, Eq a, Show a, Hashable a, Typeable a) => NonFuncSBVRep a where {
    type NonFuncSBVBaseType a;
}

-- | Indicates that a type is supported, can be represented as a symbolic
--   term, is not a function type, and can be lowered to an SBV term.
class NonFuncSBVRep a => SupportedNonFuncPrim a
conNonFuncSBVTerm :: SupportedNonFuncPrim a => a -> SBV (NonFuncSBVBaseType a)
symNonFuncSBVTerm :: (SupportedNonFuncPrim a, SBVFreshMonad m) => String -> m (SBV (NonFuncSBVBaseType a))
withNonFuncPrim :: SupportedNonFuncPrim a => (NonFuncPrimConstraint a => r) -> r

-- | Type class for resolving the SBV type for the primitive type.
class SBVRep t where {
    type SBVType t;
}

-- | Monads that supports generating sbv fresh variables.
class MonadIO m => SBVFreshMonad (m :: Type -> Type)
sbvFresh :: (SBVFreshMonad m, SymVal a) => String -> m (SBV a)

-- | Error message for unsupported types.
translateTypeError :: HasCallStack => Maybe String -> TypeRep a -> b

-- | Error message for failure to parse the SBV model result.
parseSMTModelResultError :: HasCallStack => TypeRep a -> ([([CV], CV)], CV) -> a

-- | Partition the list of CVs for models for functions.
partitionCVArg :: SupportedNonFuncPrim a => [([CV], CV)] -> [(a, [([CV], CV)])]

-- | Parse the scalar model result.
parseScalarSMTModelResult :: forall v r. (SatModel r, Typeable v) => (r -> v) -> ([([CV], CV)], CV) -> v

-- | Construct the <a>BVIsNonZero</a> constraint from the proof that the
--   width is at least 1.
bvIsNonZeroFromGEq1 :: forall (w :: Natural) r proxy. 1 <= w => proxy w -> (BVIsNonZero w => r) -> r

-- | A partial function from a to b.
type PartialFun a b = a -> Maybe b

-- | A partial rule for unary operations.
type PartialRuleUnary a b = PartialFun Term a Term b

-- | A total rule for unary operations.
type TotalRuleUnary a b = Term a -> Term b

-- | A partial rule for binary operations.
type PartialRuleBinary a b c = Term a -> PartialFun Term b Term c

-- | A total rule for binary operations.
type TotalRuleBinary a b c = Term a -> Term b -> Term c

-- | Totalize a partial function with a fallback function.
totalize :: PartialFun a b -> (a -> b) -> a -> b

-- | Totalize a binary partial function with a fallback function.
totalize2 :: (a -> PartialFun b c) -> (a -> b -> c) -> a -> b -> c

-- | A strategy for partially evaluating unary operations.
class UnaryPartialStrategy tag a b | tag a -> b
extractor :: UnaryPartialStrategy tag a b => tag -> Term a -> Maybe a
constantHandler :: UnaryPartialStrategy tag a b => tag -> a -> Maybe (Term b)
nonConstantHandler :: UnaryPartialStrategy tag a b => tag -> Term a -> Maybe (Term b)

-- | Partially evaluate a unary operation.
unaryPartial :: UnaryPartialStrategy tag a b => tag -> PartialRuleUnary a b

-- | A strategy for partially evaluating commutative binary operations.
class BinaryCommPartialStrategy tag a c | tag a -> c
singleConstantHandler :: BinaryCommPartialStrategy tag a c => tag -> a -> Term a -> Maybe (Term c)

-- | A strategy for partially evaluating operations.
class BinaryPartialStrategy tag a b c | tag a b -> c
extractora :: BinaryPartialStrategy tag a b c => tag -> Term a -> Maybe a
extractorb :: BinaryPartialStrategy tag a b c => tag -> Term b -> Maybe b
allConstantHandler :: BinaryPartialStrategy tag a b c => tag -> a -> b -> Maybe (Term c)
leftConstantHandler :: BinaryPartialStrategy tag a b c => tag -> a -> Term b -> Maybe (Term c)
($dmleftConstantHandler) :: (BinaryPartialStrategy tag a b c, a ~ b, BinaryCommPartialStrategy tag a c) => tag -> a -> Term b -> Maybe (Term c)
rightConstantHandler :: BinaryPartialStrategy tag a b c => tag -> Term a -> b -> Maybe (Term c)
($dmrightConstantHandler) :: (BinaryPartialStrategy tag a b c, a ~ b, BinaryCommPartialStrategy tag a c) => tag -> Term a -> b -> Maybe (Term c)
nonBinaryConstantHandler :: BinaryPartialStrategy tag a b c => tag -> Term a -> Term b -> Maybe (Term c)

-- | Partially evaluate a binary operation.
binaryPartial :: BinaryPartialStrategy tag a b c => tag -> PartialRuleBinary a b c

-- | Unfold a unary operation once.
unaryUnfoldOnce :: forall a b. SupportedPrim b => PartialRuleUnary a b -> TotalRuleUnary a b -> TotalRuleUnary a b

-- | Unfold a binary operation once.
binaryUnfoldOnce :: forall a b c. SupportedPrim c => PartialRuleBinary a b c -> TotalRuleBinary a b c -> TotalRuleBinary a b c

-- | Unfold a unary operation once.
generalUnaryUnfolded :: (Typeable a, SupportedPrim b) => (a -> b) -> (Term a -> Term b) -> Term a -> Term b

-- | Unfold a binary operation once.
generalBinaryUnfolded :: (Typeable a, Typeable b, SupportedPrim c) => (a -> b -> c) -> (Term a -> Term b -> Term c) -> Term a -> Term b -> Term c

-- | Unsafe version of <a>pevalBVConcatTerm</a>. Use <a>NatRepr</a> for the
--   bit-width representations.
unsafePevalBVConcatTerm :: forall bv (n1 :: Nat) (n2 :: Nat) (r :: Nat). PEvalBVTerm bv => NatRepr n1 -> NatRepr n2 -> NatRepr r -> Term (bv n1) -> Term (bv n2) -> Term (bv r)

-- | Unsafe version of <a>pevalBVExtendTerm</a>. Use <a>NatRepr</a> for the
--   bit-width representations.
unsafePevalBVExtendTerm :: forall bv (l :: Nat) (r :: Nat). PEvalBVTerm bv => NatRepr l -> NatRepr r -> Bool -> Term (bv l) -> Term (bv r)

-- | Unsafe version of <a>pevalBVSelectTerm</a>. Use <a>NatRepr</a> for the
--   bit-width representations.
unsafePevalBVSelectTerm :: forall bv (n :: Nat) (ix :: Nat) (w :: Nat). PEvalBVTerm bv => NatRepr n -> NatRepr ix -> NatRepr w -> Term (bv n) -> Term (bv w)

-- | Convert boolean term to a 1-bit bitvector term.
boolToBVTerm :: forall bv (n :: Nat). (PEvalBVTerm bv, KnownNat n, 1 <= n, forall (m :: Nat). (KnownNat m, 1 <= m) => SupportedPrim (bv m)) => Term Bool -> Term (bv n)

-- | Default partial evaluation of addition of numerical terms.
pevalDefaultAddNumTerm :: (PEvalNumTerm a, Eq a) => Term a -> Term a -> Term a

-- | Default partial evaluation of negation of numerical terms.
pevalDefaultNegNumTerm :: (PEvalNumTerm a, Eq a) => Term a -> Term a

-- | Default partial evaluation of multiplication of numerical terms.
pevalDefaultMulNumTerm :: (PEvalNumTerm a, Eq a) => Term a -> Term a -> Term a

-- | Default partial evaluation of absolute value of finite-bit numerical
--   terms.
pevalBitsAbsNumTerm :: (PEvalNumTerm a, Bits a) => Term a -> Term a

-- | Partial evaluation of absolute value of numerical terms that does not
--   overflow.
doPevalNoOverflowAbsNumTerm :: PEvalNumTerm a => Term a -> Maybe (Term a)

-- | Default partial evaluation of signum of numerical terms.
pevalGeneralSignumNumTerm :: PEvalNumTerm a => Term a -> Term a

-- | Partial evaluation of signum of numerical terms that does not
--   overflow.
doPevalNoOverflowSignumNumTerm :: PEvalNumTerm a => Term a -> Maybe (Term a)
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.Prim.Internal.Caches.Description (Grisette.Internal.SymPrim.Prim.Internal.Term.Term t))
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.HashId
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim t => GHC.Classes.Eq (Grisette.Internal.SymPrim.Prim.Internal.Term.Term t)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Term.TypeHashId
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.Prim.Internal.Caches.Description (Grisette.Internal.SymPrim.Prim.Internal.Term.Term t))
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.HashId
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim t => Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.Prim.Internal.Term.Term t)
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Term.TypeHashId
instance Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance Grisette.Internal.SymPrim.Prim.Internal.Caches.Interned (Grisette.Internal.SymPrim.Prim.Internal.Term.Term t)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim t, Grisette.Internal.SymPrim.Prim.Internal.Term.SymbolKindConstraint knd t, Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd) => GHC.Internal.Data.String.IsString (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind 'Grisette.Internal.SymPrim.Prim.Internal.Term.AnyKind
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind 'Grisette.Internal.SymPrim.Prim.Internal.Term.ConstantKind
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.Prim.Internal.Term.Term t)
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Caches.CachedInfo
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.Prim.Internal.Term.Term a)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep (Grisette.Internal.SymPrim.BV.IntN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.NonFuncSBVRep (Grisette.Internal.SymPrim.BV.WordN w)
instance GHC.Classes.Ord Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance GHC.Classes.Ord Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance GHC.Classes.Ord Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance GHC.Classes.Ord Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance GHC.Classes.Ord Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance GHC.Classes.Ord Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance GHC.Classes.Ord (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance GHC.Classes.Ord (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBVTerm Grisette.Internal.SymPrim.BV.IntN
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBVTerm Grisette.Internal.SymPrim.BV.WordN
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitwiseTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitwiseTerm (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalNumTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalNumTerm (Grisette.Internal.SymPrim.BV.WordN n)
instance Control.Monad.IO.Class.MonadIO m => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Data.SBV.Core.Symbolic.QueryT m)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m, GHC.Internal.Base.Monoid w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m, GHC.Internal.Base.Monoid w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.Reader.ReaderT r m)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.IO.Class.MonadIO m => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Data.SBV.Core.Symbolic.SymbolicT m)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m, GHC.Internal.Base.Monoid w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad m, GHC.Internal.Base.Monoid w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVFreshMonad (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep (Grisette.Internal.SymPrim.BV.IntN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep (Grisette.Internal.SymPrim.BV.WordN w)
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.FPBinaryOp
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingBinaryOp
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.FPRoundingUnaryOp
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.FPTrait
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.FPUnaryOp
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.FloatingUnaryOp
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.HashId
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance GHC.Internal.Show.Show (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance GHC.Internal.Show.Show (Grisette.Internal.SymPrim.Prim.Internal.Term.Term ty)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Term.TypeHashId
instance GHC.Internal.Show.Show (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim (Grisette.Internal.SymPrim.BV.IntN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim (Grisette.Internal.SymPrim.BV.WordN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint (Grisette.Internal.SymPrim.BV.IntN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint (Grisette.Internal.SymPrim.BV.WordN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (Grisette.Internal.SymPrim.BV.IntN w)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat w, 1 GHC.Internal.Data.Type.Ord.<= w) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (Grisette.Internal.SymPrim.BV.WordN w)


module Grisette.Internal.SymPrim.Prim.SomeTerm

-- | Existential wrapper for symbolic Grisette terms.
data SomeTerm
[SomeTerm] :: forall a. SupportedPrim a => Term a -> SomeTerm

-- | Wrap a symbolic term into <a>SomeTerm</a>.
someTerm :: Term a -> SomeTerm

-- | Get the unique identifier of a symbolic term.
someTermId :: SomeTerm -> Id
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.SomeTerm.SomeTerm
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.SomeTerm.SomeTerm
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.SomeTerm.SomeTerm


module Grisette.Internal.SymPrim.Prim.Pattern

-- | Extract all the subterms of a term.
pattern SubTerms :: [SomeTerm] -> Term a


module Grisette.Internal.SymPrim.Prim.Internal.PartialEval

-- | A partial function from a to b.
type PartialFun a b = a -> Maybe b

-- | A partial rule for unary operations.
type PartialRuleUnary a b = PartialFun Term a Term b

-- | A total rule for unary operations.
type TotalRuleUnary a b = Term a -> Term b

-- | A partial rule for binary operations.
type PartialRuleBinary a b c = Term a -> PartialFun Term b Term c

-- | A total rule for binary operations.
type TotalRuleBinary a b c = Term a -> Term b -> Term c

-- | Totalize a partial function with a fallback function.
totalize :: PartialFun a b -> (a -> b) -> a -> b

-- | Totalize a binary partial function with a fallback function.
totalize2 :: (a -> PartialFun b c) -> (a -> b -> c) -> a -> b -> c

-- | A strategy for partially evaluating unary operations.
class UnaryPartialStrategy tag a b | tag a -> b
extractor :: UnaryPartialStrategy tag a b => tag -> Term a -> Maybe a
constantHandler :: UnaryPartialStrategy tag a b => tag -> a -> Maybe (Term b)
nonConstantHandler :: UnaryPartialStrategy tag a b => tag -> Term a -> Maybe (Term b)

-- | Partially evaluate a unary operation.
unaryPartial :: UnaryPartialStrategy tag a b => tag -> PartialRuleUnary a b

-- | A strategy for partially evaluating commutative binary operations.
class BinaryCommPartialStrategy tag a c | tag a -> c
singleConstantHandler :: BinaryCommPartialStrategy tag a c => tag -> a -> Term a -> Maybe (Term c)

-- | A strategy for partially evaluating operations.
class BinaryPartialStrategy tag a b c | tag a b -> c
extractora :: BinaryPartialStrategy tag a b c => tag -> Term a -> Maybe a
extractorb :: BinaryPartialStrategy tag a b c => tag -> Term b -> Maybe b
allConstantHandler :: BinaryPartialStrategy tag a b c => tag -> a -> b -> Maybe (Term c)
leftConstantHandler :: BinaryPartialStrategy tag a b c => tag -> a -> Term b -> Maybe (Term c)
($dmleftConstantHandler) :: (BinaryPartialStrategy tag a b c, a ~ b, BinaryCommPartialStrategy tag a c) => tag -> a -> Term b -> Maybe (Term c)
rightConstantHandler :: BinaryPartialStrategy tag a b c => tag -> Term a -> b -> Maybe (Term c)
($dmrightConstantHandler) :: (BinaryPartialStrategy tag a b c, a ~ b, BinaryCommPartialStrategy tag a c) => tag -> Term a -> b -> Maybe (Term c)
nonBinaryConstantHandler :: BinaryPartialStrategy tag a b c => tag -> Term a -> Term b -> Maybe (Term c)

-- | Partially evaluate a binary operation.
binaryPartial :: BinaryPartialStrategy tag a b c => tag -> PartialRuleBinary a b c


module Grisette.Internal.SymPrim.Prim.Internal.Unfold

-- | Unfold a unary operation once.
unaryUnfoldOnce :: forall a b. SupportedPrim b => PartialRuleUnary a b -> TotalRuleUnary a b -> TotalRuleUnary a b

-- | Unfold a binary operation once.
binaryUnfoldOnce :: forall a b c. SupportedPrim c => PartialRuleBinary a b c -> TotalRuleBinary a b c -> TotalRuleBinary a b c

-- | Unfold a unary operation once.
generalUnaryUnfolded :: (Typeable a, SupportedPrim b) => (a -> b) -> (Term a -> Term b) -> Term a -> Term b

-- | Unfold a binary operation once.
generalBinaryUnfolded :: (Typeable a, Typeable b, SupportedPrim c) => (a -> b -> c) -> (Term a -> Term b -> Term c) -> Term a -> Term b -> Term c


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalShiftTerm

-- | Partial evaluation of symbolic shift left term for finite bits types.
pevalFiniteBitsSymShiftShiftLeftTerm :: forall bv (n :: Nat). (forall (m :: Nat). (KnownNat m, 1 <= m) => Integral (bv m), forall (m :: Nat). (KnownNat m, 1 <= m) => SymShift (bv m), forall (m :: Nat). (KnownNat m, 1 <= m) => SupportedPrim (bv m), forall (m :: Nat). (KnownNat m, 1 <= m) => PEvalShiftTerm (bv m), PEvalBVTerm bv, KnownNat n, 1 <= n) => Term (bv n) -> Term (bv n) -> Term (bv n)

-- | Partial evaluation of symbolic shift right term for finite bits types.
pevalFiniteBitsSymShiftShiftRightTerm :: forall bv (n :: Nat). (forall (m :: Nat). (KnownNat m, 1 <= m) => Integral (bv m), forall (m :: Nat). (KnownNat m, 1 <= m) => SymShift (bv m), forall (m :: Nat). (KnownNat m, 1 <= m) => SupportedPrim (bv m), forall (m :: Nat). (KnownNat m, 1 <= m) => PEvalShiftTerm (bv m), PEvalBVTerm bv, KnownNat n, 1 <= n) => Term (bv n) -> Term (bv n) -> Term (bv n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalShiftTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalShiftTerm (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalRotateTerm

-- | Partial evaluation of symbolic rotate left term for finite bits types.
pevalFiniteBitsSymRotateRotateLeftTerm :: (Integral a, SymRotate a, FiniteBits a, PEvalRotateTerm a) => Term a -> Term a -> Term a

-- | Partial evaluation of symbolic rotate right term for finite bits
--   types.
pevalFiniteBitsSymRotateRotateRightTerm :: (Integral a, SymRotate a, FiniteBits a, PEvalRotateTerm a) => Term a -> Term a -> Term a
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalRotateTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalRotateTerm (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalDivModIntegralTerm

-- | Default partial evaluation of division operation for integral types.
pevalDefaultDivIntegralTerm :: (PEvalDivModIntegralTerm a, Integral a) => Term a -> Term a -> Term a

-- | Default partial evaluation of division operation for bounded integral
--   types.
pevalDefaultDivBoundedIntegralTerm :: (PEvalDivModIntegralTerm a, Bounded a, Integral a) => Term a -> Term a -> Term a

-- | Default partial evaluation of modulo operation for integral types.
pevalDefaultModIntegralTerm :: (PEvalDivModIntegralTerm a, Integral a) => Term a -> Term a -> Term a

-- | Default partial evaluation of quotient operation for integral types.
pevalDefaultQuotIntegralTerm :: (PEvalDivModIntegralTerm a, Integral a) => Term a -> Term a -> Term a

-- | Default partial evaluation of quotient operation for bounded integral
--   types.
pevalDefaultQuotBoundedIntegralTerm :: (PEvalDivModIntegralTerm a, Bounded a, Integral a) => Term a -> Term a -> Term a

-- | Default partial evaluation of remainder operation for integral types.
pevalDefaultRemIntegralTerm :: (PEvalDivModIntegralTerm a, Integral a) => Term a -> Term a -> Term a
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalDivModIntegralTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalDivModIntegralTerm GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalDivModIntegralTerm (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.SymPrim.FunInstanceGen

-- | Generate an instance of <a>SupportedPrim</a> for a function with a
--   given number of arguments.
supportedPrimFun :: ExpQ -> ExpQ -> ExpQ -> ([TypeQ] -> ExpQ) -> String -> String -> Name -> Int -> DecsQ

-- | Generate instances of <a>SupportedPrim</a> for functions with up to a
--   given number of arguments.
supportedPrimFunUpTo :: ExpQ -> ExpQ -> ExpQ -> ([TypeQ] -> ExpQ) -> String -> String -> Name -> Int -> DecsQ


module Grisette.Internal.SymPrim.TabularFun

-- | Functions as a table. Use the <a>#</a> operator to apply the function.
--   
--   <pre>
--   &gt;&gt;&gt; let f = TabularFun [(1, 2), (3, 4)] 0 :: Int =-&gt; Int
--   
--   &gt;&gt;&gt; f # 1
--   2
--   
--   &gt;&gt;&gt; f # 2
--   0
--   
--   &gt;&gt;&gt; f # 3
--   4
--   </pre>
data a =-> b
TabularFun :: [(a, b)] -> b -> (=->) a b
[funcTable] :: (=->) a b -> [(a, b)]
[defaultFuncValue] :: (=->) a b -> b
infixr 0 =->
instance (Grisette.Internal.Core.Data.Class.Function.Apply t, GHC.Classes.Eq a) => Grisette.Internal.Core.Data.Class.Function.Apply (a Grisette.Internal.SymPrim.TabularFun.=-> t)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance GHC.Classes.Eq a => Grisette.Internal.Core.Data.Class.Function.Function (a Grisette.Internal.SymPrim.TabularFun.=-> b) a b
instance GHC.Internal.Generics.Generic1 ((Grisette.Internal.SymPrim.TabularFun.=->) a)
instance GHC.Internal.Generics.Generic (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 ((Grisette.Internal.SymPrim.TabularFun.=->) a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim b, GHC.Classes.Eq a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a Grisette.Internal.SymPrim.TabularFun.=-> b)) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalApplyTerm (a Grisette.Internal.SymPrim.TabularFun.=-> b) a b
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim b) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (a Grisette.Internal.SymPrim.TabularFun.=-> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> a1)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> (a1 Grisette.Internal.SymPrim.TabularFun.=-> a2))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> (a1 Grisette.Internal.SymPrim.TabularFun.=-> (a2 Grisette.Internal.SymPrim.TabularFun.=-> a3)))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> (a1 Grisette.Internal.SymPrim.TabularFun.=-> (a2 Grisette.Internal.SymPrim.TabularFun.=-> (a3 Grisette.Internal.SymPrim.TabularFun.=-> a4))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a5) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> (a1 Grisette.Internal.SymPrim.TabularFun.=-> (a2 Grisette.Internal.SymPrim.TabularFun.=-> (a3 Grisette.Internal.SymPrim.TabularFun.=-> (a4 Grisette.Internal.SymPrim.TabularFun.=-> a5)))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a5, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a6) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> (a1 Grisette.Internal.SymPrim.TabularFun.=-> (a2 Grisette.Internal.SymPrim.TabularFun.=-> (a3 Grisette.Internal.SymPrim.TabularFun.=-> (a4 Grisette.Internal.SymPrim.TabularFun.=-> (a5 Grisette.Internal.SymPrim.TabularFun.=-> a6))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a5, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a6, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a7) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.TabularFun.=-> (a1 Grisette.Internal.SymPrim.TabularFun.=-> (a2 Grisette.Internal.SymPrim.TabularFun.=-> (a3 Grisette.Internal.SymPrim.TabularFun.=-> (a4 Grisette.Internal.SymPrim.TabularFun.=-> (a5 Grisette.Internal.SymPrim.TabularFun.=-> (a6 Grisette.Internal.SymPrim.TabularFun.=-> a7)))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim b) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint (a Grisette.Internal.SymPrim.TabularFun.=-> b)


module Grisette.Internal.Backend.QuantifiedStack

-- | A set of quantified symbols.
newtype QuantifiedSymbols
QuantifiedSymbols :: HashSet SomeTypedConstantSymbol -> QuantifiedSymbols
[_symbols] :: QuantifiedSymbols -> HashSet SomeTypedConstantSymbol

-- | A stack of quantified symbols.
data QuantifiedStack

-- | Add a quantified symbol to the stack.
addQuantified :: TypedConstantSymbol a -> Dynamic -> QuantifiedStack -> QuantifiedStack

-- | Look up a quantified symbol in the stack.
lookupQuantified :: forall (knd :: SymbolKind). (HasCallStack, IsSymbolKind knd) => SomeTypedSymbol knd -> QuantifiedStack -> Maybe Dynamic

-- | An empty set of quantified symbols.
emptyQuantifiedSymbols :: QuantifiedSymbols

-- | Add a quantified symbol to the set.
addQuantifiedSymbol :: TypedConstantSymbol a -> QuantifiedSymbols -> QuantifiedSymbols

-- | Check if a symbol is quantified.
isQuantifiedSymbol :: forall a (knd :: SymbolKind). (SupportedPrim a, IsSymbolKind knd) => TypedSymbol knd a -> QuantifiedSymbols -> Bool

-- | An empty stack of quantified symbols.
emptyQuantifiedStack :: QuantifiedStack
instance GHC.Classes.Eq Grisette.Internal.Backend.QuantifiedStack.QuantifiedStack
instance Data.Hashable.Class.Hashable Grisette.Internal.Backend.QuantifiedStack.QuantifiedStack
instance GHC.Internal.Show.Show Grisette.Internal.Backend.QuantifiedStack.QuantifiedSymbols


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalNumTerm
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalNumTerm Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalNumTerm (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalNumTerm GHC.Num.Integer.Integer


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalOrdTerm

-- | General partially evaluation of less than operation.
pevalGeneralLtOrdTerm :: (PEvalOrdTerm a, Ord a) => Term a -> Term a -> Term Bool

-- | General partially evaluation of less than or equal to operation.
pevalGeneralLeOrdTerm :: (PEvalOrdTerm a, Ord a) => Term a -> Term a -> Term Bool
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalOrdTerm Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalOrdTerm (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalOrdTerm Grisette.Internal.SymPrim.FP.FPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalOrdTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalOrdTerm GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalOrdTerm (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalIEEEFPConvertibleTerm

-- | Generic implementation for floating-point casting operators for sbv.
genericFPCast :: (HasKind a, HasKind r) => SRoundingMode -> SBV a -> SBV r
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalIEEEFPConvertibleTerm Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalIEEEFPConvertibleTerm (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalIEEEFPConvertibleTerm (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalIEEEFPConvertibleTerm GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalIEEEFPConvertibleTerm (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalFromIntegralTerm
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.IntN n) Grisette.Internal.SymPrim.AlgReal.AlgReal
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.IntN m)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.IntN n) GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.WordN m)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm GHC.Num.Integer.Integer Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm GHC.Num.Integer.Integer GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.WordN n) Grisette.Internal.SymPrim.AlgReal.AlgReal
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.IntN m)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.WordN n) GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFromIntegralTerm (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.WordN m)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalFractionalTerm
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFractionalTerm Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFractionalTerm (Grisette.Internal.SymPrim.FP.FP eb sb)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalFloatingTerm
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFloatingTerm Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFloatingTerm (Grisette.Internal.SymPrim.FP.FP eb sb)


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalFP
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalFPTerm Grisette.Internal.SymPrim.FP.FP


module Grisette.Internal.SymPrim.GeneralFun

-- | General symbolic function type. Use the <a>#</a> operator to apply the
--   function. Note that this function should be applied to symbolic values
--   only. It is by itself already a symbolic value, but can be considered
--   partially concrete as the function body is specified. Use
--   <a>-~&gt;</a> for uninterpreted general symbolic functions.
--   
--   The result would be partially evaluated.
--   
--   <pre>
--   &gt;&gt;&gt; let f = ("x" :: TypedConstantSymbol Integer) --&gt; ("x" + 1 + "y" :: SymInteger) :: Integer --&gt; Integer
--   
--   &gt;&gt;&gt; f # 1    -- 1 has the type SymInteger
--   (+ 2 y)
--   
--   &gt;&gt;&gt; f # "a"  -- "a" has the type SymInteger
--   (+ 1 (+ a y))
--   </pre>
data a --> b
[GeneralFun] :: forall a b. (SupportedNonFuncPrim a, SupportedPrim b) => TypedConstantSymbol a -> Term b -> a --> b
infixr 0 -->

-- | Build a general symbolic function with a bounded symbol and a term.
buildGeneralFun :: (SupportedNonFuncPrim a, SupportedPrim b) => TypedConstantSymbol a -> Term b -> a --> b

-- | General procedure for substituting symbols in a term.
generalSubstSomeTerm :: (forall a. () => TypedSymbol 'AnyKind a -> Term a) -> HashSet SomeTypedConstantSymbol -> Term v -> Term v

-- | Substitute a term for a symbol in a term.
substTerm :: forall (knd :: SymbolKind) a b. (SupportedPrim a, SupportedPrim b, IsSymbolKind knd) => TypedSymbol knd a -> Term a -> HashSet SomeTypedConstantSymbol -> Term b -> Term b

-- | Generate a fresh argument symbol that is not used as bounded or
--   unbounded variables in the function body for a general symbolic
--   function.
freshArgSymbol :: SupportedNonFuncPrim a => [SomeTerm] -> TypedConstantSymbol a
instance (Grisette.Internal.Core.Data.Class.Function.Apply st, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ct st) => Grisette.Internal.Core.Data.Class.Function.Apply (ca Grisette.Internal.SymPrim.GeneralFun.--> ct)
instance GHC.Classes.Eq (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep a sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep b sb) => Grisette.Internal.Core.Data.Class.Function.Function (a Grisette.Internal.SymPrim.GeneralFun.--> b) sa sb
instance Data.Hashable.Class.Hashable (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance Language.Haskell.TH.Syntax.Lift (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance Control.DeepSeq.NFData (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a Grisette.Internal.SymPrim.GeneralFun.--> b), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim b) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalApplyTerm (a Grisette.Internal.SymPrim.GeneralFun.--> b) a b
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim b) => Grisette.Internal.SymPrim.Prim.Internal.Term.SBVRep (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance GHC.Internal.Show.Show (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> a1)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> (a1 Grisette.Internal.SymPrim.GeneralFun.--> a2))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> (a1 Grisette.Internal.SymPrim.GeneralFun.--> (a2 Grisette.Internal.SymPrim.GeneralFun.--> a3)))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> (a1 Grisette.Internal.SymPrim.GeneralFun.--> (a2 Grisette.Internal.SymPrim.GeneralFun.--> (a3 Grisette.Internal.SymPrim.GeneralFun.--> a4))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a5) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> (a1 Grisette.Internal.SymPrim.GeneralFun.--> (a2 Grisette.Internal.SymPrim.GeneralFun.--> (a3 Grisette.Internal.SymPrim.GeneralFun.--> (a4 Grisette.Internal.SymPrim.GeneralFun.--> a5)))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a5, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a6) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> (a1 Grisette.Internal.SymPrim.GeneralFun.--> (a2 Grisette.Internal.SymPrim.GeneralFun.--> (a3 Grisette.Internal.SymPrim.GeneralFun.--> (a4 Grisette.Internal.SymPrim.GeneralFun.--> (a5 Grisette.Internal.SymPrim.GeneralFun.--> a6))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a0, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a1, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a2, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a3, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a4, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a5, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a6, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a7) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a0 Grisette.Internal.SymPrim.GeneralFun.--> (a1 Grisette.Internal.SymPrim.GeneralFun.--> (a2 Grisette.Internal.SymPrim.GeneralFun.--> (a3 Grisette.Internal.SymPrim.GeneralFun.--> (a4 Grisette.Internal.SymPrim.GeneralFun.--> (a5 Grisette.Internal.SymPrim.GeneralFun.--> (a6 Grisette.Internal.SymPrim.GeneralFun.--> a7)))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim a, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim b) => Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrimConstraint (a Grisette.Internal.SymPrim.GeneralFun.--> b)


module Grisette.Internal.SymPrim.Prim.TermUtils

-- | Extract all the symbols in a term.
extractTerm :: forall (knd :: SymbolKind) a. (IsSymbolKind knd, SymbolKindConstraint knd a, SupportedPrim a) => HashSet SomeTypedConstantSymbol -> Term a -> Maybe (HashSet (SomeTypedSymbol knd))

-- | Cast a term to another type.
castTerm :: forall a b. Typeable b => Term a -> Maybe (Term b)

-- | Compute the size of a list of terms. Do not count the same term twice.
someTermsSize :: [SomeTerm] -> Int

-- | Compute the size of a list of terms. Do not count the same term twice.
someTermSize :: SomeTerm -> Int

-- | Compute the size of a term.
termSize :: Term a -> Int

-- | Compute the size of a list of terms. Do not count the same term twice.
termsSize :: [Term a] -> Int


module Grisette.Internal.SymPrim.Prim.Internal.Instances.PEvalBitCastTerm

-- | Partially evaluate a bitcast term. If no reduction is performed,
--   return Nothing.
doPevalBitCast :: (PEvalBitCastTerm a b, SupportedPrim b) => Term a -> Maybe (Term b)
instance (n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastOrTerm (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.IntN n)
instance (n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastOrTerm (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm GHC.Types.Bool (Grisette.Internal.SymPrim.BV.IntN 1)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm GHC.Types.Bool (Grisette.Internal.SymPrim.BV.WordN 1)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm (Grisette.Internal.SymPrim.BV.IntN 1) GHC.Types.Bool
instance (n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm (Grisette.Internal.SymPrim.BV.WordN 1) GHC.Types.Bool
instance (n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.PEvalBitCastTerm (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.FP.FP eb sb)


module Grisette.Internal.SymPrim.Prim.Internal.Serialize
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> c))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> d)))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> e))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> f)))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> g))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg h) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> (g Grisette.Internal.SymPrim.GeneralFun.--> h)))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg h, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg i) => Data.Binary.Class.Binary (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> (g Grisette.Internal.SymPrim.GeneralFun.--> (h Grisette.Internal.SymPrim.GeneralFun.--> i))))))))
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownNonFuncType
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.SomeTerm.SomeTerm
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim a => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.Prim.Internal.Term.Term a)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd, GHC.Internal.Data.Typeable.Internal.Typeable a) => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownNonFuncType
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownNonFuncType
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> c))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> d)))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> e))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> f)))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> g))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg h) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> (g Grisette.Internal.SymPrim.GeneralFun.--> h)))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg h, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg i) => Data.Bytes.Serial.Serial (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> (g Grisette.Internal.SymPrim.GeneralFun.--> (h Grisette.Internal.SymPrim.GeneralFun.--> i))))))))
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownNonFuncType
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.SomeTerm.SomeTerm
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim a => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.Prim.Internal.Term.Term a)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd, GHC.Internal.Data.Typeable.Internal.Typeable a) => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a)
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> c))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> d)))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> e))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> f)))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> g))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg h) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> (g Grisette.Internal.SymPrim.GeneralFun.--> h)))))))
instance (Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg a, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg b, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg c, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg d, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg e, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg f, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg g, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg h, Grisette.Internal.SymPrim.Prim.Internal.Serialize.GeneralFunArg i) => Data.Serialize.Serialize (a Grisette.Internal.SymPrim.GeneralFun.--> (b Grisette.Internal.SymPrim.GeneralFun.--> (c Grisette.Internal.SymPrim.GeneralFun.--> (d Grisette.Internal.SymPrim.GeneralFun.--> (e Grisette.Internal.SymPrim.GeneralFun.--> (f Grisette.Internal.SymPrim.GeneralFun.--> (g Grisette.Internal.SymPrim.GeneralFun.--> (h Grisette.Internal.SymPrim.GeneralFun.--> i))))))))
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownNonFuncType
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Internal.Term.ModelValue
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.SomeTerm.SomeTerm
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd => Data.Serialize.Serialize (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim a => Data.Serialize.Serialize (Grisette.Internal.SymPrim.Prim.Internal.Term.Term a)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd, GHC.Internal.Data.Typeable.Internal.Typeable a) => Data.Serialize.Serialize (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownNonFuncType
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Internal.Serialize.KnownType


module Grisette.Internal.SymPrim.Prim.Term


module Grisette.Internal.SymPrim.Prim.Model

-- | Set of symbols.
--   
--   Check <a>SymbolSetOps</a> for operations, and <a>SymbolSetRep</a> for
--   manual constructions.
newtype SymbolSet (knd :: SymbolKind)
SymbolSet :: HashSet (SomeTypedSymbol knd) -> SymbolSet (knd :: SymbolKind)
[unSymbolSet] :: SymbolSet (knd :: SymbolKind) -> HashSet (SomeTypedSymbol knd)

-- | Set of constant symbols. Excluding unintepreted functions.
type ConstantSymbolSet = SymbolSet 'ConstantKind

-- | Set of any symbols.
type AnySymbolSet = SymbolSet 'AnyKind

-- | Model returned by the solver.
--   
--   Check <a>ModelOps</a> for operations, and <a>ModelRep</a> for manual
--   constructions.
newtype Model
Model :: HashMap SomeTypedAnySymbol ModelValue -> Model
[unModel] :: Model -> HashMap SomeTypedAnySymbol ModelValue

-- | A type used for building a model by hand.
--   
--   <pre>
--   &gt;&gt;&gt; buildModel ("x" ::= (1 :: Integer), "y" ::= True) :: Model
--   Model {x -&gt; 1 :: Integer, y -&gt; true :: Bool}
--   </pre>
data ModelValuePair t
(::=) :: TypedAnySymbol t -> t -> ModelValuePair t

-- | Given a typed symbol and a model, return the equation (symbol = value)
--   encoded in the model.
equation :: TypedAnySymbol a -> Model -> Maybe (Term Bool)

-- | Evaluate a term in the given model.
evalTerm :: SupportedPrim a => Bool -> Model -> HashSet SomeTypedConstantSymbol -> Term a -> Term a
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.Prim.Model.Model
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Classes.Eq (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Internal.Generics.Generic (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.Prim.Model.Model
instance Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.Prim.Model.Model
instance Grisette.Internal.Core.Data.Class.ModelOps.ModelOps Grisette.Internal.SymPrim.Prim.Model.Model Grisette.Internal.SymPrim.Prim.Model.AnySymbolSet Grisette.Internal.SymPrim.Prim.Internal.Term.TypedAnySymbol
instance Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (Grisette.Internal.SymPrim.Prim.Model.ModelValuePair t) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep c Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b, c) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep c Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep d Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b, c, d) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep c Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep d Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep e Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b, c, d, e) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep c Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep d Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep e Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep f Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b, c, d, e, f) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep c Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep d Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep e Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep f Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep g Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b, c, d, e, f, g) Grisette.Internal.SymPrim.Prim.Model.Model
instance (Grisette.Internal.Core.Data.Class.ModelOps.ModelRep a Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep b Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep c Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep d Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep e Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep f Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep g Grisette.Internal.SymPrim.Prim.Model.Model, Grisette.Internal.Core.Data.Class.ModelOps.ModelRep h Grisette.Internal.SymPrim.Prim.Model.Model) => Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (a, b, c, d, e, f, g, h) Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Internal.Base.Monoid Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Internal.Base.Monoid (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Internal.Base.Semigroup Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Internal.Base.Semigroup (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.Prim.Model.Model
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.Prim.Model.Model
instance Grisette.Internal.SymPrim.Prim.Internal.Term.IsSymbolKind knd => Data.Serialize.Serialize (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.Prim.Model.Model
instance GHC.Internal.Show.Show t => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.Prim.Model.ModelValuePair t)
instance GHC.Internal.Show.Show (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetOps (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep [Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd] (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep [Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t] (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.SomeTypedSymbol knd) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd c) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd c, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd d) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd c, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd d, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd e) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd c, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd d, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd e, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd f) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd c, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd d, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd e, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd f, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd g) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd a, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd b, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd c, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd d, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd e, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd f, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd g, Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd h) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)
instance Grisette.Internal.Core.Data.Class.ModelOps.SymbolSetRep (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd t) (Grisette.Internal.SymPrim.Prim.Model.SymbolSet knd) (Grisette.Internal.SymPrim.Prim.Internal.Term.TypedSymbol knd)


module Grisette.Internal.SymPrim.ModelRep

-- | A pair of a symbolic constant and its value. This is used to build a
--   model from a list of symbolic constants and their values.
--   
--   <pre>
--   &gt;&gt;&gt; buildModel ("a" := (1 :: Integer), "b" := True) :: Model
--   Model {a -&gt; 1 :: Integer, b -&gt; true :: Bool}
--   </pre>
data ModelSymPair ct st
[:=] :: forall ct st. LinkedRep ct st => st -> ct -> ModelSymPair ct st
instance Grisette.Internal.Core.Data.Class.ModelOps.ModelRep (Grisette.Internal.SymPrim.ModelRep.ModelSymPair ct st) Grisette.Internal.SymPrim.Prim.Model.Model


module Grisette.Internal.Backend.SymBiMap

-- | A bidirectional map between symbolic Grisette terms and sbv terms.
data SymBiMap
SymBiMap :: HashMap SomeTerm (QuantifiedStack -> Dynamic) -> Int -> HashMap String SomeTypedAnySymbol -> Int -> SymBiMap
[biMapToSBV] :: SymBiMap -> HashMap SomeTerm (QuantifiedStack -> Dynamic)
[biMapSize] :: SymBiMap -> Int
[biMapFromSBV] :: SymBiMap -> HashMap String SomeTypedAnySymbol
[quantifiedSymbolNum] :: SymBiMap -> Int

-- | An empty bidirectional map.
emptySymBiMap :: SymBiMap

-- | The size of the bidirectional map.
sizeBiMap :: SymBiMap -> Int

-- | Add a new entry to the bidirectional map.
addBiMap :: forall (knd :: SymbolKind). HasCallStack => SomeTerm -> Dynamic -> String -> SomeTypedSymbol knd -> SymBiMap -> SymBiMap

-- | Add a new entry to the bidirectional map for intermediate values.
addBiMapIntermediate :: HasCallStack => SomeTerm -> (QuantifiedStack -> Dynamic) -> SymBiMap -> SymBiMap

-- | Find a symbolic Grisette term from a string.
findStringToSymbol :: forall (knd :: SymbolKind). IsSymbolKind knd => String -> SymBiMap -> Maybe (SomeTypedSymbol knd)

-- | Look up an sbv value with a symbolic Grisette term in the
--   bidirectional map.
lookupTerm :: HasCallStack => SomeTerm -> SymBiMap -> Maybe (QuantifiedStack -> Dynamic)

-- | Attach the next quantified symbol info to a symbol.
attachNextQuantifiedSymbolInfo :: SymBiMap -> TypedConstantSymbol a -> (SymBiMap, TypedConstantSymbol a)
instance GHC.Internal.Show.Show Grisette.Internal.Backend.SymBiMap.SymBiMap

module Grisette.Internal.Core.Data.Class.AsKey

-- | Type class for identity equality for terms.
class KeyEq a
keyEq :: KeyEq a => a -> a -> Bool
infix 4 `keyEq`

-- | Type class for comparing terms based on their identity.
class KeyEq a => KeyOrd a
keyCompare :: KeyOrd a => a -> a -> Ordering
infix 4 `keyCompare`

-- | Type class for hashing terms based on their identity.
class KeyEq a => KeyHashable a
keyHashWithSalt :: KeyHashable a => Int -> a -> Int
infixl 0 `keyHashWithSalt`
class KeyEq1 (f :: Type -> Type)
liftKeyEq :: KeyEq1 f => (a -> b -> Bool) -> f a -> f b -> Bool
class KeyEq1 f => KeyOrd1 (f :: Type -> Type)
liftKeyCompare :: KeyOrd1 f => (a -> b -> Ordering) -> f a -> f b -> Ordering
class KeyEq1 f => KeyHashable1 (f :: Type -> Type)
liftKeyHashWithSalt :: KeyHashable1 f => (Int -> a -> Int) -> Int -> f a -> Int

-- | Use a term as a key with identity equality.
--   
--   For example, <tt><a>AsKey</a> <a>SymBool</a></tt> uses the term
--   identity for <a>SymBool</a>.
newtype AsKey a
AsKey :: a -> AsKey a
[getAsKey] :: AsKey a -> a

-- | Use a union as a key with identity equality.
--   
--   For example, <tt><a>AsKey1</a> <a>Union</a></tt> uses the term
--   identity for <a>Union</a>.
newtype AsKey1 (f :: Type -> Type) a
AsKey1 :: f a -> AsKey1 (f :: Type -> Type) a
[getAsKey1] :: AsKey1 (f :: Type -> Type) a -> f a
shouldUseAsKeyError :: HasCallStack => String -> String -> a
shouldUseAsKeyHasSymbolicVersionError :: HasCallStack => String -> String -> String -> a
shouldUseSymbolicVersionError :: HasCallStack => String -> String -> String -> a
instance GHC.Internal.Base.Applicative f => GHC.Internal.Base.Applicative (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Grisette.Internal.Core.Data.Class.Function.Apply a => Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.BitVector.BV a => Grisette.Internal.Core.Data.Class.BitVector.BV (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Data.Binary.Class.Binary (f a) => Data.Binary.Class.Binary (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical a b => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical a b => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical a b => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast a b => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast a b => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast a b => Grisette.Internal.Core.Data.Class.BitCast.BitCast a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance (Grisette.Internal.Core.Data.Class.AsKey.KeyEq a, GHC.Internal.Bits.Bits a) => GHC.Internal.Bits.Bits (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Enum.Bounded a => GHC.Internal.Enum.Bounded (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep a => Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.Concrete.Concrete (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Enum.Enum a => GHC.Internal.Enum.Enum (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq1 f => Data.Functor.Classes.Eq1 (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq a => GHC.Classes.Eq (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance (Grisette.Internal.Core.Data.Class.AsKey.KeyEq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance (Grisette.Internal.Core.Data.Class.AsKey.KeyEq a, GHC.Internal.Bits.FiniteBits a) => GHC.Internal.Bits.FiniteBits (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Float.Floating a => GHC.Internal.Float.Floating (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Real.Fractional a => GHC.Internal.Real.Fractional (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.Function.Function (f a) arg (f res) => Grisette.Internal.Core.Data.Class.Function.Function (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a) arg (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f res)
instance Grisette.Internal.Core.Data.Class.Function.Function a arg res => Grisette.Internal.Core.Data.Class.Function.Function (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) arg res
instance GHC.Internal.Base.Functor Grisette.Internal.Core.Data.Class.AsKey.AsKey
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable1 f => Data.Hashable.Class.Hashable1 (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable a => Data.Hashable.Class.Hashable (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance (Grisette.Internal.Core.Data.Class.AsKey.KeyHashable1 f, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConstants a => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConstants (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible a fp mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey fp) (Grisette.Internal.Core.Data.Class.AsKey.AsKey mode)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible a fp mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) fp mode
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible a fp mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible a (Grisette.Internal.Core.Data.Class.AsKey.AsKey fp) (Grisette.Internal.Core.Data.Class.AsKey.AsKey mode)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPOp a => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPOp (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingMode a => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingMode (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingOp a mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingOp (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey mode)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal a fp mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey fp) (Grisette.Internal.Core.Data.Class.AsKey.AsKey mode)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal a fp mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) fp mode
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal a fp mode => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal a (Grisette.Internal.Core.Data.Class.AsKey.AsKey fp) (Grisette.Internal.Core.Data.Class.AsKey.AsKey mode)
instance GHC.Internal.Data.String.IsString a => GHC.Internal.Data.String.IsString (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Data.String.IsString (f a) => GHC.Internal.Data.String.IsString (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP a b => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.FP.FP a b)
instance GHC.Classes.Eq a => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (GHC.Internal.Data.Functor.Identity.Identity a)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP a b => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.FP.FP a b)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (GHC.Internal.Data.Functor.Identity.Identity a)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.BV.WordN n)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Language.Haskell.TH.Syntax.Lift (f a) => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance GHC.Internal.Base.Monad f => GHC.Internal.Base.Monad (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Control.DeepSeq.NFData1 f => Control.DeepSeq.NFData1 (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Control.DeepSeq.NFData (f a) => Control.DeepSeq.NFData (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance GHC.Internal.Num.Num a => GHC.Internal.Num.Num (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Num.Num (f a) => GHC.Internal.Num.Num (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyOrd1 f => Data.Functor.Classes.Ord1 (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyOrd a => GHC.Classes.Ord (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance (Grisette.Internal.Core.Data.Class.AsKey.KeyOrd1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial1 f) => Data.Bytes.Serial.Serial (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Data.Serialize.Serialize (f a) => Data.Serialize.Serialize (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Show.Show (f a) => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a)
instance Grisette.Internal.Core.Data.Class.SignConversion.SignConversion a b => Grisette.Internal.Core.Data.Class.SignConversion.SignConversion (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)


module Grisette.Internal.Core.Data.Class.Solvable

-- | The class defines the creation and pattern matching of solvable type
--   values.
class IsString t => Solvable c t | t -> c

-- | Wrap a concrete value in a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; con True :: SymBool
--   true
--   </pre>
con :: Solvable c t => c -> t

-- | Extract the concrete value from a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; conView (con True :: SymBool)
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conView (ssym "a" :: SymBool)
--   Nothing
--   </pre>
conView :: Solvable c t => t -> Maybe c

-- | Generate symbolic constants.
--   
--   Two symbolic constants with the same symbol are the same symbolic
--   constant, and will always be assigned with the same value by the
--   solver.
--   
--   In the examples, we use <a>AsKey</a> to check if two symbolic
--   constants are the same term, concretely.
--   
--   <pre>
--   &gt;&gt;&gt; sym "a" :: SymBool
--   a
--   
--   &gt;&gt;&gt; AsKey (sym "a" :: SymBool) == AsKey (sym "a" :: SymBool)
--   True
--   
--   &gt;&gt;&gt; AsKey (sym "a" :: SymBool) == AsKey (sym "b")
--   False
--   
--   &gt;&gt;&gt; (sym "a" :: SymBool) .&amp;&amp; sym "a"
--   a
--   
--   &gt;&gt;&gt; AsKey (sym "a" :: SymBool) == AsKey (isym "a" 1)
--   False
--   </pre>
sym :: Solvable c t => Symbol -> t

-- | Generate simply-named symbolic constants.
--   
--   Two symbolic constants with the same identifier are the same symbolic
--   constant, and will always be assigned with the same value by the
--   solver.
--   
--   In the examples, we use <a>AsKey</a> to check if two symbolic
--   constants are the same term, concretely.
--   
--   <pre>
--   &gt;&gt;&gt; ssym "a" :: SymBool
--   a
--   
--   &gt;&gt;&gt; AsKey (ssym "a" :: SymBool) == AsKey (ssym "a" :: SymBool)
--   True
--   
--   &gt;&gt;&gt; AsKey (ssym "a" :: SymBool) == AsKey (ssym "b")
--   False
--   
--   &gt;&gt;&gt; (ssym "a" :: SymBool) .&amp;&amp; ssym "a"
--   a
--   </pre>
ssym :: Solvable c t => Identifier -> t

-- | Generate indexed symbolic constants.
--   
--   Two symbolic constants with the same identifier but different indices
--   are not the same symbolic constants.
--   
--   <pre>
--   &gt;&gt;&gt; isym "a" 1 :: SymBool
--   a@1
--   </pre>
isym :: Solvable c t => Identifier -> Int -> t

-- | Extract the concrete value from a solvable value with <a>conView</a>.
--   
--   <pre>
--   &gt;&gt;&gt; case con True :: SymBool of Con v -&gt; v
--   True
--   </pre>
pattern Con :: Solvable c t => c -> t

-- | Generate simply-named symbolic variables. The file location will be
--   attached to the identifier.
--   
--   <pre>
--   &gt;&gt;&gt; $$(slocsym "a") :: SymBool
--   a:[grisette-file-location &lt;interactive&gt;...]
--   </pre>
--   
--   Calling <a>slocsym</a> with the same name at different location will
--   always generate different symbolic constants. Calling <a>slocsym</a>
--   at the same location for multiple times will generate the same
--   symbolic constants.
--   
--   In the examples, we use <a>AsKey</a> to check if two symbolic
--   constants are the same term, concretely.
--   
--   <pre>
--   &gt;&gt;&gt; AsKey ($$(slocsym "a") :: SymBool) == AsKey ($$(slocsym "a") :: SymBool)
--   False
--   
--   &gt;&gt;&gt; let f _ = $$(slocsym "a") :: SymBool
--   
--   &gt;&gt;&gt; AsKey (f ()) == AsKey (f ())
--   True
--   </pre>
slocsym :: Solvable c s => Text -> SpliceQ s

-- | Generate indexed symbolic variables. The file location will be
--   attached to the identifier.
--   
--   <pre>
--   &gt;&gt;&gt; $$(ilocsym "a" 1) :: SymBool
--   a:[grisette-file-location &lt;interactive&gt;...]@1
--   </pre>
--   
--   Calling <a>ilocsym</a> with the same name and index at different
--   location will always generate different symbolic constants. Calling
--   <a>slocsym</a> at the same location for multiple times will generate
--   the same symbolic constants.
ilocsym :: Solvable c s => Text -> Int -> SpliceQ s
instance Grisette.Internal.Core.Data.Class.Solvable.Solvable c s => Grisette.Internal.Core.Data.Class.Solvable.Solvable c (Grisette.Internal.Core.Data.Class.AsKey.AsKey s)
instance Grisette.Internal.Core.Data.Class.Solvable.Solvable c (f s) => Grisette.Internal.Core.Data.Class.Solvable.Solvable c (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f s)


module Grisette.Internal.SymPrim.SymTabularFun

-- | Symbolic tabular function type.
--   
--   <pre>
--   &gt;&gt;&gt; f' = "f" :: SymInteger =~&gt; SymInteger
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   (apply f 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f' = con (TabularFun [(1, 2), (2, 3)] 4) :: SymInteger =~&gt; SymInteger
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   2
--   
--   &gt;&gt;&gt; f 2
--   3
--   
--   &gt;&gt;&gt; f 3
--   4
--   
--   &gt;&gt;&gt; f "b"
--   (ite (= b 1) 2 (ite (= b 2) 3 4))
--   </pre>
data sa =~> sb
[SymTabularFun] :: forall ca sa cb sb. (LinkedRep ca sa, LinkedRep cb sb, SupportedPrim (ca =-> cb), SupportedNonFuncPrim ca) => Term (ca =-> cb) -> sa =~> sb
infixr 0 =~>
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.Function.Apply st => Grisette.Internal.Core.Data.Class.Function.Apply (sa Grisette.Internal.SymPrim.SymTabularFun.=~> st)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Data.Binary.Class.Binary (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep a, Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep b) => Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep (a Grisette.Internal.SymPrim.SymTabularFun.=~> b)
instance GHC.Classes.Eq (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.Function.Function (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb) sa sb
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => GHC.Internal.Data.String.IsString (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Language.Haskell.TH.Syntax.Lift (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep (ca Grisette.Internal.SymPrim.TabularFun.=-> cb) (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Control.DeepSeq.NFData (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Data.Bytes.Serial.Serial (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Data.Serialize.Serialize (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance GHC.Internal.Show.Show (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Grisette.Internal.Core.Data.Class.Solvable.Solvable (ca Grisette.Internal.SymPrim.TabularFun.=-> cb) (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep a, Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep b, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (a Grisette.Internal.SymPrim.TabularFun.=-> b)) => Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep (a Grisette.Internal.SymPrim.TabularFun.=-> b)


module Grisette.Internal.SymPrim.SymInteger

-- | Symbolic (unbounded, mathematical) integer type.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 1 :: SymInteger
--   (+ 1 a)
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymInteger
SymInteger :: Term Integer -> SymInteger

-- | <a>SymInteger</a> type with identity equality.
type SymIntegerKey = AsKey SymInteger
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.Core.Data.Class.Function.Apply Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Enum.Enum Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Real.Integral Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Data.String.IsString Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep GHC.Num.Integer.Integer Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Num.Num Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Classes.Ord Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Real.Real Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.SymInteger.SymInteger
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.Core.Data.Class.Solvable.Solvable GHC.Num.Integer.Integer Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep GHC.Num.Integer.Integer


module Grisette.Internal.SymPrim.SymGeneralFun

-- | Symbolic general function type.
--   
--   <pre>
--   &gt;&gt;&gt; f' = "f" :: SymInteger -~&gt; SymInteger
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   (apply f 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f' = con ("a" --&gt; "a" + 1) :: SymInteger -~&gt; SymInteger
--   
--   &gt;&gt;&gt; f'
--   \(arg@0 :: Integer) -&gt; (+ 1 arg@0)
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   2
--   
--   &gt;&gt;&gt; f 2
--   3
--   
--   &gt;&gt;&gt; f 3
--   4
--   
--   &gt;&gt;&gt; f "b"
--   (+ 1 b)
--   </pre>
data sa -~> sb
[SymGeneralFun] :: forall ca sa cb sb. (LinkedRep ca sa, LinkedRep cb sb, SupportedPrim (ca --> cb), SupportedNonFuncPrim ca) => Term (ca --> cb) -> sa -~> sb
infixr 0 -~>

-- | Construction of general symbolic functions.
--   
--   <pre>
--   &gt;&gt;&gt; f = "a" --&gt; "a" + 1 :: Integer --&gt; Integer
--   
--   &gt;&gt;&gt; f
--   \(arg@0 :: Integer) -&gt; (+ 1 arg@0)
--   </pre>
--   
--   This general symbolic function needs to be applied to symbolic values:
--   
--   <pre>
--   &gt;&gt;&gt; f # ("a" :: SymInteger)
--   (+ 1 a)
--   
--   &gt;&gt;&gt; f # (2 :: SymInteger)
--   3
--   </pre>
(-->) :: (SupportedNonFuncPrim ca, SupportedPrim cb, LinkedRep cb sb) => TypedConstantSymbol ca -> sb -> ca --> cb
infixr 0 -->
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Grisette.Internal.Core.Data.Class.Function.Apply st => Grisette.Internal.Core.Data.Class.Function.Apply (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> st)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Data.Binary.Class.Binary (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep a, Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep b) => Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep (a Grisette.Internal.SymPrim.SymGeneralFun.-~> b)
instance GHC.Classes.Eq (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance Grisette.Internal.Core.Data.Class.Function.Function (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb) sa sb
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb) => GHC.Internal.Data.String.IsString (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Language.Haskell.TH.Syntax.Lift (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim cb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep (ca Grisette.Internal.SymPrim.GeneralFun.--> cb) (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Control.DeepSeq.NFData (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance GHC.Classes.Ord Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Data.Bytes.Serial.Serial (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca) => Data.Serialize.Serialize (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance GHC.Internal.Show.Show (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SymGeneralFun.ARG
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb)) => Grisette.Internal.Core.Data.Class.Solvable.Solvable (ca Grisette.Internal.SymPrim.GeneralFun.--> cb) (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep ca, Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep cb, Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb)) => Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep (ca Grisette.Internal.SymPrim.GeneralFun.--> cb)


module Grisette.Internal.SymPrim.SymBool

-- | Symbolic Boolean type.
--   
--   <pre>
--   &gt;&gt;&gt; "a" :: SymBool
--   a
--   
--   &gt;&gt;&gt; "a" .&amp;&amp; "b" :: SymBool
--   (&amp;&amp; a b)
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymBool
SymBool :: Term Bool -> SymBool

-- | <a>SymBool</a> type with identity equality.
type SymBoolKey = AsKey SymBool
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.Core.Data.Class.Function.Apply Grisette.Internal.SymPrim.SymBool.SymBool
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep Grisette.Internal.SymPrim.SymBool.SymBool
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SymBool.SymBool
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SymBool.SymBool
instance GHC.Internal.Data.String.IsString Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable Grisette.Internal.SymPrim.SymBool.SymBool
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep GHC.Types.Bool Grisette.Internal.SymPrim.SymBool.SymBool
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SymBool.SymBool
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.SymBool.SymBool
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.SymBool.SymBool
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.Core.Data.Class.Solvable.Solvable GHC.Types.Bool Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep GHC.Types.Bool


module Grisette.Internal.SymPrim.SymBV

-- | Symbolic unsigned bit vector type. Indexed with the bit width.
--   Signedness affects the semantics of the operations, including
--   comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 5 :: SymWordN 5
--   (+ 0b00101 a)
--   
--   &gt;&gt;&gt; sizedBVConcat (con 0b101 :: SymWordN 3) (con 0b110 :: SymWordN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (con 0b101 :: SymWordN 3)
--   0b000101
--   
--   &gt;&gt;&gt; (8 :: SymWordN 4) .&lt; (7 :: SymWordN 4)
--   false
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymWordN (n :: Nat)
SymWordN :: Term (WordN n) -> SymWordN (n :: Nat)

-- | Symbolic 8-bit unsigned bit-vector.
type SymWordN8 = SymWordN 8

-- | Symbolic 16-bit unsigned bit-vector.
type SymWordN16 = SymWordN 16

-- | Symbolic 32-bit unsigned bit-vector.
type SymWordN32 = SymWordN 32

-- | Symbolic 64-bit unsigned bit-vector.
type SymWordN64 = SymWordN 64

-- | <a>SymWordN</a> type with identity equality.
type SymWordNKey (n :: Nat) = AsKey SymWordN n

-- | <a>SymWordN</a> 8@ type with identity equality.
type SymWordN8Key = SymWordNKey 8

-- | <a>SymWordN</a> 16@ type with identity equality.
type SymWordN16Key = SymWordNKey 16

-- | <a>SymWordN</a> 32@ type with identity equality.
type SymWordN32Key = SymWordNKey 32

-- | <a>SymWordN</a> 64@ type with identity equality.
type SymWordN64Key = SymWordNKey 64

-- | Symbolic signed bit vector type. Indexed with the bit width.
--   Signedness affects the semantics of the operations, including
--   comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 5 :: SymIntN 5
--   (+ 0b00101 a)
--   
--   &gt;&gt;&gt; sizedBVConcat (con 0b101 :: SymIntN 3) (con 0b110 :: SymIntN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (con 0b101 :: SymIntN 3)
--   0b111101
--   
--   &gt;&gt;&gt; (8 :: SymIntN 4) .&lt; (7 :: SymIntN 4)
--   true
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymIntN (n :: Nat)
SymIntN :: Term (IntN n) -> SymIntN (n :: Nat)

-- | Symbolic 8-bit signed bit-vector.
type SymIntN8 = SymIntN 8

-- | Symbolic 16-bit signed bit-vector.
type SymIntN16 = SymIntN 16

-- | Symbolic 32-bit signed bit-vector.
type SymIntN32 = SymIntN 32

-- | Symbolic 64-bit signed bit-vector.
type SymIntN64 = SymIntN 64

-- | <a>SymIntN</a> type with identity equality.
type SymIntNKey (n :: Nat) = AsKey SymIntN n

-- | <tt><a>SymIntN</a> 8</tt> type with identity equality.
type SymIntN8Key = SymIntNKey 8

-- | <tt><a>SymIntN</a> 16</tt> type with identity equality.
type SymIntN16Key = SymIntNKey 16

-- | <tt><a>SymIntN</a> 32</tt> type with identity equality.
type SymIntN32Key = SymIntNKey 32

-- | <tt><a>SymIntN</a> 64</tt> type with identity equality.
type SymIntN64Key = SymIntNKey 64
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast Grisette.Internal.SymPrim.SymBool.SymBool (Grisette.Internal.SymPrim.SymBV.SymIntN 1)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast Grisette.Internal.SymPrim.SymBool.SymBool (Grisette.Internal.SymPrim.SymBV.SymWordN 1)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.SymBV.SymIntN 1) Grisette.Internal.SymPrim.SymBool.SymBool
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.SymBV.SymWordN 1) Grisette.Internal.SymPrim.SymBool.SymBool
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.Bits (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.Bits (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Bounded (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Enum (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Enum (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Eq (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Eq (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.FiniteBits (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.FiniteBits (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance GHC.Internal.Generics.Generic (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance GHC.Internal.Generics.Generic (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Integral (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Integral (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Data.String.IsString (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Data.String.IsString (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Ord (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Ord (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Real (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Real (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Serialize.Serialize (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Serialize.Serialize (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SignConversion.SignConversion (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.BitVector.SizedBV Grisette.Internal.SymPrim.SymBV.SymIntN
instance Grisette.Internal.Core.Data.Class.BitVector.SizedBV Grisette.Internal.SymPrim.SymBV.SymWordN
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.Solvable.Solvable (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.Solvable.Solvable (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (Grisette.Internal.SymPrim.SymBV.SymWordN n)


module Grisette.Internal.SymPrim.SymAlgReal

-- | Symbolic representation of algebraic real numbers.
newtype SymAlgReal
SymAlgReal :: Term AlgReal -> SymAlgReal

-- | <a>SymAlgReal</a> type with identity equality.
type SymAlgRealKey = AsKey SymAlgReal
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.Function.Apply Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Float.Floating Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Real.Fractional Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Data.String.IsString Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep Grisette.Internal.SymPrim.AlgReal.AlgReal Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Num.Num Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Classes.Ord Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Real.Real Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.Solvable.Solvable Grisette.Internal.SymPrim.AlgReal.AlgReal Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep Grisette.Internal.SymPrim.AlgReal.AlgReal


module Grisette.Internal.Core.Data.Class.SymIEEEFP

-- | A class for symbolic traits of IEEE floating-point numbers.
class SymIEEEFPTraits a

-- | Check if a symbolic floating-point number is not-a-number.
symFpIsNaN :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is positive. +0, +inf are
--   considered positive. nan, -0, -inf are not positive.
symFpIsPositive :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is negative. -0, -inf are
--   considered negative. nan, +0, +inf are not negative.
symFpIsNegative :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is positive infinite.
symFpIsPositiveInfinite :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is negative infinite.
symFpIsNegativeInfinite :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is infinite.
symFpIsInfinite :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is positive zero.
symFpIsPositiveZero :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is negative zero.
symFpIsNegativeZero :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is zero.
symFpIsZero :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is normal, i.e., not 0, not
--   inf, not nan, and not denormalized.
symFpIsNormal :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is subnormal, i.e.,
--   denormalized. 0, inf, or nan are not subnormal.
symFpIsSubnormal :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is a point, i.e., not inf,
--   not nan.
symFpIsPoint :: SymIEEEFPTraits a => a -> SymBool
instance Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits a => Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance GHC.Internal.Float.RealFloat f => Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits (Grisette.Internal.Core.Data.Class.SymIEEEFP.ConcreteFloat f)
instance Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits GHC.Types.Double
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits GHC.Types.Float


module Grisette.Internal.SymPrim.SymFP

-- | Symbolic IEEE 754 floating-point number with <tt>eb</tt> exponent bits
--   and <tt>sb</tt> significand bits.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 2.0 :: SymFP 11 53
--   (+ a 2.0)
--   
--   &gt;&gt;&gt; fpAdd rne "a" 2.0 :: SymFP 11 53
--   (fp.add rne a 2.0)
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymFP (eb :: Nat) (sb :: Nat)
SymFP :: Term (FP eb sb) -> SymFP (eb :: Nat) (sb :: Nat)

-- | Symbolic IEEE 754 half-precision floating-point number.
type SymFP16 = SymFP 5 11

-- | Symbolic IEEE 754 single-precision floating-point number.
type SymFP32 = SymFP 8 24

-- | Symbolic IEEE 754 double-precision floating-point number.
type SymFP64 = SymFP 11 53

-- | <a>SymFP</a> type with identity equality.
type SymFPKey (eb :: Nat) (sb :: Nat) = AsKey SymFP eb sb

-- | <tt><a>SymFP</a> 16</tt> type with identity equality.
type SymFP16Key = SymFPKey 5 11

-- | <tt><a>SymFP</a> 32</tt> type with identity equality.
type SymFP32Key = SymFPKey 8 24

-- | <tt><a>SymFP</a> 64</tt> type with identity equality.
type SymFP64Key = SymFPKey 11 53

-- | Symbolic floating-point rounding mode.
newtype SymFPRoundingMode
SymFPRoundingMode :: Term FPRoundingMode -> SymFPRoundingMode

-- | <a>SymFPRoundingMode</a> type with identity equality.
type SymFPRoundingModeKey = AsKey SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.Function.Apply (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.Function.Apply Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymIntN r)
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastCanonical (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymWordN r)
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymIntN r)
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymWordN r)
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.SymBV.SymIntN r) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Core.Data.Class.BitCast.BitCast (Grisette.Internal.SymPrim.SymBV.SymWordN r) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.ConRep Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Classes.Eq (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Internal.Float.Floating (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Internal.Real.Fractional (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance GHC.Internal.Generics.Generic (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConstants (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, Grisette.Internal.SymPrim.FP.ValidFP eb' sb') => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.SymPrim.SymFP.SymFP eb' sb') (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPConvertible (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPOp (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingMode Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPRoundingOp (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.IEEEFP.IEEEFPToAlgReal Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Internal.Data.String.IsString (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance GHC.Internal.Data.String.IsString Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep Grisette.Internal.SymPrim.FP.FPRoundingMode Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Control.DeepSeq.NFData (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Data.Serialize.Serialize (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.Core.Data.Class.Solvable.Solvable Grisette.Internal.SymPrim.FP.FPRoundingMode Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.Solvable.Solvable (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.SymIEEEFP.SymIEEEFPTraits (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.SymPrim.Prim.Internal.Term.SymRep Grisette.Internal.SymPrim.FP.FPRoundingMode


module Grisette.Internal.Unified.Class.UnifiedSolvable

-- | A class that provides the ability to extract/wrap the concrete value
--   from/into a symbolic value.
class UnifiedSolvable (mode :: EvalModeTag) a con | a -> mode con, con mode -> a
withBaseSolvable :: UnifiedSolvable mode a con => (If (IsConMode mode) (a ~ con) (Solvable con a) => r) -> r

-- | Wrap a concrete value in a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; con True :: Bool
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; con True :: SymBool
--   true
--   </pre>
con :: forall (mode :: EvalModeTag) a con. (DecideEvalMode mode, UnifiedSolvable mode a con) => con -> a

-- | A pattern synonym for extracting the concrete value from a symbolic
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; case con True :: SymBool of Con v -&gt; v
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case ssym "a" :: SymBool of Con v -&gt; Just v; _ -&gt; Nothing
--   Nothing
--   </pre>
pattern Con :: forall (mode :: EvalModeTag) a con. (DecideEvalMode mode, UnifiedSolvable mode a con) => con -> a

-- | Extract the concrete value from a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; conView (con True :: SymBool)
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conView (ssym "a" :: SymBool)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conView True
--   Just True
--   </pre>
conView :: forall (mode :: EvalModeTag) a con. (DecideEvalMode mode, UnifiedSolvable mode a con) => a -> Maybe con
instance Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.AlgReal.AlgReal Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.C GHC.Types.Bool GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymBool.SymBool GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSolvable.UnifiedSolvable 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.Unified.Class.UnifiedRep

-- | A class that gives the concrete type of a unified primitive type.
class UnifiedConRep a where {
    type ConType a;
}

-- | A class that gives the symbolic type of a unified primitive type.
class UnifiedSymRep a where {
    type SymType a;
}
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep GHC.Num.Integer.Integer
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedConRep (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep GHC.Types.Bool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep GHC.Num.Integer.Integer
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedRep.UnifiedSymRep (Grisette.Internal.SymPrim.BV.WordN n)


module Grisette.Internal.Core.Data.Class.SymFromIntegral

-- | Conversion from a symbolic integral type.
class SymFromIntegral from to
symFromIntegral :: SymFromIntegral from to => from -> to
instance Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral a b => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral a b => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymIntN n) Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= n, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymBV.SymIntN m)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymIntN n) Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= n, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymBV.SymWordN m)
instance Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral Grisette.Internal.SymPrim.SymInteger.SymInteger Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral Grisette.Internal.SymPrim.SymInteger.SymInteger Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymWordN n) Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= n, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymBV.SymIntN m)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymWordN n) Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= n, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymBV.SymWordN m)
instance Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral a b => Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)


module Grisette.Internal.Unified.Class.UnifiedFromIntegral

-- | A class that provides unified conversion from integral types.
--   
--   We use this type class to help resolve the constraints for
--   <a>SymFromIntegral</a>.
class UnifiedFromIntegral (mode :: EvalModeTag) a b
withBaseFromIntegral :: UnifiedFromIntegral mode a b => (If (IsConMode mode) (Integral a, Num b) (SymFromIntegral a b) => r) -> r

-- | Unified <a>symFromIntegral</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   symFromIntegral @mode a
--   </pre>
symFromIntegral :: forall (mode :: EvalModeTag) a b. (DecideEvalMode mode, UnifiedFromIntegral mode a b) => a -> b
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n') Grisette.Internal.SymPrim.AlgReal.AlgReal
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n') (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n') (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n') GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n') (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n') Grisette.Internal.SymPrim.AlgReal.AlgReal
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n') (Grisette.Internal.SymPrim.FP.FP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n') (Grisette.Internal.SymPrim.BV.IntN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n') GHC.Num.Integer.Integer
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n') (Grisette.Internal.SymPrim.BV.WordN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n') Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n') (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n') (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n') Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n') (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n') Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n') (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n') (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n') => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n') Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n', 1 GHC.Internal.Data.Type.Ord.<= n', GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n') (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (Grisette.Internal.Unified.Util.DecideEvalMode mode, GHC.Internal.Data.Type.Bool.If (Grisette.Internal.Unified.EvalModeTag.IsConMode mode) (GHC.Internal.Real.Integral a, GHC.Internal.Num.Num b) (Grisette.Internal.Core.Data.Class.SymFromIntegral.SymFromIntegral a b)) => Grisette.Internal.Unified.Class.UnifiedFromIntegral.UnifiedFromIntegral mode a b


module Grisette.Internal.Core.Data.Class.LogicalOp

-- | Symbolic logical operators for symbolic booleans.
--   
--   <pre>
--   &gt;&gt;&gt; let t = true :: SymBool
--   
--   &gt;&gt;&gt; let f = false :: SymBool
--   
--   &gt;&gt;&gt; let a = "a" :: SymBool
--   
--   &gt;&gt;&gt; let b = "b" :: SymBool
--   
--   &gt;&gt;&gt; t .|| f
--   true
--   
--   &gt;&gt;&gt; a .|| t
--   true
--   
--   &gt;&gt;&gt; a .|| f
--   a
--   
--   &gt;&gt;&gt; a .|| b
--   (|| a b)
--   
--   &gt;&gt;&gt; t .&amp;&amp; f
--   false
--   
--   &gt;&gt;&gt; a .&amp;&amp; t
--   a
--   
--   &gt;&gt;&gt; a .&amp;&amp; f
--   false
--   
--   &gt;&gt;&gt; a .&amp;&amp; b
--   (&amp;&amp; a b)
--   
--   &gt;&gt;&gt; symNot t
--   false
--   
--   &gt;&gt;&gt; symNot f
--   true
--   
--   &gt;&gt;&gt; symNot a
--   (! a)
--   
--   &gt;&gt;&gt; t `symXor` f
--   true
--   
--   &gt;&gt;&gt; t `symXor` t
--   false
--   
--   &gt;&gt;&gt; a `symXor` t
--   (! a)
--   
--   &gt;&gt;&gt; a `symXor` f
--   a
--   
--   &gt;&gt;&gt; a `symXor` b
--   (|| (&amp;&amp; (! a) b) (&amp;&amp; a (! b)))
--   </pre>
class LogicalOp b

-- | Constant true
true :: LogicalOp b => b

-- | Constant false
false :: LogicalOp b => b

-- | Symbolic disjunction
(.||) :: LogicalOp b => b -> b -> b

-- | Symbolic conjunction
(.&&) :: LogicalOp b => b -> b -> b

-- | Symbolic negation
symNot :: LogicalOp b => b -> b

-- | Symbolic exclusive disjunction
symXor :: LogicalOp b => b -> b -> b

-- | Symbolic implication
symImplies :: LogicalOp b => b -> b -> b
infixr 2 .||
infixr 3 .&&
instance Grisette.Internal.Core.Data.Class.LogicalOp.LogicalOp a => Grisette.Internal.Core.Data.Class.LogicalOp.LogicalOp (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.LogicalOp.LogicalOp GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.LogicalOp.LogicalOp a => Grisette.Internal.Core.Data.Class.LogicalOp.LogicalOp (GHC.Internal.Data.Functor.Identity.Identity a)
instance Grisette.Internal.Core.Data.Class.LogicalOp.LogicalOp Grisette.Internal.SymPrim.SymBool.SymBool


module Grisette.Internal.Core.Data.Class.ITEOp

-- | ITE operator for solvable (see <a>Grisette.Core#g:solvable</a>)s,
--   including symbolic boolean, integer, etc.
--   
--   <pre>
--   &gt;&gt;&gt; let a = "a" :: SymBool
--   
--   &gt;&gt;&gt; let b = "b" :: SymBool
--   
--   &gt;&gt;&gt; let c = "c" :: SymBool
--   
--   &gt;&gt;&gt; symIte a b c
--   (ite a b c)
--   </pre>
class ITEOp v

-- | Symbolic if-then-else.
symIte :: ITEOp v => SymBool -> v -> v -> v
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (a Grisette.Internal.SymPrim.GeneralFun.--> b)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp a => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp v => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (GHC.Internal.Data.Functor.Identity.Identity v)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (GHC.Internal.Data.Proxy.Proxy a)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.ITEOp.ITEOp Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (Grisette.Internal.SymPrim.SymBV.SymWordN n)


module Grisette.Internal.TH.Derivation.Common

-- | Result of <a>checkArgs</a> for a data type.
data CheckArgsResult
CheckArgsResult :: [ConstructorInfo] -> [(Type, Kind)] -> [(Type, Kind)] -> CheckArgsResult
[constructors] :: CheckArgsResult -> [ConstructorInfo]
[keptVars] :: CheckArgsResult -> [(Type, Kind)]
[argVars] :: CheckArgsResult -> [(Type, Kind)]

-- | Check if the number of type parameters is valid for a data type, and
--   return new names for the type variables, split into kept and arg
--   parts.
checkArgs :: String -> Int -> Name -> Bool -> Int -> Q CheckArgsResult

-- | Generate a context for a variable in a GADT.
ctxForVar :: [Type] -> Type -> Kind -> Q (Maybe Pred)

-- | Configuration for constraints for evaluation modes tag.
--   
--   <ul>
--   <li><a>EvalModeConstraints</a> specifies a list of constraints for the
--   tag, for example, we may use <a>EvalModeBase</a> and <a>EvalModeBV</a>
--   to specify that the evaluation mode must support both base (boolean
--   and data types) and bit vectors. This should be used when the data
--   type uses bit vectors.</li>
--   <li><a>EvalModeSpecified</a> specifies a that an evaluation mode tag
--   should be specialized to a specific tag for all the instances.</li>
--   </ul>
data EvalModeConfig
EvalModeConstraints :: [Name] -> EvalModeConfig
EvalModeSpecified :: EvalModeTag -> EvalModeConfig

-- | Configuration for deriving instances for a data type.
data DeriveConfig
DeriveConfig :: [(Int, EvalModeConfig)] -> [Int] -> [(Int, Int)] -> [Int] -> Bool -> Bool -> Bool -> Bool -> DeriveConfig
[evalModeConfig] :: DeriveConfig -> [(Int, EvalModeConfig)]
[bitSizePositions] :: DeriveConfig -> [Int]
[fpBitSizePositions] :: DeriveConfig -> [(Int, Int)]
[unconstrainedPositions] :: DeriveConfig -> [Int]
[needExtraMergeableUnderEvalMode] :: DeriveConfig -> Bool
[needExtraMergeableWithConcretizedEvalMode] :: DeriveConfig -> Bool
[useNoStrategy] :: DeriveConfig -> Bool
[useSerialForCerealAndBinary] :: DeriveConfig -> Bool

-- | Generate extra constraints for evaluation modes.
extraEvalModeConstraint :: Name -> Name -> [(Type, Kind)] -> (Int, EvalModeConfig) -> Q [Pred]

-- | Generate extra constraints for bit vectors.
extraBitSizeConstraint :: Name -> Name -> [(Type, Kind)] -> Int -> Q [Pred]

-- | Generate extra constraints for floating point exponents and
--   significands.
extraFpBitSizeConstraint :: Name -> Name -> [(Type, Kind)] -> (Int, Int) -> Q [Pred]

-- | Generate extra constraints for <a>Mergeable</a> instances.
extraExtraMergeableConstraint :: DeriveConfig -> [ConstructorInfo] -> [(Type, Kind)] -> Q [Pred]

-- | Generate extra constraints for a data type.
extraConstraint :: DeriveConfig -> Name -> Name -> [(Type, Kind)] -> [(Type, Kind)] -> [ConstructorInfo] -> Q [Pred]

-- | Specialize the evaluation mode tags for the <a>CheckArgsResult</a>.
specializeResult :: [(Int, EvalModeTag)] -> CheckArgsResult -> Q CheckArgsResult

-- | Get all the evaluation modes to specialize in the <a>DeriveConfig</a>.
evalModeSpecializeList :: DeriveConfig -> [(Int, EvalModeTag)]

-- | Check if a variable is used in the fields of a constructor.
isVarUsedInFields :: CheckArgsResult -> Name -> Bool

-- | Freshen the type variables in the <a>CheckArgsResult</a>.
freshenCheckArgsResult :: Bool -> CheckArgsResult -> Q CheckArgsResult
instance GHC.Internal.Base.Monoid Grisette.Internal.TH.Derivation.Common.DeriveConfig
instance GHC.Internal.Base.Semigroup Grisette.Internal.TH.Derivation.Common.DeriveConfig


module Grisette.Internal.TH.Derivation.UnaryOpCommon

-- | Configuration for a unary operation type class generation on a GADT.
data UnaryOpClassConfig
UnaryOpClassConfig :: [UnaryOpConfig] -> [Name] -> Maybe [Name] -> (DeriveConfig -> Q [(Type, Kind)]) -> (DeriveConfig -> [(Type, Kind)] -> [(Type, Kind)] -> Name -> Q Type) -> Bool -> UnaryOpClassConfig
[unaryOpConfigs] :: UnaryOpClassConfig -> [UnaryOpConfig]
[unaryOpInstanceNames] :: UnaryOpClassConfig -> [Name]
[unaryOpContextNames] :: UnaryOpClassConfig -> Maybe [Name]
[unaryOpExtraVars] :: UnaryOpClassConfig -> DeriveConfig -> Q [(Type, Kind)]
[unaryOpInstanceTypeFromConfig] :: UnaryOpClassConfig -> DeriveConfig -> [(Type, Kind)] -> [(Type, Kind)] -> Name -> Q Type
[unaryOpAllowExistential] :: UnaryOpClassConfig -> Bool

-- | Configuration for the derivation rules for a unary operation that can
--   be derived by transforming each field and then combining the results.
data UnaryOpFieldConfig
UnaryOpFieldConfig :: [String] -> (Int -> [String]) -> (ConstructorVariant -> Name -> [Exp] -> Int -> Exp -> Exp -> Q (Exp, [Bool])) -> (Int -> Int -> ConstructorVariant -> Name -> [Exp] -> [Exp] -> Q (Exp, [Bool])) -> FieldFunExp -> UnaryOpFieldConfig
[extraPatNames] :: UnaryOpFieldConfig -> [String]
[extraLiftedPatNames] :: UnaryOpFieldConfig -> Int -> [String]
[fieldResFun] :: UnaryOpFieldConfig -> ConstructorVariant -> Name -> [Exp] -> Int -> Exp -> Exp -> Q (Exp, [Bool])
[fieldCombineFun] :: UnaryOpFieldConfig -> Int -> Int -> ConstructorVariant -> Name -> [Exp] -> [Exp] -> Q (Exp, [Bool])
[fieldFunExp] :: UnaryOpFieldConfig -> FieldFunExp

-- | Configuration for a unary function field expression generation on a
--   GADT.
data UnaryOpConfig
[UnaryOpConfig] :: forall config. UnaryOpFunConfig config => config -> [Name] -> UnaryOpConfig

-- | Configuration for the derivation rules for a unary operation.
class UnaryOpFunConfig config
genUnaryOpFun :: UnaryOpFunConfig config => DeriveConfig -> config -> [Name] -> Int -> [(Type, Kind)] -> [(Type, Kind)] -> [(Type, Kind)] -> (Name -> Bool) -> [ConstructorInfo] -> Q Dec

-- | Type of field function expression generator.
type FieldFunExp = Map Name Name -> Map Name [Name] -> Type -> Q Exp

-- | Default field result function.
defaultFieldResFun :: ConstructorVariant -> Name -> [Exp] -> Int -> Exp -> Exp -> Q (Exp, [Bool])

-- | Default field function expression generator.
defaultFieldFunExp :: [Name] -> FieldFunExp

-- | Generate a unary operation type class instance for a data type.
genUnaryOpClass :: DeriveConfig -> UnaryOpClassConfig -> Int -> Name -> Q [Dec]

-- | Default unary operation instance type generator.
defaultUnaryOpInstanceTypeFromConfig :: DeriveConfig -> [(Type, Kind)] -> [(Type, Kind)] -> Name -> Q Type
instance Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFunConfig Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFieldConfig


module Grisette.Internal.TH.Derivation.UnifiedOpCommon

-- | Configuration for the derivation rules for a unified operation.
newtype UnaryOpUnifiedConfig
UnaryOpUnifiedConfig :: (Type -> (Type, Kind) -> Q (Maybe Exp)) -> UnaryOpUnifiedConfig
[unifiedFun] :: UnaryOpUnifiedConfig -> Type -> (Type, Kind) -> Q (Maybe Exp)

-- | Default implementation for the derivation rules for a unified
--   operation.
defaultUnaryOpUnifiedFun :: [Name] -> Type -> (Type, Kind) -> Q (Maybe Exp)
instance Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFunConfig Grisette.Internal.TH.Derivation.UnifiedOpCommon.UnaryOpUnifiedConfig


module Grisette.Internal.TH.Derivation.ShowPPrintCommon

-- | Common <a>FieldFunExp</a> for <a>Show</a> and <a>PPrint</a> on a GADT.
showPrintFieldFunExp :: [Name] -> [Name] -> FieldFunExp


module Grisette.Internal.TH.Derivation.SerializeCommon

-- | Configuration for serialization function, generate the function from
--   scratch.
serializeConfig :: [Name] -> [Name] -> [Name] -> UnaryOpClassConfig

-- | Configuration for serialization function, reuse the <a>Serial</a>
--   instance.
serializeWithSerialConfig :: [Name] -> [Name] -> [Name] -> UnaryOpClassConfig
instance Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFunConfig Grisette.Internal.TH.Derivation.SerializeCommon.UnaryOpDeserializeConfig
instance Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFunConfig Grisette.Internal.TH.Derivation.SerializeCommon.UnaryOpDeserializeWithSerialConfig
instance Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFunConfig Grisette.Internal.TH.Derivation.SerializeCommon.UnaryOpSerializeWithSerialConfig


module Grisette.Internal.TH.Derivation.DeriveUnifiedSymEq

-- | Derive <a>UnifiedSymEq</a> instance for a data type.
deriveUnifiedSymEq :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>UnifiedSymEq1</a> instance for a data type.
deriveUnifiedSymEq1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>UnifiedSymEq2</a> instance for a data type.
deriveUnifiedSymEq2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveSubstSym

-- | Derive <a>SubstSym</a> instance for a data type.
deriveSubstSym :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SubstSym1</a> instance for a data type.
deriveSubstSym1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SubstSym2</a> instance for a data type.
deriveSubstSym2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveShow

-- | Derive <a>Show</a> instance for a data type.
deriveShow :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Show1</a> instance for a data type.
deriveShow1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Show2</a> instance for a data type.
deriveShow2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveSerial

-- | Derive <a>Serial</a> instance for a data type.
deriveSerial :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Serial1</a> instance for a data type.
deriveSerial1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Serial2</a> instance for a data type.
deriveSerial2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DerivePPrint

-- | Derive <a>PPrint</a> instance for a data type.
derivePPrint :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>PPrint1</a> instance for a data type.
derivePPrint1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>PPrint2</a> instance for a data type.
derivePPrint2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveNFData

-- | Derive <a>NFData</a> instance for a data type.
deriveNFData :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>NFData1</a> instance for a data type.
deriveNFData1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>NFData2</a> instance for a data type.
deriveNFData2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveMergeable

-- | Derive <a>Mergeable</a> instance for GADT.
deriveMergeable :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Mergeable1</a> instance for GADT.
deriveMergeable1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Mergeable2</a> instance for GADT.
deriveMergeable2 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Mergeable3</a> instance for GADT.
deriveMergeable3 :: DeriveConfig -> Name -> Q [Dec]

-- | Generate <a>Mergeable</a> instance and merging information for a data
--   type.
genMergeableAndGetMergingInfoResult :: DeriveConfig -> Name -> Int -> Q (MergingInfoResult, [Dec])

-- | Generate <a>Mergeable</a> instance for a data type.
genMergeable :: DeriveConfig -> Name -> Int -> Q [Dec]

-- | Generate <a>Mergeable</a> instance for a data type, using a given
--   merging info result.
genMergeable' :: DeriveConfig -> MergingInfoResult -> Name -> Int -> Q (Name, [Dec])

-- | Generate <a>Mergeable</a> instance for a data type without existential
--   variables.
genMergeableNoExistential :: DeriveConfig -> Name -> Int -> Q [Dec]

-- | Generate <a>Mergeable</a> instance for a data type, using
--   <a>NoStrategy</a>.
genMergeableNoStrategy :: DeriveConfig -> Name -> Int -> Q [Dec]

-- | Generate multiple <a>Mergeable</a> instances for a data type.
genMergeableList :: DeriveConfig -> Name -> [Int] -> Q [Dec]
instance Grisette.Internal.TH.Derivation.UnaryOpCommon.UnaryOpFunConfig Grisette.Internal.TH.Derivation.DeriveMergeable.MergeableNoExistentialConfig


module Grisette.Internal.TH.Derivation.DeriveHashable

-- | Derive <a>Hashable</a> instance for a data type.
deriveHashable :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Hashable1</a> instance for a data type.
deriveHashable1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Hashable2</a> instance for a data type.
deriveHashable2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveExtractSym

-- | Derive <a>ExtractSym</a> instance for a data type.
deriveExtractSym :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>ExtractSym1</a> instance for a data type.
deriveExtractSym1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>ExtractSym2</a> instance for a data type.
deriveExtractSym2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveEvalSym

-- | Derive <a>EvalSym</a> instance for a data type.
deriveEvalSym :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>EvalSym1</a> instance for a data type.
deriveEvalSym1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>EvalSym2</a> instance for a data type.
deriveEvalSym2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveCereal

-- | Derive <a>Serialize</a> instance for a data type.
deriveCereal :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveBinary

-- | Derive <a>Binary</a> instance for a data type.
deriveBinary :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveAllSyms

-- | Derive <a>AllSyms</a> instance for a data type.
deriveAllSyms :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>AllSyms1</a> instance for a data type.
deriveAllSyms1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>AllSyms2</a> instance for a data type.
deriveAllSyms2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.BinaryOpCommon

-- | Configuration for a binary operation type class generation on a GADT.
data BinaryOpClassConfig
BinaryOpClassConfig :: [BinaryOpFieldConfig] -> [Name] -> Bool -> Bool -> BinaryOpClassConfig
[binaryOpFieldConfigs] :: BinaryOpClassConfig -> [BinaryOpFieldConfig]
[binaryOpInstanceNames] :: BinaryOpClassConfig -> [Name]
[binaryOpAllowSumType] :: BinaryOpClassConfig -> Bool
[binaryOpAllowExistential] :: BinaryOpClassConfig -> Bool

-- | Configuration for a binary operation field generation on a GADT.
data BinaryOpFieldConfig
BinaryOpFieldConfig :: [String] -> ([Exp] -> (Exp, Exp) -> Exp -> Q (Exp, [Bool])) -> (Name -> [Exp] -> Q (Exp, [Bool])) -> (Exp -> Q Exp) -> Q Exp -> Q Exp -> FieldFunExp -> [Name] -> BinaryOpFieldConfig
[extraPatNames] :: BinaryOpFieldConfig -> [String]
[fieldResFun] :: BinaryOpFieldConfig -> [Exp] -> (Exp, Exp) -> Exp -> Q (Exp, [Bool])
[fieldCombineFun] :: BinaryOpFieldConfig -> Name -> [Exp] -> Q (Exp, [Bool])
[fieldDifferentExistentialFun] :: BinaryOpFieldConfig -> Exp -> Q Exp
[fieldLMatchResult] :: BinaryOpFieldConfig -> Q Exp
[fieldRMatchResult] :: BinaryOpFieldConfig -> Q Exp
[fieldFunExp] :: BinaryOpFieldConfig -> FieldFunExp
[fieldFunNames] :: BinaryOpFieldConfig -> [Name]

-- | Type of field function expression generator.
type FieldFunExp = Map Name Name -> Type -> Q Exp

-- | Default field function expression generator.
defaultFieldFunExp :: [Name] -> FieldFunExp

-- | Generate a clause for a binary operation on a GADT.
genBinaryOpClause :: BinaryOpFieldConfig -> [(Type, Kind)] -> [(Type, Kind)] -> Bool -> ConstructorInfo -> ConstructorInfo -> Q [Clause]

-- | Generate a type class instance for a binary operation on a GADT.
genBinaryOpClass :: DeriveConfig -> BinaryOpClassConfig -> Int -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveSymEq

-- | Derive <a>SymEq</a> instance for a data type.
deriveSymEq :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SymEq1</a> instance for a data type.
deriveSymEq1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SymEq2</a> instance for a data type.
deriveSymEq2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveOrd

-- | Derive <a>Ord</a> instance for a data type.
deriveOrd :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Ord1</a> instance for a data type.
deriveOrd1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Ord2</a> instance for a data type.
deriveOrd2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveEq

-- | Derive <a>Eq</a> instance for a data type.
deriveEq :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Eq1</a> instance for a data type.
deriveEq1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>Eq2</a> instance for a data type.
deriveEq2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveSimpleMergeable

-- | Derive <a>SimpleMergeable</a> instance for a data type.
deriveSimpleMergeable :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SimpleMergeable1</a> instance for a data type.
deriveSimpleMergeable1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SimpleMergeable2</a> instance for a data type.
deriveSimpleMergeable2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveUnifiedSimpleMergeable

-- | Derive <a>UnifiedSimpleMergeable</a> instance for a data type.
deriveUnifiedSimpleMergeable :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>UnifiedSimpleMergeable1</a> instance for a data type.
deriveUnifiedSimpleMergeable1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>UnifiedSimpleMergeable2</a> instance for a data type.
deriveUnifiedSimpleMergeable2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.Core.Data.Class.UnionView

-- | Containers that can be projected back into single value or if-guarded
--   values. <a>Identity</a> is an instance of this class as we can always
--   project to single value.
class (Applicative u, TryMerge u) => UnionView (u :: Type -> Type)

-- | Pattern match to extract single values.
--   
--   <pre>
--   &gt;&gt;&gt; singleView (return 1 :: Union Integer)
--   Just 1
--   
--   &gt;&gt;&gt; singleView (mrgIfPropagatedStrategy "a" (return 1) (return 2) :: Union Integer)
--   Nothing
--   </pre>
singleView :: UnionView u => u a -> Maybe a

-- | Pattern match to extract if values.
--   
--   <pre>
--   &gt;&gt;&gt; ifView (return 1 :: Union Integer)
--   Nothing
--   
--   &gt;&gt;&gt; ifView (mrgIfPropagatedStrategy "a" (return 1) (return 2) :: Union Integer)
--   Just (IfViewResult a &lt;1&gt; &lt;2&gt;)
--   
--   &gt;&gt;&gt; ifView (mrgIf "a" (return 1) (return 2) :: Union Integer)
--   Just (IfViewResult a {1} {2})
--   </pre>
ifView :: UnionView u => u a -> Maybe (IfViewResult u a)

-- | Convert the union to a guarded list.
--   
--   <pre>
--   &gt;&gt;&gt; toGuardedList (mrgIf "a" (return 1) (mrgIf "b" (return 2) (return 3)) :: Union Integer)
--   [(a,1),((&amp;&amp; b (! a)),2),((! (|| b a)),3)]
--   </pre>
toGuardedList :: UnionView u => u a -> [(SymBool, a)]

-- | Return all possible values in the union. Drop the path conditions.
--   
--   <pre>
--   &gt;&gt;&gt; overestimateUnionValues (return 1 :: Union Integer)
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; overestimateUnionValues (mrgIf "a" (return 1) (return 2) :: Union Integer)
--   [1,2]
--   </pre>
overestimateUnionValues :: (UnionView u, Mergeable a) => u a -> [a]

-- | The result of <a>ifView</a>.
data IfViewResult (u :: Type -> Type) a
[IfViewResult] :: forall (u :: Type -> Type) a. SymBranching u => SymBool -> u a -> u a -> IfViewResult u a

-- | Pattern match to extract single values with <a>singleView</a>.
--   
--   <pre>
--   &gt;&gt;&gt; case (return 1 :: Union Integer) of Single v -&gt; v
--   1
--   </pre>
pattern Single :: (UnionView u, Mergeable a) => a -> u a

-- | Pattern match to extract guard values with <a>ifView</a>
--   
--   <pre>
--   &gt;&gt;&gt; case (mrgIfPropagatedStrategy "a" (return 1) (return 2) :: Union Integer) of If c t f -&gt; (c,t,f)
--   (a,&lt;1&gt;,&lt;2&gt;)
--   </pre>
pattern If :: (UnionView u, Mergeable a) => SymBranching u => SymBool -> u a -> u a -> u a

-- | Merge the simply mergeable values in a union, and extract the merged
--   value.
--   
--   In the following example, <a>mrgIfPropagatedStrategy</a> will not
--   merge the results, and <a>simpleMerge</a> will merge it and extract
--   the single merged value.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfPropagatedStrategy (ssym "a") (return $ ssym "b") (return $ ssym "c") :: Union SymBool
--   &lt;If a b c&gt;
--   
--   &gt;&gt;&gt; simpleMerge $ (mrgIfPropagatedStrategy (ssym "a") (return $ ssym "b") (return $ ssym "c") :: Union SymBool)
--   (ite a b c)
--   </pre>
simpleMerge :: forall u a. (SimpleMergeable a, UnionView u) => u a -> a

-- | Merge the mergeable values in a union, using <a>symIte</a>, and
--   extract the merged value.
--   
--   The reason why we provide this class is that for some types, we only
--   have <a>ITEOp</a> (which may throw an error), and we don't have a
--   <a>SimpleMergeable</a> instance. In this case, we can use
--   <a>symIteMerge</a> to merge the values.
symIteMerge :: (ITEOp a, Mergeable a, UnionView u) => u a -> a

-- | Helper for applying functions on <a>UnionView</a> and
--   <a>SimpleMergeable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Integer -&gt; Union Integer = \x -&gt; mrgIf (ssym "a") (mrgSingle $ x + 1) (mrgSingle $ x + 2)
--   
--   &gt;&gt;&gt; f .# (mrgIf (ssym "b" :: SymBool) (mrgSingle 0) (mrgSingle 2) :: Union Integer)
--   {If (&amp;&amp; b a) 1 (If b 2 (If a 3 4))}
--   </pre>
(.#) :: (Function f a r, SimpleMergeable r, UnionView u) => f -> u a -> r
infixl 9 .#

-- | Lift a function to work on union values.
--   
--   <pre>
--   &gt;&gt;&gt; sumU = onUnion sum :: Union [SymInteger] -&gt; SymInteger
--   
--   &gt;&gt;&gt; sumU (mrgIfPropagatedStrategy "cond" (return ["a"]) (return ["b","c"]) :: Union [SymInteger])
--   (ite cond a (+ b c))
--   </pre>
onUnion :: forall u a r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a) => (a -> r) -> u a -> r

-- | Lift a function to work on union values.
onUnion2 :: forall u a b r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a, Mergeable b) => (a -> b -> r) -> u a -> u b -> r

-- | Lift a function to work on union values.
onUnion3 :: forall u a b c r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a, Mergeable b, Mergeable c) => (a -> b -> c -> r) -> u a -> u b -> u c -> r

-- | Lift a function to work on union values.
onUnion4 :: forall u a b c d r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a, Mergeable b, Mergeable c, Mergeable d) => (a -> b -> c -> d -> r) -> u a -> u b -> u c -> u d -> r

-- | Convert a plain union to concrete values.
--   
--   <pre>
--   &gt;&gt;&gt; unionToCon (return 1 :: Union SymInteger) :: Maybe Integer
--   Just 1
--   
--   &gt;&gt;&gt; unionToCon (mrgIf "a" (return 1) (return 2) :: Union SymInteger) :: Maybe Integer
--   Nothing
--   
--   &gt;&gt;&gt; unionToCon (return "a" :: Union SymInteger) :: Maybe Integer
--   Nothing
--   </pre>
unionToCon :: (ToCon a b, UnionView u) => u a -> Maybe b

-- | Lift the <a>UnionView</a> value to any Applicative
--   <a>SymBranching</a>.
liftUnion :: (Mergeable a, UnionView u, Applicative m, SymBranching m) => u a -> m a

-- | Alias for <a>liftUnion</a>, but for monads.
liftToMonadUnion :: (Mergeable a, UnionView u, Monad m, SymBranching m) => u a -> m a
instance GHC.Internal.Show.Show (u a) => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.UnionView.IfViewResult u a)
instance Grisette.Internal.Core.Data.Class.UnionView.UnionView u => Grisette.Internal.Core.Data.Class.UnionView.UnionView (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 u)
instance Grisette.Internal.Core.Data.Class.UnionView.UnionView GHC.Internal.Data.Functor.Identity.Identity

module Grisette.Internal.Unified.Class.UnionViewMode

-- | This class is used to determine the type of the Boolean used in the
--   <a>UnionView</a> class.
--   
--   For <a>Identity</a>, we use <a>Bool</a> as the Boolean type, and this
--   ensures that the <a>ifView</a> function will return <a>Nothing</a>.
--   
--   For <a>Union</a>, we use <tt>SymBool</tt> as the Boolean type, and
--   <a>ifView</a> function can return <a>Nothing</a> or <a>Just</a>.
class UnionViewMode (mode :: EvalModeTag) (u :: Type -> Type) | u -> mode
instance Grisette.Internal.Unified.Class.UnionViewMode.UnionViewMode 'Grisette.Internal.Unified.EvalModeTag.C GHC.Internal.Data.Functor.Identity.Identity
instance Grisette.Internal.Unified.Class.UnionViewMode.UnionViewMode 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union


module Grisette.Internal.TH.Derivation.ConvertOpCommon

-- | Generate a convert operation class instance.
genConvertOpClass :: DeriveConfig -> ConvertOpClassConfig -> Int -> Name -> Q [Dec]

-- | Configuration for a convert operation class.
data ConvertOpClassConfig
ConvertOpClassConfig :: EvalModeTag -> [Name] -> [Name] -> (Exp -> Exp -> Q Exp) -> (Name -> [Exp] -> Q Exp) -> FieldFunExp -> ConvertOpClassConfig
[convertOpTarget] :: ConvertOpClassConfig -> EvalModeTag
[convertOpInstanceNames] :: ConvertOpClassConfig -> [Name]
[convertOpFunNames] :: ConvertOpClassConfig -> [Name]
[convertFieldResFun] :: ConvertOpClassConfig -> Exp -> Exp -> Q Exp
[convertFieldCombineFun] :: ConvertOpClassConfig -> Name -> [Exp] -> Q Exp
[convertFieldFunExp] :: ConvertOpClassConfig -> FieldFunExp

-- | Default field transformation function.
defaultFieldFunExp :: [Name] -> FieldFunExp


module Grisette.Internal.TH.Derivation.DeriveToSym

-- | Derive <a>ToSym</a> instance for a data type.
deriveToSym :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>ToSym1</a> instance for a data type.
deriveToSym1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>ToSym2</a> instance for a data type.
deriveToSym2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveToCon

-- | Derive <a>ToCon</a> instance for a data type.
deriveToCon :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>ToCon1</a> instance for a data type.
deriveToCon1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>ToCon2</a> instance for a data type.
deriveToCon2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveSymOrd

-- | Derive <a>SymOrd</a> instance for a data type.
deriveSymOrd :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SymOrd1</a> instance for a data type.
deriveSymOrd1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>SymOrd2</a> instance for a data type.
deriveSymOrd2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.DeriveUnifiedSymOrd

-- | Derive <a>UnifiedSymOrd</a> instance for a data type.
deriveUnifiedSymOrd :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>UnifiedSymOrd1</a> instance for a data type.
deriveUnifiedSymOrd1 :: DeriveConfig -> Name -> Q [Dec]

-- | Derive <a>UnifiedSymOrd2</a> instance for a data type.
deriveUnifiedSymOrd2 :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.TH.Derivation.Derive

-- | Derive the specified classes for a data type with the given name.
--   
--   See <a>deriveWith</a> for more details.
derive :: [Name] -> [Name] -> Q [Dec]

-- | Derive the specified classes for a data type with the given name.
--   
--   Support the following classes for both vanilla data types and GADTs.
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>Mergeable1</a></li>
--   <li><a>Mergeable2</a></li>
--   <li><a>Mergeable3</a></li>
--   <li><a>EvalSym</a></li>
--   <li><a>EvalSym1</a></li>
--   <li><a>EvalSym2</a></li>
--   <li><a>ExtractSym</a></li>
--   <li><a>ExtractSym1</a></li>
--   <li><a>ExtractSym2</a></li>
--   <li><a>SubstSym</a></li>
--   <li><a>SubstSym1</a></li>
--   <li><a>SubstSym2</a></li>
--   <li><a>NFData</a></li>
--   <li><a>NFData1</a></li>
--   <li><a>NFData2</a></li>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable1</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable2</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Show</a></li>
--   <li><a>Show1</a></li>
--   <li><a>Show2</a></li>
--   <li><a>PPrint</a></li>
--   <li><a>PPrint1</a></li>
--   <li><a>PPrint2</a></li>
--   <li><a>AllSyms</a></li>
--   <li><a>AllSyms1</a></li>
--   <li><a>AllSyms2</a></li>
--   <li><a>Eq</a></li>
--   <li><a>Eq1</a></li>
--   <li><a>Eq2</a></li>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord1</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord2</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>SymOrd</a></li>
--   <li><a>SymOrd1</a></li>
--   <li><a>SymOrd2</a></li>
--   <li><a>SymEq</a></li>
--   <li><a>SymEq1</a></li>
--   <li><a>SymEq2</a></li>
--   <li><a>UnifiedSymEq</a></li>
--   <li><a>UnifiedSymEq1</a></li>
--   <li><a>UnifiedSymEq2</a></li>
--   <li><a>UnifiedSymOrd</a></li>
--   <li><a>UnifiedSymOrd1</a></li>
--   <li><a>UnifiedSymOrd2</a></li>
--   <li><a>ToSym</a></li>
--   <li><a>ToSym1</a></li>
--   <li><a>ToSym2</a></li>
--   <li><a>ToCon</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToCon2</a></li>
--   <li><a>Serial</a></li>
--   <li><a>Serial1</a></li>
--   <li><a>Serial2</a></li>
--   <li><a>SimpleMergeable</a></li>
--   <li><a>SimpleMergeable1</a></li>
--   <li><a>SimpleMergeable2</a></li>
--   <li><a>Binary</a></li>
--   <li><a>Serialize</a></li>
--   </ul>
--   
--   Note that the following type classes cannot be derived for GADTs with
--   existential type variables.
--   
--   <ul>
--   <li><a>ToCon</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToCon2</a></li>
--   <li><a>ToSym</a></li>
--   <li><a>ToSym1</a></li>
--   <li><a>ToSym2</a></li>
--   <li><a>Serial</a></li>
--   <li><a>Serial1</a></li>
--   <li><a>Serial2</a></li>
--   <li><a>Binary</a></li>
--   <li><a>Serialize</a></li>
--   </ul>
deriveWith :: DeriveConfig -> [Name] -> [Name] -> Q [Dec]

-- | All the classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>EvalSym</a></li>
--   <li><a>ExtractSym</a></li>
--   <li><a>SubstSym</a></li>
--   <li><a>NFData</a></li>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Show</a></li>
--   <li><a>PPrint</a></li>
--   <li><a>AllSyms</a></li>
--   <li><a>Eq</a></li>
--   <li><a>SymEq</a></li>
--   <li><a>SymOrd</a></li>
--   <li><a>UnifiedSymEq</a></li>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd</a></li>
--   <li><a>Serial</a></li>
--   <li><a>ToCon</a></li>
--   <li><a>ToSym</a></li>
--   </ul>
allClasses0 :: [Name]

-- | All the classes that can be derived for GADT functors.
--   
--   This includes all the classes in <a>allClasses0</a> and
--   <a>allClasses1</a>.
allClasses01 :: [Name]

-- | All the classes that can be derived for GADT functors.
--   
--   This includes all the classes in <a>allClasses0</a>,
--   <a>allClasses1</a>, and <a>allClasses2</a>.
allClasses012 :: [Name]

-- | Basic classes for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>EvalSym</a></li>
--   <li><a>ExtractSym</a></li>
--   <li><a>SubstSym</a></li>
--   <li><a>NFData</a></li>
--   <li><a>Show</a></li>
--   <li><a>PPrint</a></li>
--   <li><a>AllSyms</a></li>
--   <li><a>Eq</a></li>
--   <li><a>SymEq</a></li>
--   <li><a>SymOrd</a></li>
--   <li><a>UnifiedSymEq</a></li>
--   </ul>
--   
--   These classes can be derived for most GADTs.
basicClasses0 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable1</a></li>
--   <li><a>EvalSym1</a></li>
--   <li><a>ExtractSym1</a></li>
--   <li><a>SubstSym1</a></li>
--   <li><a>NFData1</a></li>
--   <li><a>Show1</a></li>
--   <li><a>PPrint1</a></li>
--   <li><a>AllSyms1</a></li>
--   <li><a>Eq1</a></li>
--   <li><a>SymEq1</a></li>
--   <li><a>SymOrd1</a></li>
--   <li><a>UnifiedSymEq1</a></li>
--   </ul>
basicClasses1 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable2</a></li>
--   <li><a>EvalSym2</a></li>
--   <li><a>ExtractSym2</a></li>
--   <li><a>SubstSym2</a></li>
--   <li><a>NFData2</a></li>
--   <li><a>Show2</a></li>
--   <li><a>PPrint2</a></li>
--   <li><a>AllSyms2</a></li>
--   <li><a>Eq2</a></li>
--   <li><a>SymEq2</a></li>
--   <li><a>SymOrd2</a></li>
--   <li><a>UnifiedSymEq2</a></li>
--   </ul>
basicClasses2 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes all the classes in <a>basicClasses0</a> and
--   <a>basicClasses1</a>.
basicClasses01 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes all the classes in <a>basicClasses0</a> and
--   <a>basicClasses1</a> and <a>basicClasses2</a>.
basicClasses012 :: [Name]

-- | Classes that can only be derived for GADTs without existential type
--   variables.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial</a></li>
--   <li><a>Serialize</a></li>
--   <li><a>Binary</a></li>
--   <li><a>ToCon</a></li>
--   <li><a>ToSym</a></li>
--   </ul>
noExistentialClasses0 :: [Name]

-- | Concrete ordered classes that can be derived for GADTs that
--   
--   <ul>
--   <li>uses unified evaluation mode, or</li>
--   <li>does not contain any symbolic variables.</li>
--   </ul>
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd</a></li>
--   </ul>
concreteOrdClasses0 :: [Name]

-- | Hashable classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   </ul>
hashableClasses0 :: [Name]

-- | <tt>*1</tt> classes that can only be derived for GADT functors without
--   existential type variables.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial1</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToSym1</a></li>
--   </ul>
noExistentialClasses1 :: [Name]

-- | <tt>*1</tt> concrete ordered classes that can be derived for GADT
--   functors that
--   
--   <ul>
--   <li>uses unified evaluation mode, or</li>
--   <li>does not contain any symbolic variables.</li>
--   </ul>
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord1</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd1</a></li>
--   </ul>
concreteOrdClasses1 :: [Name]

-- | Hashable classes that can be derived for GADT functors.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Hashable1</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   </ul>
hashableClasses1 :: [Name]

-- | <tt>*2</tt> classes that can only be derived for GADT functors without
--   existential type variables.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial2</a></li>
--   <li><a>ToCon2</a></li>
--   <li><a>ToSym2</a></li>
--   </ul>
noExistentialClasses2 :: [Name]

-- | <tt>*2</tt> concrete ordered classes that can be derived for GADT
--   functors that
--   
--   <ul>
--   <li>uses unified evaluation mode, or</li>
--   <li>does not contain any symbolic variables.</li>
--   </ul>
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord2</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd2</a></li>
--   </ul>
concreteOrdClasses2 :: [Name]

-- | Hashable classes that can be derived for GADT functors.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Hashable2</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   </ul>
hashableClasses2 :: [Name]

-- | <a>Show</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Show</a></li>
--   <li><a>Show1</a></li>
--   <li><a>Show2</a></li>
--   </ul>
showClasses :: [Name]

-- | <a>PPrint</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>PPrint</a></li>
--   <li><a>PPrint1</a></li>
--   <li><a>PPrint2</a></li>
--   </ul>
pprintClasses :: [Name]

-- | <a>EvalSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>EvalSym</a></li>
--   <li><a>EvalSym1</a></li>
--   <li><a>EvalSym2</a></li>
--   </ul>
evalSymClasses :: [Name]

-- | <a>ExtractSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>ExtractSym</a></li>
--   <li><a>ExtractSym1</a></li>
--   <li><a>ExtractSym2</a></li>
--   </ul>
extractSymClasses :: [Name]

-- | <a>SubstSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SubstSym</a></li>
--   <li><a>SubstSym1</a></li>
--   <li><a>SubstSym2</a></li>
--   </ul>
substSymClasses :: [Name]

-- | <a>AllSyms</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>AllSyms</a></li>
--   <li><a>AllSyms1</a></li>
--   <li><a>AllSyms2</a></li>
--   </ul>
allSymsClasses :: [Name]

-- | <a>Eq</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Eq</a></li>
--   <li><a>Eq1</a></li>
--   <li><a>Eq2</a></li>
--   </ul>
eqClasses :: [Name]

-- | <a>Ord</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord1</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord2</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   </ul>
ordClasses :: [Name]

-- | <a>SymOrd</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SymOrd</a></li>
--   <li><a>SymOrd1</a></li>
--   <li><a>SymOrd2</a></li>
--   </ul>
symOrdClasses :: [Name]

-- | <a>SymEq</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SymEq</a></li>
--   <li><a>SymEq1</a></li>
--   <li><a>SymEq2</a></li>
--   </ul>
symEqClasses :: [Name]

-- | <a>UnifiedSymOrd</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>UnifiedSymOrd</a></li>
--   <li><a>UnifiedSymOrd1</a></li>
--   <li><a>UnifiedSymOrd2</a></li>
--   </ul>
unifiedSymOrdClasses :: [Name]

-- | <a>UnifiedSymEq</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>UnifiedSymEq</a></li>
--   <li><a>UnifiedSymEq1</a></li>
--   <li><a>UnifiedSymEq2</a></li>
--   </ul>
unifiedSymEqClasses :: [Name]

-- | <a>Mergeable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>Mergeable1</a></li>
--   <li><a>Mergeable2</a></li>
--   <li><a>Mergeable3</a></li>
--   </ul>
mergeableClasses :: [Name]

-- | <a>NFData</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>NFData</a></li>
--   <li><a>NFData1</a></li>
--   <li><a>NFData2</a></li>
--   </ul>
nfDataClasses :: [Name]

-- | <a>Hashable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable1</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable2</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   </ul>
hashableClasses :: [Name]

-- | <a>ToSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>ToSym</a></li>
--   <li><a>ToSym1</a></li>
--   <li><a>ToSym2</a></li>
--   </ul>
toSymClasses :: [Name]

-- | <a>ToCon</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>ToCon</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToCon2</a></li>
--   </ul>
toConClasses :: [Name]

-- | <a>Serial</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial</a></li>
--   <li><a>Serial1</a></li>
--   <li><a>Serial2</a></li>
--   </ul>
serialClasses :: [Name]

-- | <a>SimpleMergeable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SimpleMergeable</a></li>
--   <li><a>SimpleMergeable1</a></li>
--   <li><a>SimpleMergeable2</a></li>
--   </ul>
simpleMergeableClasses :: [Name]

-- | <a>UnifiedSimpleMergeable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>UnifiedSimpleMergeable</a></li>
--   <li><a>UnifiedSimpleMergeable1</a></li>
--   <li><a>UnifiedSimpleMergeable2</a></li>
--   </ul>
unifiedSimpleMergeableClasses :: [Name]

-- | Filter classes that accepts type constructors with exactly <tt>n</tt>
--   arguments.
filterExactNumArgs :: Int -> [Name] -> [Name]

-- | Filter classes that accepts type constructors with at most <tt>n</tt>
--   arguments.
filterLeqNumArgs :: Int -> [Name] -> [Name]


module Grisette.Internal.SymPrim.AllSyms

-- | Some symbolic value with <a>LinkedRep</a> constraint.
data SomeSym
[SomeSym] :: forall con sym. LinkedRep con sym => sym -> SomeSym

-- | Extract all symbolic primitive values that are represented as SMT
--   terms.
--   
--   <pre>
--   &gt;&gt;&gt; allSyms (["a" + 1 :: SymInteger, -"b"], "c" :: SymBool)
--   [(+ 1 a),(- b),c]
--   </pre>
--   
--   This is usually used for getting a statistical summary of the size of
--   a symbolic value with <a>allSymsSize</a>.
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extenstions.
--   
--   <pre>
--   data X = ... deriving Generic deriving AllSyms via (Default X)
--   </pre>
class AllSyms a

-- | Convert a value to a list of symbolic primitive values. It should
--   prepend to an existing list of symbolic primitive values.
allSymsS :: AllSyms a => a -> [SomeSym] -> [SomeSym]

-- | Specialized <a>allSymsS</a> that prepends to an empty list.
allSyms :: AllSyms a => a -> [SomeSym]

-- | Lifting of the <a>AllSyms</a> class to unary type constructors.
class forall a. AllSyms a => AllSyms f a => AllSyms1 (f :: Type -> Type)

-- | Lift the <a>allSymsS</a> function to unary type constructors.
liftAllSymsS :: AllSyms1 f => (a -> [SomeSym] -> [SomeSym]) -> f a -> [SomeSym] -> [SomeSym]

-- | Lift the standard <a>allSymsS</a> function to unary type constructors.
allSymsS1 :: (AllSyms1 f, AllSyms a) => f a -> [SomeSym] -> [SomeSym]

-- | Lifting of the <a>AllSyms</a> class to binary type constructors.
class forall a. AllSyms a => AllSyms1 f a => AllSyms2 (f :: Type -> Type -> Type)

-- | Lift the <a>allSymsS</a> function to binary type constructors.
liftAllSymsS2 :: AllSyms2 f => (a -> [SomeSym] -> [SomeSym]) -> (b -> [SomeSym] -> [SomeSym]) -> f a b -> [SomeSym] -> [SomeSym]

-- | Lift the standard <a>allSymsS</a> function to binary type
--   constructors.
allSymsS2 :: (AllSyms2 f, AllSyms a, AllSyms b) => f a b -> [SomeSym] -> [SomeSym]

-- | Get the total size of symbolic terms in a value. Duplicate sub-terms
--   are counted for only once.
--   
--   <pre>
--   &gt;&gt;&gt; allSymsSize ("a" :: SymInteger, "a" + "b" :: SymInteger, ("a" + "b") * "c" :: SymInteger)
--   5
--   </pre>
--   
--   The 5 terms are <tt>a</tt>, <tt>b</tt>, <tt>(+ a b)</tt>, <tt>c</tt>,
--   and <tt>(* (+ a b) c)</tt>.
allSymsSize :: AllSyms a => a -> Int

-- | Get the size of a symbolic term. Duplicate sub-terms are counted for
--   only once.
--   
--   <pre>
--   &gt;&gt;&gt; symSize (1 :: SymInteger)
--   1
--   
--   &gt;&gt;&gt; symSize ("a" :: SymInteger)
--   1
--   
--   &gt;&gt;&gt; symSize ("a" + 1 :: SymInteger)
--   3
--   
--   &gt;&gt;&gt; symSize (("a" + 1) * ("a" + 1) :: SymInteger)
--   4
--   </pre>
symSize :: LinkedRep con sym => sym -> Int

-- | Get the sum of the sizes of a list of symbolic terms. Duplicate
--   sub-terms are counted for only once.
--   
--   <pre>
--   &gt;&gt;&gt; symsSize [1, "a" :: SymInteger, "a" + 1 :: SymInteger]
--   3
--   </pre>
symsSize :: LinkedRep con sym => [sym] -> Int

-- | The arguments to the generic <a>AllSyms</a> function.
data family AllSymsArgs arity a

-- | The class of types that can generically extract all symbolic
--   primitives.
class GAllSyms arity (f :: Type -> Type)
gallSymsS :: GAllSyms arity f => AllSymsArgs arity a -> f a -> [SomeSym] -> [SomeSym]

-- | Generic <a>allSymsS</a> function.
genericAllSymsS :: (Generic a, GAllSyms Arity0 (Rep a)) => a -> [SomeSym] -> [SomeSym]

-- | Generic <a>liftAllSymsS</a> function.
genericLiftAllSymsS :: (Generic1 f, GAllSyms Arity1 (Rep1 f)) => (a -> [SomeSym] -> [SomeSym]) -> f a -> [SomeSym] -> [SomeSym]


module Grisette.Internal.Core.Data.Class.ToCon

-- | Convert a symbolic value to concrete value if possible.
class ToCon a b

-- | Convert a symbolic value to concrete value if possible. If the
--   symbolic value cannot be converted to concrete, the result will be
--   <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toCon (ssym "a" :: SymInteger) :: Maybe Integer
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCon (con 1 :: SymInteger) :: Maybe Integer
--   Just 1
--   </pre>
--   
--   <a>toCon</a> works on complex types too.
--   
--   <pre>
--   &gt;&gt;&gt; toCon ([con 1, con 2] :: [SymInteger]) :: Maybe [Integer]
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCon ([con 1, ssym "a"] :: [SymInteger]) :: Maybe [Integer]
--   Nothing
--   </pre>
toCon :: ToCon a b => a -> Maybe b

-- | Lifting of <a>ToCon</a> to unary type constructors.
class forall a b. ToCon a b => ToCon f1 a f2 b => ToCon1 (f1 :: Type -> Type) (f2 :: Type -> Type)

-- | Lift a conversion to concrete function to unary type constructors.
liftToCon :: ToCon1 f1 f2 => (a -> Maybe b) -> f1 a -> Maybe (f2 b)

-- | Lift the standard <a>toCon</a> to unary type constructors.
toCon1 :: (ToCon1 f1 f2, ToCon a b) => f1 a -> Maybe (f2 b)

-- | Lifting of <a>ToCon</a> to binary type constructors.
class forall a b. ToCon a b => ToCon1 f1 a f2 b => ToCon2 (f1 :: Type -> Type -> Type) (f2 :: Type -> Type -> Type)

-- | Lift conversion to concrete functions to binary type constructors.
liftToCon2 :: ToCon2 f1 f2 => (a -> Maybe b) -> (c -> Maybe d) -> f1 a c -> Maybe (f2 b d)

-- | Lift the standard <a>toCon</a> to binary type constructors.
toCon2 :: (ToCon2 f1 f2, ToCon a b, ToCon c d) => f1 a c -> Maybe (f2 b d)

-- | The arguments to the generic <a>toCon</a> function.
data family ToConArgs arity a b

-- | The class of types that can be generically converted to concrete
--   values.
class GToCon arity (f1 :: Type -> Type) (f2 :: Type -> Type)
gtoCon :: GToCon arity f1 f2 => ToConArgs arity a b -> f1 a -> Maybe (f2 b)

-- | Generic <a>toCon</a> function.
genericToCon :: (Generic a, Generic b, GToCon Arity0 (Rep a) (Rep b)) => a -> Maybe b

-- | Generic <a>liftToCon</a> function.
genericLiftToCon :: (Generic1 f1, Generic1 f2, GToCon Arity1 (Rep1 f1) (Rep1 f2)) => (a -> Maybe b) -> f1 a -> Maybe (f2 b)


module Grisette.Internal.Core.Data.Class.SymEq

-- | Symbolic equality. Note that we can't use Haskell's <a>Eq</a> class
--   since symbolic comparison won't necessarily return a concrete
--   <a>Bool</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; let a = 1 :: SymInteger
--   
--   &gt;&gt;&gt; let b = 2 :: SymInteger
--   
--   &gt;&gt;&gt; a .== b
--   false
--   
--   &gt;&gt;&gt; a ./= b
--   true
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = "a" :: SymInteger
--   
--   &gt;&gt;&gt; let b = "b" :: SymInteger
--   
--   &gt;&gt;&gt; a .== b
--   (= a b)
--   
--   &gt;&gt;&gt; a ./= b
--   (! (= a b))
--   </pre>
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving SymEq via (Default X)
--   </pre>
class SymEq a
(.==) :: SymEq a => a -> a -> SymBool
(./=) :: SymEq a => a -> a -> SymBool

-- | Check if all elements in a list are distinct, under the symbolic
--   equality semantics.
symDistinct :: SymEq a => [a] -> SymBool
infix 4 .==
infix 4 ./=

-- | Lifting of the <a>SymEq</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftSymEq (.==)</tt> should be equivalent to <tt>(.==)</tt>, under
--   the symbolic semantics.
--   
--   This class therefore represents the generalization of <a>SymEq</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class forall a. SymEq a => SymEq f a => SymEq1 (f :: Type -> Type)

-- | Lift a symbolic equality test through the type constructor.
--   
--   The function will usually be applied to an symbolic equality function,
--   but the more general type ensures that the implementation uses it to
--   compare elements of the first container with elements of the second.
liftSymEq :: SymEq1 f => (a -> b -> SymBool) -> f a -> f b -> SymBool

-- | Lift the standard <tt>(<a>.==</a>)</tt> function through the type
--   constructor.
symEq1 :: (SymEq a, SymEq1 f) => f a -> f a -> SymBool

-- | Lifting of the <a>SymEq</a> class to binary type constructors.
class forall a. SymEq a => SymEq1 f a => SymEq2 (f :: Type -> Type -> Type)

-- | Lift symbolic equality tests through the type constructor.
--   
--   The function will usually be applied to an symbolic equality function,
--   but the more general type ensures that the implementation uses it to
--   compare elements of the first container with elements of the second.
liftSymEq2 :: SymEq2 f => (a -> b -> SymBool) -> (c -> d -> SymBool) -> f a c -> f b d -> SymBool

-- | Lift the standard <tt>(<a>.==</a>)</tt> function through the type
--   constructor.
symEq2 :: (SymEq a, SymEq b, SymEq2 f) => f a b -> f a b -> SymBool

-- | Default pairwise symbolic distinct implementation.
pairwiseSymDistinct :: SymEq a => [a] -> SymBool

-- | Check if all elements in a list are distinct.
--   
--   Note that empty or singleton lists are always distinct.
--   
--   <pre>
--   &gt;&gt;&gt; distinct []
--   True
--   
--   &gt;&gt;&gt; distinct [1]
--   True
--   
--   &gt;&gt;&gt; distinct [1, 2, 3]
--   True
--   
--   &gt;&gt;&gt; distinct [1, 2, 2]
--   False
--   </pre>
distinct :: Eq a => [a] -> Bool

-- | The arguments to the generic equality function.
data family SymEqArgs arity a b

-- | The class of types that can be generically compared for symbolic
--   equality.
class GSymEq arity (f :: Type -> Type)
gsymEq :: GSymEq arity f => SymEqArgs arity a b -> f a -> f b -> SymBool

-- | Generic <tt>(<a>.==</a>)</tt> function.
genericSymEq :: (Generic a, GSymEq Arity0 (Rep a)) => a -> a -> SymBool

-- | Generic <a>liftSymEq</a> function.
genericLiftSymEq :: (Generic1 f, GSymEq Arity1 (Rep1 f)) => (a -> b -> SymBool) -> f a -> f b -> SymBool


module Grisette.Internal.Core.Data.Class.SubstSym

-- | Substitution of symbols (symbolic constants) to a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; a = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; v = "x" .&amp;&amp; "y" :: SymBool
--   
--   &gt;&gt;&gt; substSym a v (["a" .&amp;&amp; "b", "a"] :: [SymBool])
--   [(&amp;&amp; (&amp;&amp; x y) b),(&amp;&amp; x y)]
--   </pre>
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving SubstSym via (Default X)
--   </pre>
class SubstSym a
substSym :: forall cb sb (knd :: SymbolKind). (SubstSym a, LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> a -> a

-- | Lifting of <a>SubstSym</a> to unary type constructors.
class forall a. SubstSym a => SubstSym f a => SubstSym1 (f :: Type -> Type)

-- | Lift a symbol substitution function to unary type constructors.
liftSubstSym :: forall cb sb (knd :: SymbolKind) a. (SubstSym1 f, LinkedRep cb sb, IsSymbolKind knd) => (TypedSymbol knd cb -> sb -> a -> a) -> TypedSymbol knd cb -> sb -> f a -> f a

-- | Lifting the standard <a>substSym</a> to unary type constructors.
substSym1 :: forall f a cb sb (knd :: SymbolKind). (SubstSym1 f, SubstSym a, LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> f a -> f a

-- | Lifting of <a>SubstSym</a> to binary type constructors.
class forall a. SubstSym a => SubstSym1 f a => SubstSym2 (f :: Type -> Type -> Type)

-- | Lift a symbol substitution function to binary type constructors.
liftSubstSym2 :: forall cb sb (knd :: SymbolKind) a b. (SubstSym2 f, LinkedRep cb sb, IsSymbolKind knd) => (TypedSymbol knd cb -> sb -> a -> a) -> (TypedSymbol knd cb -> sb -> b -> b) -> TypedSymbol knd cb -> sb -> f a b -> f a b

-- | Lifting the standard <a>substSym</a> to binary type constructors.
substSym2 :: forall f a b cb sb (knd :: SymbolKind). (SubstSym2 f, SubstSym a, SubstSym b, LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> f a b -> f a b

-- | The arguments to the generic <a>substSym</a> function.
data family SubstSymArgs arity (knd :: SymbolKind) a cb sb

-- | The class of types where we can generically substitute the symbols in
--   a value.
class GSubstSym arity (f :: Type -> Type)
gsubstSym :: forall cb sb (knd :: SymbolKind) a. (GSubstSym arity f, LinkedRep cb sb, IsSymbolKind knd) => SubstSymArgs arity knd a cb sb -> TypedSymbol knd cb -> sb -> f a -> f a

-- | Generic <a>substSym</a> function.
genericSubstSym :: forall a cb sb (knd :: SymbolKind). (Generic a, GSubstSym Arity0 (Rep a), LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> a -> a

-- | Generic <a>liftSubstSym</a> function.
genericLiftSubstSym :: forall f cb sb (knd :: SymbolKind) a. (Generic1 f, GSubstSym Arity1 (Rep1 f), LinkedRep cb sb, IsSymbolKind knd) => (TypedSymbol knd cb -> sb -> a -> a) -> TypedSymbol knd cb -> sb -> f a -> f a


module Grisette.Internal.Core.Data.Class.PPrint

-- | Pretty printing of values.
--   
--   This class is similar to the <a>Pretty</a> class from the
--   <a>Prettyprinter</a> package, but it also provides pretty printing
--   with a given precedence level.
--   
--   We are able to derive instances of this class for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving PPrint via (Default X)
--   </pre>
--   
--   The derived instance will pretty print the value with a format similar
--   to the one used by ormolu.
class PPrint a
pformat :: PPrint a => a -> Doc ann
pformatPrec :: PPrint a => Int -> a -> Doc ann
pformatList :: PPrint a => [a] -> Doc ann

-- | Convenience function to layout and render a <a>Doc</a> to <a>Text</a>.
--   
--   You can control the layout with <a>LayoutOptions</a>.
docToTextWith :: LayoutOptions -> Doc ann -> Text

-- | Convenience function to layout and render a <a>Doc</a> to <a>Text</a>.
--   
--   You can control the layout with a single number of the width limit.
docToTextWithWidth :: Int -> Doc ann -> Text

-- | Convenience function to layout and render a <a>Doc</a> to <a>Text</a>.
--   
--   The default layout options <a>defaultLayoutOptions</a> are used.
docToText :: Doc ann -> Text

-- | Convenience function to format a value to <a>Text</a>.
--   
--   You can control the layout with <a>LayoutOptions</a>.
pformatTextWith :: PPrint a => LayoutOptions -> a -> Text

-- | Convenience function to format a value to <a>Text</a>.
--   
--   You can control the layout with a single number of the width limit.
pformatTextWithWidth :: PPrint a => Int -> a -> Text

-- | Convenience function to format a value to <a>Text</a>.
--   
--   The default layout options <a>defaultLayoutOptions</a> are used.
pformatText :: PPrint a => a -> Text

-- | Pretty print a value to the standard output.
pprint :: PPrint a => a -> IO ()

-- | Lifting of the <a>PPrint</a> class to unary type constructors.
class forall a. PPrint a => PPrint f a => PPrint1 (f :: Type -> Type)

-- | Lift a pretty-printer to a unary type constructor.
liftPFormatPrec :: PPrint1 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> Int -> f a -> Doc ann

-- | Lift a pretty-printer to list of values with unary type constructors.
liftPFormatList :: PPrint1 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> [f a] -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to unary type constructors.
pformatPrec1 :: (PPrint1 f, PPrint a) => Int -> f a -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to list of values with unary type constructors.
pformatList1 :: (PPrint1 f, PPrint a) => [f a] -> Doc ann

-- | Lifting of the <a>PPrint</a> class to binary type constructors.
class (forall a. PPrint a => PPrint1 f a, forall a b. (PPrint a, PPrint b) => PPrint f a b) => PPrint2 (f :: Type -> Type -> Type)

-- | Lift two pretty-printers to a binary type constructor.
liftPFormatPrec2 :: PPrint2 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> (Int -> b -> Doc ann) -> ([b] -> Doc ann) -> Int -> f a b -> Doc ann

-- | Lift two pretty-printers to list of values with binary type
--   constructors.
liftPFormatList2 :: PPrint2 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> (Int -> b -> Doc ann) -> ([b] -> Doc ann) -> [f a b] -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to binary type constructors.
pformatPrec2 :: (PPrint2 f, PPrint a, PPrint b) => Int -> f a b -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to list of values with binary type constructors.
pformatList2 :: (PPrint2 f, PPrint a, PPrint b) => [f a b] -> Doc ann

-- | Generic <a>pformatPrec</a> function.
genericPFormatPrec :: (Generic a, GPPrint Arity0 (Rep a)) => Int -> a -> Doc ann

-- | Generic <a>liftPFormatPrec</a> function.
genericLiftPFormatPrec :: (Generic1 f, GPPrint Arity1 (Rep1 f)) => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> Int -> f a -> Doc ann

-- | Generic <a>pformatList</a> function.
genericPFormatList :: (Generic a, GPPrint Arity0 (Rep a)) => [a] -> Doc ann

-- | Generic <a>liftPFormatList</a> function.
genericLiftPFormatList :: (Generic1 f, GPPrint Arity1 (Rep1 f)) => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> [f a] -> Doc ann

-- | The arguments to the generic <a>PPrint</a> class.
data family PPrintArgs arity a ann

-- | Generic <a>PPrint</a> class.
class GPPrint arity (f :: Type -> Type)
gpformatPrec :: GPPrint arity f => PPrintArgs arity a ann -> PPrintType -> Int -> f a -> Doc ann
gpformatList :: (GPPrint arity f, HasCallStack) => PPrintArgs arity a ann -> [f a] -> Doc ann
gisNullary :: (GPPrint arity f, HasCallStack) => PPrintArgs arity a ann -> f a -> Bool

-- | Controls how to pretty-print a generic representation.
data PPrintType
Rec :: PPrintType
Tup :: PPrintType
Pref :: PPrintType
Inf :: String -> Int -> PPrintType

-- | Enclose a document with left and right documents.
--   
--   The pretty printer will try to layout the document in a single line,
--   but the right document may be split to a newline.
groupedEnclose :: Doc ann -> Doc ann -> Doc ann -> Doc ann

-- | Conditionally enclose a document with left and right documents.
--   
--   If the condition is <a>True</a>, then this function is equivalent to
--   <a>groupedEnclose</a>.
condEnclose :: Bool -> Doc ann -> Doc ann -> Doc ann -> Doc ann

-- | Pretty print a list of fields with a constructor.
--   
--   Aligns the fields and nests them by 2 spaces.
pformatWithConstructor :: Int -> Doc ann -> [Doc ann] -> Doc ann

-- | Pretty print a list of fields with a constructor without alignment.
pformatWithConstructorNoAlign :: Int -> Doc ann -> [Doc ann] -> Doc ann

-- | Pretty print a value using <a>showsPrec</a>.
viaShowsPrec :: (Int -> a -> ShowS) -> Int -> a -> Doc ann


module Grisette.Internal.Core.Data.Class.ToSym

-- | Convert a concrete value to symbolic value.
class ToSym a b

-- | Convert a concrete value to symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; toSym False :: SymBool
--   false
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toSym [False, True] :: [SymBool]
--   [false,true]
--   </pre>
toSym :: ToSym a b => a -> b

-- | Lifting of <a>ToSym</a> to unary type constructors.
class forall a b. ToSym a b => ToSym f1 a f2 b => ToSym1 (f1 :: Type -> Type) (f2 :: Type -> Type)

-- | Lift a conversion to symbolic function to unary type constructors.
liftToSym :: ToSym1 f1 f2 => (a -> b) -> f1 a -> f2 b

-- | Lift the standard <a>toSym</a> to unary type constructors.
toSym1 :: (ToSym1 f1 f2, ToSym a b) => f1 a -> f2 b

-- | Lifting of <a>ToSym</a> to binary type constructors.
class forall a b. ToSym a b => ToSym1 f1 a f2 b => ToSym2 (f1 :: Type -> Type -> Type) (f2 :: Type -> Type -> Type)

-- | Lift conversion to symbolic functions to binary type constructors.
liftToSym2 :: ToSym2 f1 f2 => (a -> b) -> (c -> d) -> f1 a c -> f2 b d

-- | Lift the standard <a>toSym</a> to binary type constructors.
toSym2 :: (ToSym2 f1 f2, ToSym a b, ToSym c d) => f1 a c -> f2 b d

-- | The arguments to the generic <a>toSym</a> function.
data family ToSymArgs arity a b

-- | The class of types that can be generically converted to symbolic
--   values.
class GToSym arity (f1 :: Type -> Type) (f2 :: Type -> Type)
gtoSym :: GToSym arity f1 f2 => ToSymArgs arity a b -> f1 a -> f2 b

-- | Generic <a>toSym</a> function.
genericToSym :: (Generic a, Generic b, GToSym Arity0 (Rep a) (Rep b)) => a -> b

-- | Generic <a>liftToSym</a> function.
genericLiftToSym :: (Generic1 f1, Generic1 f2, GToSym Arity1 (Rep1 f1) (Rep1 f2)) => (a -> b) -> f1 a -> f2 b


module Grisette.Internal.Unified.BaseConstraint

-- | A type that is used as a constraint for all the types in Grisette that
--   can be converted between concrete and symbolic types.
type ConSymConversion conType symType t = (ToCon t conType, ToSym conType t, ToCon symType t, ToSym t symType)


module Grisette.Internal.Core.Data.Class.Mergeable

-- | Merging strategies.
--   
--   <b>You probably do not need to know the details of this type if you
--   are only</b> <b>going to use algebraic data types. You can get merging
--   strategies for</b> <b>them with type derivation.</b>
--   
--   In Grisette, a merged union (if-then-else tree) follows the
--   <b><i>hierarchical sorted representation invariant</i></b> with
--   regards to some merging strategy.
--   
--   A merging strategy encodes how to merge a <b><i>subset</i></b> of the
--   values of a given type. We have three types of merging strategies:
--   
--   <ul>
--   <li>Simple strategy</li>
--   <li>Sorted strategy</li>
--   <li>No strategy</li>
--   </ul>
--   
--   The <a>SimpleStrategy</a> merges values with a simple merge function.
--   For example,
--   
--   <ul>
--   <li>the symbolic boolean values can be directly merged with
--   <a>symIte</a>.</li>
--   <li>the set <tt>{1}</tt>, which is a subset of the values of the type
--   <tt>Integer</tt>, can be simply merged as the set contains only a
--   single value.</li>
--   <li>all the <a>Just</a> values of the type <tt>Maybe SymBool</tt> can
--   be simply merged by merging the wrapped symbolic boolean with
--   <a>symIte</a>.</li>
--   </ul>
--   
--   The <a>SortedStrategy</a> merges values by first grouping the values
--   with an indexing function, and the values with the same index will be
--   organized as a sub-tree in the if-then-else structure of
--   <a>UnionBase</a>. Each group (sub-tree) will be further merged with a
--   sub-strategy for the index. The index type should be a totally ordered
--   type (with the <a>Ord</a> type class). Grisette will use the indexing
--   function to partition the values into sub-trees, and organize them in
--   a sorted way. The sub-trees will further be merged with the
--   sub-strategies. For example,
--   
--   <ul>
--   <li>all the integers can be merged with <a>SortedStrategy</a> by
--   indexing with the identity function and use the <a>SimpleStrategy</a>
--   shown before as the sub-strategies.</li>
--   <li>all the <tt>Maybe SymBool</tt> values can be merged with
--   <a>SortedStrategy</a> by indexing with <a>isJust</a>, the
--   <a>Nothing</a> and <a>Just</a> values can then be merged with
--   different simple strategies as sub-strategies.</li>
--   </ul>
--   
--   The <a>NoStrategy</a> does not perform any merging. For example, we
--   cannot merge values with function types that returns concrete lists.
--   
--   For ADTs, we can automatically derive the <a>Mergeable</a> type class,
--   which provides a merging strategy.
--   
--   If the derived version does not work for you, you should determine if
--   your type can be directly merged with a merging function. If so, you
--   can implement the merging strategy as a <a>SimpleStrategy</a>. If the
--   type cannot be directly merged with a merging function, but could be
--   partitioned into subsets of values that can be simply merged with a
--   function, you should implement the merging strategy as a
--   <a>SortedStrategy</a>. For easier building of the merging strategies,
--   check out the combinators like <a>wrapStrategy</a>.
--   
--   For more details, please see the documents of the constructors, or
--   refer to <a>Grisette's paper</a>.
data MergingStrategy a

-- | Simple mergeable strategy.
--   
--   For symbolic booleans, we can implement its merge strategy as follows:
--   
--   <pre>
--   SimpleStrategy symIte :: MergingStrategy SymBool
--   </pre>
[SimpleStrategy] :: forall a. (SymBool -> a -> a -> a) -> MergingStrategy a

-- | Sorted mergeable strategy.
--   
--   For Integers, we can implement its merge strategy as follows:
--   
--   <pre>
--   SortedStrategy id (\_ -&gt; SimpleStrategy $ \_ t _ -&gt; t)
--   </pre>
--   
--   For <tt>Maybe SymBool</tt>, we can implement its merge strategy as
--   follows:
--   
--   <pre>
--   SortedStrategy
--     (\case; Nothing -&gt; False; Just _ -&gt; True)
--     (\idx -&gt;
--        if idx
--          then SimpleStrategy $ \_ t _ -&gt; t
--          else SimpleStrategy $ \cond (Just l) (Just r) -&gt; Just $ symIte cond l r)
--   </pre>
[SortedStrategy] :: forall idx a. MergingIndex idx => (a -> idx) -> (idx -> MergingStrategy a) -> MergingStrategy a

-- | For preventing the merging intentionally. This could be useful for
--   keeping some value concrete and may help generate more efficient
--   formulas.
--   
--   See <a>Grisette's paper</a> for details.
[NoStrategy] :: forall a. MergingStrategy a

-- | Each type is associated with a root merge strategy given by
--   <a>rootStrategy</a>. The root merge strategy should be able to merge
--   every value of the type. Grisette will use the root merge strategy to
--   merge the values of the type in a union.
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving Mergeable via (Default X)
--   </pre>
class Mergeable a

-- | The root merging strategy for the type.
rootStrategy :: Mergeable a => MergingStrategy a
sortIndices :: Mergeable a => a -> [DynamicSortedIdx]

-- | Lifting of the <a>Mergeable</a> class to unary type constructors.
class forall a. Mergeable a => Mergeable u a => Mergeable1 (u :: Type -> Type)

-- | Lift merge strategy through the type constructor.
liftRootStrategy :: Mergeable1 u => MergingStrategy a -> MergingStrategy (u a)

-- | Lift the root merge strategy through the unary type constructor.
rootStrategy1 :: (Mergeable a, Mergeable1 u) => MergingStrategy (u a)

-- | Lifting of the <a>Mergeable</a> class to binary type constructors.
class forall a. Mergeable a => Mergeable1 u a => Mergeable2 (u :: Type -> Type -> Type)

-- | Lift merge strategy through the type constructor.
liftRootStrategy2 :: Mergeable2 u => MergingStrategy a -> MergingStrategy b -> MergingStrategy (u a b)

-- | Lift the root merge strategy through the binary type constructor.
rootStrategy2 :: (Mergeable a, Mergeable b, Mergeable2 u) => MergingStrategy (u a b)

-- | Lifting of the <a>Mergeable</a> class to ternary type constructors.
class forall a. Mergeable a => Mergeable2 u a => Mergeable3 (u :: Type -> Type -> Type -> Type)

-- | Lift merge strategy through the type constructor.
liftRootStrategy3 :: Mergeable3 u => MergingStrategy a -> MergingStrategy b -> MergingStrategy c -> MergingStrategy (u a b c)

-- | Lift the root merge strategy through the binary type constructor.
rootStrategy3 :: (Mergeable a, Mergeable b, Mergeable c, Mergeable3 u) => MergingStrategy (u a b c)

-- | The arguments to the generic merging strategy function.
data family MergeableArgs arity a

-- | The class of types that can be generically merged.
class GMergeable arity (f :: Type -> Type)
grootStrategy :: GMergeable arity f => MergeableArgs arity a -> MergingStrategy (f a)

-- | Generic <a>rootStrategy</a>.
genericRootStrategy :: (Generic a, GMergeable Arity0 (Rep a)) => MergingStrategy a

-- | Generic <a>liftRootStrategy</a>.
genericLiftRootStrategy :: (Generic1 f, GMergeable Arity1 (Rep1 f)) => MergingStrategy a -> MergingStrategy (f a)

-- | Useful utility function for building merge strategies manually.
--   
--   For example, to build the merge strategy for the just branch of
--   <tt>Maybe a</tt>, one could write
--   
--   <pre>
--   wrapStrategy Just fromMaybe rootStrategy :: MergingStrategy (Maybe a)
--   </pre>
wrapStrategy :: MergingStrategy a -> (a -> b) -> (b -> a) -> MergingStrategy b

-- | Useful utility function for building merge strategies for product
--   types manually.
--   
--   For example, to build the merge strategy for the following product
--   type, one could write
--   
--   <pre>
--   data X = X { x1 :: Int, x2 :: Bool }
--   product2Strategy X (\(X a b) -&gt; (a, b)) rootStrategy rootStrategy
--     :: MergingStrategy X
--   </pre>
product2Strategy :: (a -> b -> r) -> (r -> (a, b)) -> MergingStrategy a -> MergingStrategy b -> MergingStrategy r

-- | Helper type for combining arbitrary number of indices into one. Useful
--   when trying to write efficient merge strategy for lists/vectors.
data DynamicSortedIdx
[DynamicSortedIdx] :: forall idx. MergingIndex idx => idx -> DynamicSortedIdx

-- | Helper type for building efficient merge strategy for list-like
--   containers.
data StrategyList (container :: Type -> Type)
[StrategyList] :: forall a (container :: Type -> Type). container [DynamicSortedIdx] -> container (MergingStrategy a) -> StrategyList container

-- | Helper function for building efficient merge strategy for list-like
--   containers.
buildStrategyList :: forall a container. Functor container => MergingStrategy a -> container a -> StrategyList container

-- | Resolves the indices and the terminal merge strategy for a value of
--   some <a>Mergeable</a> type.
resolveStrategy :: MergingStrategy x -> x -> ([DynamicSortedIdx], MergingStrategy x)

-- | Resolves the indices and the terminal merge strategy for a value given
--   a merge strategy for its type.
resolveStrategy' :: x -> MergingStrategy x -> ([DynamicSortedIdx], MergingStrategy x)

-- | Workaround as GHC prior to 9.6 doesn't support quantified constraints
--   reliably.
--   
--   Similar to
--   <a>https://github.com/haskell/core-libraries-committee/issues/10</a>,
--   which is only available with 9.6 or higher.
resolveMergeable1 :: (Mergeable1 f, Mergeable a) => (Mergeable (f a) => r) -> r


module Grisette.Internal.Core.Data.UnionBase

-- | The base union implementation, which is an if-then-else tree
--   structure.
data UnionBase a

-- | A single value
[UnionSingle] :: forall a. a -> UnionBase a

-- | A if value
[UnionIf] :: forall a. a -> !Bool -> !SymBool -> UnionBase a -> UnionBase a -> UnionBase a

-- | Build <a>UnionIf</a> with leftmost cache correctly maintained.
--   
--   Usually you should never directly try to build a <a>UnionIf</a> with
--   its constructor.
ifWithLeftMost :: Bool -> SymBool -> UnionBase a -> UnionBase a -> UnionBase a

-- | Use a specific strategy to build a <a>UnionIf</a> value.
--   
--   The merged invariant will be maintained in the result.
ifWithStrategy :: MergingStrategy a -> SymBool -> UnionBase a -> UnionBase a -> UnionBase a

-- | Fully reconstruct a <a>Union</a> to maintain the merged invariant.
fullReconstruct :: MergingStrategy a -> UnionBase a -> UnionBase a


module Grisette.Internal.Core.Data.Class.TryMerge

-- | A class for containers that may or may not be merged.
--   
--   If the container is capable of multi-path execution, then the
--   <a>tryMergeWithStrategy</a> function should merge the paths according
--   to the supplied strategy.
--   
--   If the container is not capable of multi-path execution, then the
--   <a>tryMergeWithStrategy</a> function should be equivalent to
--   <a>id</a>.
--   
--   Note that this will not necessarily do a recursive merge for the
--   elements.
class TryMerge (m :: Type -> Type)
tryMergeWithStrategy :: TryMerge m => MergingStrategy a -> m a -> m a

-- | Try to merge the container with the root strategy.
tryMerge :: (TryMerge m, Mergeable a) => m a -> m a

-- | Alias for a monad type that has <a>TryMerge</a>.
type MonadTryMerge (f :: Type -> Type) = (TryMerge f, Monad f)

-- | Wrap a value in the applicative functor and propagate the type's root
--   merge strategy.
--   
--   Equivalent to <tt><a>mrgSingleWithStrategy</a>
--   <a>rootStrategy</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; mrgSingle "a" :: Union SymInteger
--   {a}
--   </pre>
mrgSingle :: (TryMerge m, Applicative m, Mergeable a) => a -> m a

-- | Wrap a value in the applicative functor and capture the
--   <a>Mergeable</a> knowledge.
--   
--   <pre>
--   &gt;&gt;&gt; mrgSingleWithStrategy rootStrategy "a" :: Union SymInteger
--   {a}
--   </pre>
--   
--   <b>Note:</b> Be careful to call this directly from your code. The
--   supplied merge strategy should be consistent with the type's root
--   merge strategy, or some internal invariants would be broken and the
--   program can crash.
--   
--   This function is to be called when the <a>Mergeable</a> constraint can
--   not be resolved, e.g., the merge strategy for the contained type is
--   given with <a>Mergeable1</a>. In other cases, <a>mrgPure</a> is
--   usually a better alternative.
mrgSingleWithStrategy :: (TryMerge m, Applicative m) => MergingStrategy a -> a -> m a

-- | Convert a value to symbolic value and wrap it with a mergeable
--   container.
--   
--   This is a synonym for <a>toUnionSym</a>.
mrgToSym :: (ToSym a b, Mergeable b, TryMerge m, Applicative m) => a -> m b

-- | Convert a value to symbolic value and wrap it with a mergeable
--   container.
--   
--   This is a synonym for <a>toUnionSym</a>.
toUnionSym :: (ToSym a b, Mergeable b, TryMerge m, Applicative m) => a -> m b


module Grisette.Internal.TH.Ctor.SmartConstructor

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a> with provided name transformer.
--   
--   <pre>
--   makeSmartCtorWith (\name -&gt; "mrg" ++ name) ''Maybe
--   </pre>
--   
--   generates
--   
--   <pre>
--   mrgNothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; m (Maybe a)
--   mrgNothing = mrgSingle Nothing
--   </pre>
makeSmartCtorWith :: (String -> String) -> Name -> Q [Dec]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a>.
--   
--   <pre>
--   makePrefixedSmartCtor "mrg" ''Maybe
--   </pre>
--   
--   generates
--   
--   <pre>
--   mrgNothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; m (Maybe a)
--   mrgNothing = mrgSingle Nothing
--   mrgJust :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; a -&gt; m (Maybe a)
--   mrgJust = \x -&gt; mrgSingle (Just x)
--   </pre>
makePrefixedSmartCtor :: String -> Name -> Q [Dec]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a> with provided names.
--   
--   <pre>
--   makeNamedSmartCtor ["mrgTuple2"] ''(,)
--   </pre>
--   
--   generates
--   
--   <pre>
--   mrgTuple2 :: (Mergeable (a, b), Applicative m, TryMerge m) =&gt; a -&gt; b -&gt; u (a, b)
--   mrgTuple2 = \v1 v2 -&gt; mrgSingle (v1, v2)
--   </pre>
makeNamedSmartCtor :: [String] -> Name -> Q [Dec]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a>.
--   
--   <pre>
--   makeSmartCtor ''Maybe
--   </pre>
--   
--   generates
--   
--   <pre>
--   nothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; m (Maybe a)
--   nothing = mrgSingle Nothing
--   just :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; a -&gt; m (Maybe a)
--   just = \x -&gt; mrgSingle (Just x)
--   </pre>
makeSmartCtor :: Name -> Q [Dec]


module Grisette.Internal.TH.ADT

-- | Make an ADT compatible with Grisette.
--   
--   This will generate instances for the ADT with the given classes, and
--   smart constructors for each constructor.
--   
--   The derivation is done with the given configuration.
makeGrisetteADTWithClasses :: DeriveConfig -> Name -> [Name] -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   See <tt>derive</tt>, <a>basicClasses0</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   See <tt>derive</tt>, <a>basicClasses01</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT1 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   See <tt>derive</tt>, <a>basicClasses012</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT2 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>basicClasses0</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADTWith :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>basicClasses01</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT1With :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>basicClasses012</a>, and
--   <a>makeSmartCtor</a> for more details.
makeGrisetteBasicADT2With :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   See <tt>derive</tt>, <a>allClasses0</a>, and <a>makeSmartCtor</a> for
--   more details.
makeGrisetteADT :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   See <tt>derive</tt>, <a>allClasses01</a>, and <a>makeSmartCtor</a> for
--   more details.
makeGrisetteADT1 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   See <tt>derive</tt>, <a>allClasses012</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADT2 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>allClasses0</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADTWith :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>allClasses01</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADT1With :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>allClasses012</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADT2With :: DeriveConfig -> Name -> Q [Dec]


module Grisette.Internal.Core.Data.Class.SimpleMergeable

-- | This class indicates that a type has a simple root merge strategy.
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extensions.
--   
--   <pre>
--   data X = ...
--     deriving Generic
--     deriving (Mergeable, SimpleMergeable) via (Default X)
--   </pre>
class Mergeable a => SimpleMergeable a

-- | Performs if-then-else with the simple root merge strategy.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIte "a" "b" "c" :: SymInteger
--   (ite a b c)
--   </pre>
mrgIte :: SimpleMergeable a => SymBool -> a -> a -> a

-- | Lifting of the <a>SimpleMergeable</a> class to unary type
--   constructors.
class (Mergeable1 u, forall a. SimpleMergeable a => SimpleMergeable u a) => SimpleMergeable1 (u :: Type -> Type)

-- | Lift <a>mrgIte</a> through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; liftMrgIte mrgIte "a" (Identity "b") (Identity "c") :: Identity SymInteger
--   Identity (ite a b c)
--   </pre>
liftMrgIte :: SimpleMergeable1 u => (SymBool -> a -> a -> a) -> SymBool -> u a -> u a -> u a

-- | Lift the standard <a>mrgIte</a> function through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIte1 "a" (Identity "b") (Identity "c") :: Identity SymInteger
--   Identity (ite a b c)
--   </pre>
mrgIte1 :: (SimpleMergeable1 u, SimpleMergeable a) => SymBool -> u a -> u a -> u a

-- | Lifting of the <a>SimpleMergeable</a> class to binary type
--   constructors.
class (Mergeable2 u, forall a. SimpleMergeable a => SimpleMergeable1 u a) => SimpleMergeable2 (u :: Type -> Type -> Type)

-- | Lift <a>mrgIte</a> through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; liftMrgIte2 mrgIte mrgIte "a" ("b", "c") ("d", "e") :: (SymInteger, SymBool)
--   ((ite a b d),(ite a c e))
--   </pre>
liftMrgIte2 :: SimpleMergeable2 u => (SymBool -> a -> a -> a) -> (SymBool -> b -> b -> b) -> SymBool -> u a b -> u a b -> u a b

-- | Lift the standard <a>mrgIte</a> function through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIte2 "a" ("b", "c") ("d", "e") :: (SymInteger, SymBool)
--   ((ite a b d),(ite a c e))
--   </pre>
mrgIte2 :: (SimpleMergeable2 u, SimpleMergeable a, SimpleMergeable b) => SymBool -> u a b -> u a b -> u a b

-- | The arguments to the generic simple merging function.
data family SimpleMergeableArgs arity a

-- | Generic <a>SimpleMergeable</a> class.
class GSimpleMergeable arity (f :: Type -> Type)
gmrgIte :: GSimpleMergeable arity f => SimpleMergeableArgs arity a -> SymBool -> f a -> f a -> f a

-- | Generic <a>mrgIte</a> function.
genericMrgIte :: (Generic a, GSimpleMergeable Arity0 (Rep a)) => SymBool -> a -> a -> a

-- | Generic <a>liftMrgIte</a> function.
genericLiftMrgIte :: (Generic1 f, GSimpleMergeable Arity1 (Rep1 f)) => (SymBool -> a -> a -> a) -> SymBool -> f a -> f a -> f a

-- | Special case of the <a>Mergeable1</a> and <a>SimpleMergeable1</a>
--   class for type constructors that are <a>SimpleMergeable</a> when
--   applied to any <a>Mergeable</a> types.
--   
--   This type class is used to generalize the <a>mrgIf</a> function to
--   other containers, for example, monad transformer transformed Unions.
class (SimpleMergeable1 u, forall a. Mergeable a => SimpleMergeable u a, TryMerge u) => SymBranching (u :: Type -> Type)

-- | Symbolic <tt>if</tt> control flow with the result merged with some
--   merge strategy.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfWithStrategy rootStrategy "a" (mrgSingle "b") (return "c") :: Union SymInteger
--   {(ite a b c)}
--   </pre>
--   
--   <b>Note:</b> Be careful to call this directly in your code. The
--   supplied merge strategy should be consistent with the type's root
--   merge strategy, or some internal invariants would be broken and the
--   program can crash.
--   
--   This function is to be called when the <a>Mergeable</a> constraint can
--   not be resolved, e.g., the merge strategy for the contained type is
--   given with <a>Mergeable1</a>. In other cases, <a>mrgIf</a> is usually
--   a better alternative.
mrgIfWithStrategy :: SymBranching u => MergingStrategy a -> SymBool -> u a -> u a -> u a

-- | Symbolic <tt>if</tt> control flow with the result.
--   
--   This function does not need a merging strategy, and it will merge the
--   result only if any of the branches is merged.
mrgIfPropagatedStrategy :: SymBranching u => SymBool -> u a -> u a -> u a

-- | Symbolic <tt>if</tt> control flow with the result merged with the
--   type's root merge strategy.
--   
--   Equivalent to <tt><a>mrgIfWithStrategy</a> <a>rootStrategy</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIf "a" (return "b") (return "c") :: Union SymInteger
--   {(ite a b c)}
--   </pre>
mrgIf :: (SymBranching u, Mergeable a) => SymBool -> u a -> u a -> u a

-- | Try to merge the container with a given merge strategy.
mergeWithStrategy :: SymBranching m => MergingStrategy a -> m a -> m a

-- | Try to merge the container with the root strategy.
merge :: (SymBranching m, Mergeable a) => m a -> m a


module Grisette.Internal.Core.Control.Monad.Class.Union

-- | Class for monads that support union-like operations and
--   <a>Mergeable</a> knowledge propagation.
type MonadUnion (u :: Type -> Type) = (SymBranching u, Monad u)


module Grisette.Internal.Core.Data.Class.SafeBitCast

-- | Bitcasting a value. If the value cannot be precisely bitcast, throw an
--   error.
class (MonadError e m, TryMerge m, Mergeable b, BitCastOr a b) => SafeBitCast e a b (m :: Type -> Type)
safeBitCast :: SafeBitCast e a b m => a -> m b
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr a b => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr a b => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b
instance Grisette.Internal.Core.Data.Class.BitCast.BitCastOr a b => Grisette.Internal.Core.Data.Class.BitCast.BitCastOr a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP64 GHC.Types.Double m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP32 GHC.Types.Float m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP16 GHC.Internal.Int.Int16 m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP32 GHC.Internal.Int.Int32 m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP64 GHC.Internal.Int.Int64 m
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), GHC.Internal.TypeNats.KnownNat r, 1 GHC.Internal.Data.Type.Ord.<= r, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.IntN r) m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP16 GHC.Internal.Word.Word16 m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP32 GHC.Internal.Word.Word32 m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.FP.FP64 GHC.Internal.Word.Word64 m
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), GHC.Internal.TypeNats.KnownNat r, 1 GHC.Internal.Data.Type.Ord.<= r, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.WordN r) m
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), GHC.Internal.TypeNats.KnownNat r, 1 GHC.Internal.Data.Type.Ord.<= r, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymIntN r) m
instance (Grisette.Internal.SymPrim.FP.ValidFP eb sb, r GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb), GHC.Internal.TypeNats.KnownNat r, 1 GHC.Internal.Data.Type.Ord.<= r, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m) => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymWordN r) m
instance Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e a b m => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b) m
instance Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e a b m => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b m
instance Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e a b m => Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b) m


module Grisette.Internal.Core.Data.Class.Error

-- | This class indicates that the error type <tt>to</tt> can always
--   represent the error type <tt>from</tt>.
--   
--   This is useful in implementing generic procedures that may throw
--   errors. For example, we support symbolic division and modulo
--   operations. These operations should throw an error when the divisor is
--   zero, and we use the standard error type <a>ArithException</a> for
--   this purpose. However, the user may use other type to represent
--   errors, so we need this type class to transform the
--   <a>ArithException</a> to the user-defined types.
--   
--   Another example of these generic procedures is the <a>symAssert</a>
--   and <a>symAssume</a> functions. They can be used with any error types
--   that are compatible with the <a>AssertionError</a> and
--   <a>VerificationConditions</a> types, respectively.
class TransformError from to

-- | Transforms an error with type <tt>from</tt> to an error with type
--   <tt>to</tt>.
transformError :: TransformError from to => from -> to

-- | Symbolic assertion with a custom error.
symAssertWith :: (Mergeable e, MonadError e erm, MonadUnion erm) => e -> SymBool -> erm ()

-- | Used within a monadic multi path computation for exception processing.
--   
--   Terminate the current execution path with the specified error if the
--   condition does not hold. Compatible error can be transformed.
--   
--   <pre>
--   &gt;&gt;&gt; let assert = symAssertTransformableError AssertionError :: SymBool -&gt; ExceptT AssertionError Union ()
--   
--   &gt;&gt;&gt; assert "a"
--   ExceptT {If (! a) (Left AssertionError) (Right ())}
--   </pre>
symAssertTransformableError :: (Mergeable to, TransformError from to, MonadError to erm, MonadUnion erm) => from -> SymBool -> erm ()

-- | Used within a monadic multi path computation to begin exception
--   processing.
--   
--   Terminate the current execution path with the specified error.
--   Compatible errors can be transformed.
--   
--   <pre>
--   &gt;&gt;&gt; symThrowTransformableError Overflow :: ExceptT AssertionError Union ()
--   ExceptT {Left AssertionError}
--   </pre>
symThrowTransformableError :: (Mergeable to, Mergeable a, TransformError from to, MonadError to erm, MonadUnion erm) => from -> erm a

-- | Used within a monadic multi path computation to begin exception
--   processing.
--   
--   Checks the condition passed to the function. The current execution
--   path will be terminated with assertion error if the condition is
--   false.
--   
--   If the condition is symbolic, Grisette will split the execution into
--   two paths based on the condition. The symbolic execution will continue
--   on the then-branch, where the condition is true. For the else branch,
--   where the condition is false, the execution will be terminated.
--   
--   The resulting monadic environment should be compatible with the
--   <a>AssertionError</a> error type. See <a>TransformError</a> type class
--   for details.
--   
--   <b><i>Examples</i></b>:
--   
--   Terminates the execution if the condition is false. Note that we may
--   lose the <a>Mergeable</a> knowledge here if no possible execution path
--   is viable. This may affect the efficiency in theory, but in practice
--   this should not be a problem as all paths are terminated and no
--   further evaluation would be performed.
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (con False) :: ExceptT AssertionError Union ()
--   ExceptT {Left AssertionError}
--   
--   &gt;&gt;&gt; do; symAssert (con False); mrgReturn 1 :: ExceptT AssertionError Union Integer
--   ExceptT &lt;Left AssertionError&gt;
--   </pre>
--   
--   No effect if the condition is true:
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (con True) :: ExceptT AssertionError Union ()
--   ExceptT {Right ()}
--   
--   &gt;&gt;&gt; do; symAssert (con True); mrgReturn 1 :: ExceptT AssertionError Union Integer
--   ExceptT {Right 1}
--   </pre>
--   
--   Splitting the path and terminate one of them when the condition is
--   symbolic.
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (ssym "a") :: ExceptT AssertionError Union ()
--   ExceptT {If (! a) (Left AssertionError) (Right ())}
--   
--   &gt;&gt;&gt; do; symAssert (ssym "a"); mrgReturn 1 :: ExceptT AssertionError Union Integer
--   ExceptT {If (! a) (Left AssertionError) (Right 1)}
--   </pre>
--   
--   <a>AssertionError</a> is compatible with
--   <a>VerificationConditions</a>:
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (ssym "a") :: ExceptT VerificationConditions Union ()
--   ExceptT {If (! a) (Left AssertionViolation) (Right ())}
--   </pre>
symAssert :: (TransformError AssertionError to, Mergeable to, MonadError to erm, MonadUnion erm) => SymBool -> erm ()

-- | Used within a monadic multi path computation to begin exception
--   processing.
--   
--   Similar to <a>symAssert</a>, but terminates the execution path with
--   <a>AssumptionViolation</a> error.
--   
--   <i>Examples</i>:
--   
--   <pre>
--   &gt;&gt;&gt; symAssume (ssym "a") :: ExceptT VerificationConditions Union ()
--   ExceptT {If (! a) (Left AssumptionViolation) (Right ())}
--   </pre>
symAssume :: (TransformError VerificationConditions to, Mergeable to, MonadError to erm, MonadUnion erm) => SymBool -> erm ()
instance Grisette.Internal.Core.Data.Class.Error.TransformError GHC.Internal.Exception.Type.ArithException Grisette.Internal.Core.Control.Exception.AssertionError
instance Grisette.Internal.Core.Data.Class.Error.TransformError GHC.Internal.IO.Exception.ArrayException Grisette.Internal.Core.Control.Exception.AssertionError
instance Grisette.Internal.Core.Data.Class.Error.TransformError Grisette.Internal.Core.Control.Exception.AssertionError Grisette.Internal.Core.Control.Exception.AssertionError
instance Grisette.Internal.Core.Data.Class.Error.TransformError Grisette.Internal.Core.Control.Exception.AssertionError Grisette.Internal.Core.Control.Exception.VerificationConditions
instance Grisette.Internal.Core.Data.Class.Error.TransformError () ()
instance Grisette.Internal.Core.Data.Class.Error.TransformError Grisette.Internal.Core.Control.Exception.VerificationConditions Grisette.Internal.Core.Control.Exception.VerificationConditions
instance Grisette.Internal.Core.Data.Class.Error.TransformError a ()
instance Grisette.Internal.Core.Data.Class.Error.TransformError a a


module Grisette.Internal.Core.Data.Class.ExtractSym

-- | Extracts all the symbols (symbolic constants) that are transitively
--   contained in the given value.
--   
--   <pre>
--   &gt;&gt;&gt; extractSym ("a" :: SymBool)
--   SymbolSet {a :: Bool}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractSym (mrgIf "a" (mrgReturn ["b"]) (mrgReturn ["c", "d"]) :: Union [SymBool])
--   SymbolSet {a :: Bool, b :: Bool, c :: Bool, d :: Bool}
--   </pre>
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving ExtractSym via (Default X)
--   </pre>
class ExtractSym a
extractSym :: ExtractSym a => a -> AnySymbolSet
extractSymMaybe :: forall (knd :: SymbolKind). (ExtractSym a, IsSymbolKind knd) => a -> Maybe (SymbolSet knd)

-- | Lifting of <a>ExtractSym</a> to unary type constructors.
class forall a. ExtractSym a => ExtractSym f a => ExtractSym1 (f :: Type -> Type)

-- | Lifts the <a>extractSymMaybe</a> function to unary type constructors.
liftExtractSymMaybe :: forall (knd :: SymbolKind) a. (ExtractSym1 f, IsSymbolKind knd) => (a -> Maybe (SymbolSet knd)) -> f a -> Maybe (SymbolSet knd)

-- | Lift the standard <a>extractSymMaybe</a> to unary type constructors.
extractSymMaybe1 :: forall f a (knd :: SymbolKind). (ExtractSym1 f, ExtractSym a, IsSymbolKind knd) => f a -> Maybe (SymbolSet knd)

-- | Lift the standard <a>extractSym</a> to unary type constructors.
extractSym1 :: forall f a (knd :: SymbolKind). (ExtractSym1 f, ExtractSym a, IsSymbolKind knd) => f a -> SymbolSet knd

-- | Lifting of <a>ExtractSym</a> to binary type constructors.
class forall a. ExtractSym a => ExtractSym1 f a => ExtractSym2 (f :: Type -> Type -> Type)

-- | Lifts the <a>extractSymMaybe</a> function to binary type constructors.
liftExtractSymMaybe2 :: forall (knd :: SymbolKind) a b. (ExtractSym2 f, IsSymbolKind knd) => (a -> Maybe (SymbolSet knd)) -> (b -> Maybe (SymbolSet knd)) -> f a b -> Maybe (SymbolSet knd)

-- | Lift the standard <a>extractSymMaybe</a> to binary type constructors.
extractSymMaybe2 :: forall f a b (knd :: SymbolKind). (ExtractSym2 f, ExtractSym a, ExtractSym b, IsSymbolKind knd) => f a b -> Maybe (SymbolSet knd)

-- | Lift the standard <a>extractSym</a> to binary type constructors.
extractSym2 :: forall f a b (knd :: SymbolKind). (ExtractSym2 f, ExtractSym a, ExtractSym b, IsSymbolKind knd) => f a b -> SymbolSet knd

-- | The arguments to the generic <a>extractSym</a> function.
data family ExtractSymArgs arity (knd :: SymbolKind) a

-- | The class of types that can generically extract the symbols.
class GExtractSym arity (f :: Type -> Type)
gextractSymMaybe :: forall (knd :: SymbolKind) a. (GExtractSym arity f, IsSymbolKind knd) => ExtractSymArgs arity knd a -> f a -> Maybe (SymbolSet knd)

-- | Generic <a>extractSym</a> function.
genericExtractSymMaybe :: forall a (knd :: SymbolKind). (Generic a, GExtractSym Arity0 (Rep a), IsSymbolKind knd) => a -> Maybe (SymbolSet knd)

-- | Generic <a>liftExtractSymMaybe</a> function.
genericLiftExtractSymMaybe :: forall f (knd :: SymbolKind) a. (Generic1 f, GExtractSym Arity1 (Rep1 f), IsSymbolKind knd) => (a -> Maybe (SymbolSet knd)) -> f a -> Maybe (SymbolSet knd)


module Grisette.Internal.Core.Data.Class.Solver

-- | The current failures that can be returned by the solver.
data SolvingFailure

-- | Unsatisfiable: No model is available.
Unsat :: SolvingFailure

-- | Unknown: The solver cannot determine whether the formula is
--   satisfiable.
Unk :: SolvingFailure

-- | The solver has reached the maximum number of models to return.
ResultNumLimitReached :: SolvingFailure

-- | The solver has encountered an error.
SolvingError :: Text -> SolvingFailure

-- | The solver has been terminated.
Terminated :: SolvingFailure

-- | A monadic solver interface.
--   
--   This interface abstract the monadic interface of a solver. All the
--   operations performed in the monad are using a single solver instance.
--   The solver instance is management by the monad's <tt>run</tt>
--   function.
class Monad m => MonadicSolver (m :: Type -> Type)
monadicSolverPush :: MonadicSolver m => Int -> m ()
monadicSolverPop :: MonadicSolver m => Int -> m ()
monadicSolverResetAssertions :: MonadicSolver m => m ()
monadicSolverAssert :: MonadicSolver m => SymBool -> m ()
monadicSolverCheckSat :: MonadicSolver m => m (Either SolvingFailure Model)

-- | Solve a single formula with a monadic solver. Find an assignment to it
--   to make it true.
monadicSolverSolve :: MonadicSolver m => SymBool -> m (Either SolvingFailure Model)

-- | The commands that can be sent to a solver.
data SolverCommand
SolverAssert :: !SymBool -> SolverCommand
SolverCheckSat :: SolverCommand
SolverPush :: Int -> SolverCommand
SolverPop :: Int -> SolverCommand
SolverResetAssertions :: SolverCommand
SolverTerminate :: SolverCommand

-- | A class that abstracts the creation of a solver instance based on a
--   configuration.
--   
--   The solver instance will need to be terminated by the user, with the
--   solver interface.
class Solver handle => ConfigurableSolver config handle | config -> handle
newSolver :: ConfigurableSolver config handle => config -> IO handle

-- | A class that abstracts the solver interface.
class Solver handle

-- | Run a solver command.
solverRunCommand :: Solver handle => (handle -> IO (Either SolvingFailure a)) -> handle -> SolverCommand -> IO (Either SolvingFailure a)

-- | Assert a formula.
solverAssert :: Solver handle => handle -> SymBool -> IO (Either SolvingFailure ())

-- | Solve a formula.
solverCheckSat :: Solver handle => handle -> IO (Either SolvingFailure Model)

-- | Push <tt>n</tt> levels.
solverPush :: Solver handle => handle -> Int -> IO (Either SolvingFailure ())

-- | Pop <tt>n</tt> levels.
solverPop :: Solver handle => handle -> Int -> IO (Either SolvingFailure ())

-- | Reset all assertions in the solver.
--   
--   The solver keeps all the assertions used in the previous commands:
--   
--   <pre>
--   &gt;&gt;&gt; solver &lt;- newSolver z3
--   
--   &gt;&gt;&gt; solverSolve solver "a"
--   Right (Model {a -&gt; true :: Bool})
--   
--   &gt;&gt;&gt; solverSolve solver $ symNot "a"
--   Left Unsat
--   </pre>
--   
--   You can clear the assertions using <tt>solverResetAssertions</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; solverResetAssertions solver
--   Right ()
--   
--   &gt;&gt;&gt; solverSolve solver $ symNot "a"
--   Right (Model {a -&gt; false :: Bool})
--   </pre>
solverResetAssertions :: Solver handle => handle -> IO (Either SolvingFailure ())

-- | Terminate the solver, wait until the last command is finished.
solverTerminate :: Solver handle => handle -> IO ()

-- | Force terminate the solver, do not wait for the last command to
--   finish.
solverForceTerminate :: Solver handle => handle -> IO ()

-- | Solve a single formula. Find an assignment to it to make it true.
solverSolve :: Solver handle => handle -> SymBool -> IO (Either SolvingFailure Model)

-- | Start a solver, run a computation with the solver, and terminate the
--   solver after the computation finishes.
--   
--   When an exception happens, this will forcibly terminate the solver.
--   
--   Note: if Grisette is compiled with sbv &lt; 10.10, the solver likely
--   won't be really terminated until it has finished the last action, and
--   this will result in long-running or zombie solver instances.
--   
--   This was due to a bug in sbv, which is fixed in
--   <a>https://github.com/LeventErkok/sbv/pull/695</a>.
withSolver :: ConfigurableSolver config handle => config -> (handle -> IO a) -> IO a

-- | Solve a single formula. Find an assignment to it to make it true.
--   
--   <pre>
--   &gt;&gt;&gt; solve z3 ("a" .&amp;&amp; ("b" :: SymInteger) .== 1)
--   Right (Model {a -&gt; true :: Bool, b -&gt; 1 :: Integer})
--   
--   &gt;&gt;&gt; solve z3 ("a" .&amp;&amp; symNot "a")
--   Left Unsat
--   </pre>
solve :: ConfigurableSolver config handle => config -> SymBool -> IO (Either SolvingFailure Model)

-- | Solve a single formula while returning multiple models to make it
--   true. The maximum number of desired models are given.
solverSolveMulti :: Solver handle => handle -> Int -> SymBool -> IO ([Model], SolvingFailure)

-- | Solve a single formula while returning multiple models to make it
--   true. The maximum number of desired models are given.
--   
--   <pre>
--   &gt;&gt;&gt; solveMulti z3 4 ("a" .|| "b")
--   [Model {a -&gt; True :: Bool, b -&gt; False :: Bool},Model {a -&gt; False :: Bool, b -&gt; True :: Bool},Model {a -&gt; True :: Bool, b -&gt; True :: Bool}]
--   </pre>
solveMulti :: ConfigurableSolver config handle => config -> Int -> SymBool -> IO ([Model], SolvingFailure)

-- | A class that abstracts the union-like structures that contains
--   exceptions.
class UnionWithExcept t (u :: Type -> Type) e v | t -> u e v

-- | Extract a union of exceptions and values from the structure.
extractUnionExcept :: UnionWithExcept t u e v => t -> u (Either e v)

-- | Solver procedure for programs with error handling.
solverSolveExcept :: forall t (u :: Type -> Type) e v handle. (UnionWithExcept t u e v, UnionView u, Functor u, Solver handle) => handle -> (Either e v -> SymBool) -> t -> IO (Either SolvingFailure Model)

-- | Solver procedure for programs with error handling.
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   
--   &gt;&gt;&gt; let x = "x" :: SymInteger
--   
--   &gt;&gt;&gt; :{
--     res :: ExceptT AssertionError Union ()
--     res = do
--       symAssert $ x .&gt; 0       -- constrain that x is positive
--       symAssert $ x .&lt; 2       -- constrain that x is less than 2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     translate (Left _) = con False -- errors are not desirable
--     translate _ = con True         -- non-errors are desirable
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solveExcept z3 translate res
--   Right (Model {x -&gt; 1 :: Integer})
--   </pre>
solveExcept :: forall t (u :: Type -> Type) e v config handle. (UnionWithExcept t u e v, UnionView u, Functor u, ConfigurableSolver config handle) => config -> (Either e v -> SymBool) -> t -> IO (Either SolvingFailure Model)

-- | Solver procedure for programs with error handling. Would return
--   multiple models if possible.
solverSolveMultiExcept :: forall t (u :: Type -> Type) e v handle. (UnionWithExcept t u e v, UnionView u, Functor u, Solver handle) => handle -> Int -> (Either e v -> SymBool) -> t -> IO ([Model], SolvingFailure)

-- | Solver procedure for programs with error handling. Would return
--   multiple models if possible.
solveMultiExcept :: forall t (u :: Type -> Type) e v config handle. (UnionWithExcept t u e v, UnionView u, Functor u, ConfigurableSolver config handle) => config -> Int -> (Either e v -> SymBool) -> t -> IO ([Model], SolvingFailure)


module Grisette.Internal.Backend.Solving

-- | Solver configuration for the Grisette SBV backend.
--   
--   A Grisette solver configuration consists of a SBV solver configuration
--   and some extra configurations.
--   
--   You should start with the predefined configurations.
data GrisetteSMTConfig
GrisetteSMTConfig :: SMTConfig -> ExtraConfig -> GrisetteSMTConfig
[sbvConfig] :: GrisetteSMTConfig -> SMTConfig
[extraConfig] :: GrisetteSMTConfig -> ExtraConfig

-- | Solver configuration for Boolector.
--   <a>https://boolector.github.io/</a>
boolector :: GrisetteSMTConfig

-- | Solver configuration for Bitwuzla. <a>https://bitwuzla.github.io/</a>
bitwuzla :: GrisetteSMTConfig

-- | Solver configuration for CVC4. <a>https://cvc4.github.io/</a>
cvc4 :: GrisetteSMTConfig

-- | Solver configuration for CVC5. <a>https://cvc5.github.io/</a>
cvc5 :: GrisetteSMTConfig

-- | Solver configuration for Yices. <a>https://yices.csl.sri.com/</a>
yices :: GrisetteSMTConfig

-- | Solver configuration for DReal. <a>http://dreal.github.io/</a>
dReal :: GrisetteSMTConfig

-- | Solver configuration for Z3. <a>https://github.com/Z3Prover/z3/</a>
z3 :: GrisetteSMTConfig

-- | Solver configuration for MathSAT. <a>http://mathsat.fbk.eu/</a>
mathSAT :: GrisetteSMTConfig

-- | Solver configuration for ABC.
--   <a>http://www.eecs.berkeley.edu/~alanmi/abc/</a>
abc :: GrisetteSMTConfig

-- | Grisette specific extra configurations for the SBV backend.
newtype ExtraConfig
ExtraConfig :: Maybe Int -> ExtraConfig

-- | Timeout in microseconds for each solver call. CEGIS may call the
--   solver multiple times and each call has its own timeout.
[timeout] :: ExtraConfig -> Maybe Int

-- | Set the timeout for the solver configuration.
--   
--   The timeout is in microseconds (1e-6 seconds). The timeout is applied
--   to each individual solver query.
withTimeout :: Int -> GrisetteSMTConfig -> GrisetteSMTConfig

-- | Clear the timeout for the solver configuration.
clearTimeout :: GrisetteSMTConfig -> GrisetteSMTConfig

-- | Incremental solver monad transformer with the SBV backend.
type SBVIncrementalT (m :: Type -> Type) = ReaderT GrisetteSMTConfig StateT SymBiMap QueryT m

-- | Incremental solver monad with the SBV backend.
type SBVIncremental = SBVIncrementalT IO

-- | Run the incremental solver monad transformer with a given
--   configuration.
runSBVIncrementalT :: ExtractIO m => GrisetteSMTConfig -> SBVIncrementalT m a -> m a

-- | Run the incremental solver monad with a given configuration.
runSBVIncremental :: GrisetteSMTConfig -> SBVIncremental a -> IO a

-- | The handle type for the SBV solver.
--   
--   See <a>ConfigurableSolver</a> and <a>Solver</a> for the interfaces.
data SBVSolverHandle

-- | Lower a single primitive term to SBV. With an explicitly provided
--   <a>SymBiMap</a> cache.
lowerSinglePrimCached :: forall t m. (HasCallStack, SBVFreshMonad m) => Term t -> SymBiMap -> m (SymBiMap, QuantifiedStack -> SBVType t, SBool)

-- | Lower a single primitive term to SBV.
lowerSinglePrim :: forall a m. (HasCallStack, SBVFreshMonad m) => Term a -> m (SymBiMap, QuantifiedStack -> SBVType a, SBool)

-- | Parse an SBV model to a Grisette model.
parseModel :: GrisetteSMTConfig -> SMTModel -> SymBiMap -> Model
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.ConfigurableSolver Grisette.Internal.Backend.Solving.GrisetteSMTConfig Grisette.Internal.Backend.Solving.SBVSolverHandle
instance Control.Monad.IO.Class.MonadIO m => Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.MonadicSolver (Grisette.Internal.Backend.Solving.SBVIncrementalT m)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.Solver Grisette.Internal.Backend.Solving.SBVSolverHandle


module Grisette.Backend

-- | Solver configuration for the Grisette SBV backend.
--   
--   A Grisette solver configuration consists of a SBV solver configuration
--   and some extra configurations.
--   
--   You should start with the predefined configurations.
data GrisetteSMTConfig
GrisetteSMTConfig :: SMTConfig -> ExtraConfig -> GrisetteSMTConfig
[sbvConfig] :: GrisetteSMTConfig -> SMTConfig
[extraConfig] :: GrisetteSMTConfig -> ExtraConfig

-- | Solver configuration for Boolector.
--   <a>https://boolector.github.io/</a>
boolector :: GrisetteSMTConfig

-- | Solver configuration for Bitwuzla. <a>https://bitwuzla.github.io/</a>
bitwuzla :: GrisetteSMTConfig

-- | Solver configuration for CVC4. <a>https://cvc4.github.io/</a>
cvc4 :: GrisetteSMTConfig

-- | Solver configuration for CVC5. <a>https://cvc5.github.io/</a>
cvc5 :: GrisetteSMTConfig

-- | Solver configuration for Yices. <a>https://yices.csl.sri.com/</a>
yices :: GrisetteSMTConfig

-- | Solver configuration for DReal. <a>http://dreal.github.io/</a>
dReal :: GrisetteSMTConfig

-- | Solver configuration for Z3. <a>https://github.com/Z3Prover/z3/</a>
z3 :: GrisetteSMTConfig

-- | Solver configuration for MathSAT. <a>http://mathsat.fbk.eu/</a>
mathSAT :: GrisetteSMTConfig

-- | Solver configuration for ABC.
--   <a>http://www.eecs.berkeley.edu/~alanmi/abc/</a>
abc :: GrisetteSMTConfig

-- | Grisette specific extra configurations for the SBV backend.
newtype ExtraConfig
ExtraConfig :: Maybe Int -> ExtraConfig

-- | Timeout in microseconds for each solver call. CEGIS may call the
--   solver multiple times and each call has its own timeout.
[timeout] :: ExtraConfig -> Maybe Int

-- | Set the timeout for the solver configuration.
--   
--   The timeout is in microseconds (1e-6 seconds). The timeout is applied
--   to each individual solver query.
withTimeout :: Int -> GrisetteSMTConfig -> GrisetteSMTConfig

-- | Clear the timeout for the solver configuration.
clearTimeout :: GrisetteSMTConfig -> GrisetteSMTConfig

-- | Solver configuration. See also <a>z3</a>, <a>yices</a>, <a>cvc4</a>,
--   <a>boolector</a>, <a>mathSAT</a>, etc. which are instantiations of
--   this type for those solvers, with reasonable defaults. In particular,
--   custom configuration can be created by varying those values. (Such as
--   <tt>z3{verbose=True}</tt>.)
--   
--   Most fields are self explanatory. The notion of precision for printing
--   algebraic reals stems from the fact that such values does not
--   necessarily have finite decimal representations, and hence we have to
--   stop printing at some depth. It is important to emphasize that such
--   values always have infinite precision internally. The issue is merely
--   with how we print such an infinite precision value on the screen. The
--   field <a>printRealPrec</a> controls the printing precision, by
--   specifying the number of digits after the decimal point. The default
--   value is 16, but it can be set to any positive integer.
--   
--   When printing, SBV will add the suffix <tt>...</tt> at the end of a
--   real-value, if the given bound is not sufficient to represent the
--   real-value exactly. Otherwise, the number will be written out in
--   standard decimal notation. Note that SBV will always print the whole
--   value if it is precise (i.e., if it fits in a finite number of
--   digits), regardless of the precision limit. The limit only applies if
--   the representation of the real value is not finite, i.e., if it is not
--   rational.
--   
--   The <a>printBase</a> field can be used to print numbers in base 2, 10,
--   or 16.
--   
--   The <a>crackNum</a> field can be used to display numbers in detail,
--   all its bits and how they are laid out in memory. Works with all
--   bounded number types (i.e., SWord and SInt), but also with floats. It
--   is particularly useful with floating-point numbers, as it shows you
--   how they are laid out in memory following the IEEE754 rules.
data SMTConfig
SMTConfig :: Bool -> Timing -> Int -> Int -> Bool -> [(String, Integer)] -> String -> Maybe Int -> Bool -> Bool -> (String -> Bool) -> Bool -> Bool -> Maybe FilePath -> SMTLibVersion -> Maybe Double -> SMTSolver -> [String] -> RoundingMode -> [SMTOption] -> Bool -> Maybe FilePath -> Int -> SMTConfig

-- | Debug mode
[verbose] :: SMTConfig -> Bool

-- | Print timing information on how long different phases took
--   (construction, solving, etc.)
[timing] :: SMTConfig -> Timing

-- | Print integral literals in this base (2, 10, and 16 are supported.)
[printBase] :: SMTConfig -> Int

-- | Print algebraic real values with this precision. (SReal, default: 16)
[printRealPrec] :: SMTConfig -> Int

-- | For each numeric value, show it in detail in the model with its bits
--   spliced out. Good for floats.
[crackNum] :: SMTConfig -> Bool

-- | For crackNum: The surface representation of variables, if available
[crackNumSurfaceVals] :: SMTConfig -> [(String, Integer)]

-- | Usually "(check-sat)". However, users might tweak it based on solver
--   characteristics.
[satCmd] :: SMTConfig -> String

-- | In a <a>allSat</a> call, return at most this many models. If nothing,
--   return all.
[allSatMaxModelCount] :: SMTConfig -> Maybe Int

-- | In a <a>allSat</a> call, print models as they are found.
[allSatPrintAlong] :: SMTConfig -> Bool

-- | In a <a>allSat</a> call, should we try to extract values of
--   uninterpreted functions?
[allSatTrackUFs] :: SMTConfig -> Bool

-- | When constructing a model, ignore variables whose name satisfy this
--   predicate. (Default: (const False), i.e., don't ignore anything)
[isNonModelVar] :: SMTConfig -> String -> Bool

-- | If set, SBV will attempt to validate the model it gets back from the
--   solver.
[validateModel] :: SMTConfig -> Bool

-- | Validate optimization results. NB: Does NOT make sure the model is
--   optimal, just checks they satisfy the constraints.
[optimizeValidateConstraints] :: SMTConfig -> Bool

-- | If Just, the entire interaction will be recorded as a playable file
--   (for debugging purposes mostly)
[transcript] :: SMTConfig -> Maybe FilePath

-- | What version of SMT-lib we use for the tool
[smtLibVersion] :: SMTConfig -> SMTLibVersion

-- | Delta-sat precision
[dsatPrecision] :: SMTConfig -> Maybe Double

-- | The actual SMT solver.
[solver] :: SMTConfig -> SMTSolver

-- | Extra command line arguments to pass to the solver.
[extraArgs] :: SMTConfig -> [String]

-- | Rounding mode to use for floating-point conversions
[roundingMode] :: SMTConfig -> RoundingMode

-- | Options to set as we start the solver
[solverSetOptions] :: SMTConfig -> [SMTOption]

-- | If true, we shall ignore the exit code upon exit. Otherwise we require
--   ExitSuccess.
[ignoreExitCode] :: SMTConfig -> Bool

-- | Redirect the verbose output to this file if given. If Nothing, stdout
--   is implied.
[redirectVerbose] :: SMTConfig -> Maybe FilePath

-- | Line length for KD proofs
[kdRibbonLength] :: SMTConfig -> Int

-- | SMT-Lib logics. If left unspecified SBV will pick the logic based on
--   what it determines is needed. However, the user can override this
--   choice using a call to <a>setLogic</a> This is especially handy if one
--   is experimenting with custom logics that might be supported on new
--   solvers. See <a>https://smt-lib.org/logics.shtml</a> for the official
--   list.
data Logic

-- | Formulas over the theory of linear integer arithmetic and arrays
--   extended with free sort and function symbols but restricted to arrays
--   with integer indices and values.
AUFLIA :: Logic

-- | Linear formulas with free sort and function symbols over one- and
--   two-dimentional arrays of integer index and real value.
AUFLIRA :: Logic

-- | Formulas with free function and predicate symbols over a theory of
--   arrays of arrays of integer index and real value.
AUFNIRA :: Logic

-- | Linear formulas in linear real arithmetic.
LRA :: Logic

-- | Quantifier-free formulas over the theory of bitvectors and bitvector
--   arrays.
QF_ABV :: Logic

-- | Quantifier-free formulas over the theory of bitvectors and bitvector
--   arrays extended with free sort and function symbols.
QF_AUFBV :: Logic

-- | Quantifier-free linear formulas over the theory of integer arrays
--   extended with free sort and function symbols.
QF_AUFLIA :: Logic

-- | Quantifier-free formulas over the theory of arrays with
--   extensionality.
QF_AX :: Logic

-- | Quantifier-free formulas over the theory of fixed-size bitvectors.
QF_BV :: Logic

-- | Difference Logic over the integers. Boolean combinations of
--   inequations of the form x - y &lt; b where x and y are integer
--   variables and b is an integer constant.
QF_IDL :: Logic

-- | Unquantified linear integer arithmetic. In essence, Boolean
--   combinations of inequations between linear polynomials over integer
--   variables.
QF_LIA :: Logic

-- | Unquantified linear real arithmetic. In essence, Boolean combinations
--   of inequations between linear polynomials over real variables.
QF_LRA :: Logic

-- | Quantifier-free integer arithmetic.
QF_NIA :: Logic

-- | Quantifier-free real arithmetic.
QF_NRA :: Logic

-- | Difference Logic over the reals. In essence, Boolean combinations of
--   inequations of the form x - y &lt; b where x and y are real variables
--   and b is a rational constant.
QF_RDL :: Logic

-- | Unquantified formulas built over a signature of uninterpreted (i.e.,
--   free) sort and function symbols.
QF_UF :: Logic

-- | Unquantified formulas over bitvectors with uninterpreted sort function
--   and symbols.
QF_UFBV :: Logic

-- | Difference Logic over the integers (in essence) but with uninterpreted
--   sort and function symbols.
QF_UFIDL :: Logic

-- | Unquantified linear integer arithmetic with uninterpreted sort and
--   function symbols.
QF_UFLIA :: Logic

-- | Unquantified linear real arithmetic with uninterpreted sort and
--   function symbols.
QF_UFLRA :: Logic

-- | Unquantified non-linear real arithmetic with uninterpreted sort and
--   function symbols.
QF_UFNRA :: Logic

-- | Unquantified non-linear real integer arithmetic with uninterpreted
--   sort and function symbols.
QF_UFNIRA :: Logic

-- | Linear real arithmetic with uninterpreted sort and function symbols.
UFLRA :: Logic

-- | Non-linear integer arithmetic with uninterpreted sort and function
--   symbols.
UFNIA :: Logic

-- | Quantifier-free formulas over the theory of floating point numbers,
--   arrays, and bit-vectors.
QF_FPBV :: Logic

-- | Quantifier-free formulas over the theory of floating point numbers.
QF_FP :: Logic

-- | Quantifier-free finite domains.
QF_FD :: Logic

-- | Quantifier-free formulas over the theory of strings.
QF_S :: Logic

-- | The catch-all value.
Logic_ALL :: Logic

-- | Use this value when you want SBV to simply not set the logic.
Logic_NONE :: Logic

-- | In case you need a really custom string!
CustomLogic :: String -> Logic

-- | Option values that can be set in the solver, following the SMTLib
--   specification <a>https://smt-lib.org/language.shtml</a>.
--   
--   Note that not all solvers may support all of these!
--   
--   Furthermore, SBV doesn't support the following options allowed by
--   SMTLib.
--   
--   <ul>
--   <li><tt>:interactive-mode</tt> (Deprecated in SMTLib, use
--   <a>ProduceAssertions</a> instead.)</li>
--   <li><tt>:print-success</tt> (SBV critically needs this to be True in
--   query mode.)</li>
--   <li><tt>:produce-models</tt> (SBV always sets this option so it can
--   extract models.)</li>
--   <li><tt>:regular-output-channel</tt> (SBV always requires regular
--   output to come on stdout for query purposes.)</li>
--   <li><tt>:global-declarations</tt> (SBV always uses global declarations
--   since definitions are accumulative.)</li>
--   </ul>
--   
--   Note that <a>SetLogic</a> and <a>SetInfo</a> are, strictly speaking,
--   not SMTLib options. However, we treat it as such here uniformly, as it
--   fits better with how options work.
data SMTOption
DiagnosticOutputChannel :: FilePath -> SMTOption
ProduceAssertions :: Bool -> SMTOption
ProduceAssignments :: Bool -> SMTOption
ProduceProofs :: Bool -> SMTOption
ProduceInterpolants :: Bool -> SMTOption
ProduceUnsatAssumptions :: Bool -> SMTOption
ProduceUnsatCores :: Bool -> SMTOption
ProduceAbducts :: Bool -> SMTOption
RandomSeed :: Integer -> SMTOption
ReproducibleResourceLimit :: Integer -> SMTOption
SMTVerbosity :: Integer -> SMTOption
OptionKeyword :: String -> [String] -> SMTOption
SetLogic :: Logic -> SMTOption
SetInfo :: String -> [String] -> SMTOption

-- | Specify how to save timing information, if at all.
data Timing
NoTiming :: Timing
PrintTiming :: Timing
SaveTiming :: IORef NominalDiffTime -> Timing

-- | An SMT solver
data SMTSolver
SMTSolver :: Solver -> String -> (String -> String) -> (SMTConfig -> [String]) -> SMTEngine -> SolverCapabilities -> SMTSolver

-- | The solver in use
[name] :: SMTSolver -> Solver

-- | The path to its executable
[executable] :: SMTSolver -> String

-- | Each line sent to the solver will be passed through this function
--   (typically id)
[preprocess] :: SMTSolver -> String -> String

-- | Options to provide to the solver
[options] :: SMTSolver -> SMTConfig -> [String]

-- | The solver engine, responsible for interpreting solver output
[engine] :: SMTSolver -> SMTEngine

-- | Various capabilities of the solver
[capabilities] :: SMTSolver -> SolverCapabilities


module Grisette.Internal.Core.Data.Class.EvalSym

-- | Evaluating symbolic values with some model. This would substitute the
--   symbols (symbolic constants) with the values in the model.
--   
--   <pre>
--   &gt;&gt;&gt; let model = insertValue "a" (1 :: Integer) emptyModel :: Model
--   
--   &gt;&gt;&gt; evalSym False model ([ssym "a", ssym "b"] :: [SymInteger])
--   [1,b]
--   </pre>
--   
--   If we set the first argument true, the missing symbols will be filled
--   in with some default values:
--   
--   <pre>
--   &gt;&gt;&gt; evalSym True model ([ssym "a", ssym "b"] :: [SymInteger])
--   [1,0]
--   </pre>
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving EvalSym via (Default X)
--   </pre>
class EvalSym a

-- | Evaluate a symbolic value with some model, possibly fill in values for
--   the missing symbols.
evalSym :: EvalSym a => Bool -> Model -> a -> a

-- | Evaluate a symbolic value with some model, fill in values for the
--   missing symbols, and convert the result to a concrete value.
--   
--   <pre>
--   &gt;&gt;&gt; let model = insertValue "a" (1 :: Integer) emptyModel :: Model
--   
--   &gt;&gt;&gt; evalSymToCon model ([ssym "a", ssym "b"] :: [SymInteger]) :: [Integer]
--   [1,0]
--   </pre>
evalSymToCon :: (ToCon a b, EvalSym a) => Model -> a -> b

-- | Lifting of <a>EvalSym</a> to unary type constructors.
class forall a. EvalSym a => EvalSym f a => EvalSym1 (f :: Type -> Type)

-- | Lift the <a>evalSym</a> function to unary type constructors.
liftEvalSym :: EvalSym1 f => (Bool -> Model -> a -> a) -> Bool -> Model -> f a -> f a

-- | Lifting the standard <a>evalSym</a> to unary type constructors.
evalSym1 :: (EvalSym1 f, EvalSym a) => Bool -> Model -> f a -> f a

-- | Evaluate and convert to concrete values with lifted standard
--   <a>evalSym</a> for unary type constructors. See <a>evalSymToCon</a>.
evalSymToCon1 :: (EvalSym1 f, EvalSym a, ToCon1 f g, ToCon a b) => Model -> f a -> g b

-- | Lifting of <a>EvalSym1</a> to binary type constructors.
class forall a. EvalSym a => EvalSym1 f a => EvalSym2 (f :: Type -> Type -> Type)

-- | Lift the <a>evalSym</a> function to binary type constructors.
liftEvalSym2 :: EvalSym2 f => (Bool -> Model -> a -> a) -> (Bool -> Model -> b -> b) -> Bool -> Model -> f a b -> f a b

-- | Lifting the standard <a>evalSym</a> to binary type constructors.
evalSym2 :: (EvalSym2 f, EvalSym a, EvalSym b) => Bool -> Model -> f a b -> f a b

-- | Evaluate and convert to concrete values with lifted standard
--   <a>evalSym</a> for binary type constructors. See <a>evalSymToCon</a>.
evalSymToCon2 :: (EvalSym2 f, EvalSym a, EvalSym c, ToCon2 f g, ToCon a b, ToCon c d) => Model -> f a c -> g b d

-- | The arguments to the generic <a>evalSym</a> function.
data family EvalSymArgs arity a

-- | The class of types that can be generically evaluated.
class GEvalSym arity (f :: Type -> Type)
gevalSym :: GEvalSym arity f => EvalSymArgs arity a -> Bool -> Model -> f a -> f a

-- | Generic <a>evalSym</a> function.
genericEvalSym :: (Generic a, GEvalSym Arity0 (Rep a)) => Bool -> Model -> a -> a

-- | Generic <a>liftEvalSym</a> function.
genericLiftEvalSym :: (Generic1 f, GEvalSym Arity1 (Rep1 f)) => (Bool -> Model -> a -> a) -> Bool -> Model -> f a -> f a


module Grisette.Internal.Core.Control.Monad.Union

-- | <a>Union</a> is the <a>UnionBase</a> container (hidden) enhanced with
--   <a>MergingStrategy</a> <a>knowledge propagation</a>.
--   
--   The <a>UnionBase</a> models the underlying semantics evaluation
--   semantics for unsolvable types with the nested if-then-else tree
--   semantics, and can be viewed as the following structure:
--   
--   <pre>
--   data UnionBase a
--     = UnionSingle a
--     | UnionIf bool (Union a) (Union a)
--   </pre>
--   
--   The <a>UnionSingle</a> constructor is for a single value with the path
--   condition <tt>true</tt>, and the <a>UnionIf</a> constructor is the if
--   operator in an if-then-else tree. For clarity, when printing a
--   <a>Union</a> value, we will omit the <a>UnionSingle</a> constructor.
--   The following two representations has the same semantics.
--   
--   <pre>
--   If      c1    (If c11 v11 (If c12 v12 v13))
--     (If   c2    v2
--                 v3)
--   </pre>
--   
--   &lt;math&gt;
--   
--   To reduce the size of the if-then-else tree to reduce the number of
--   paths to execute, Grisette would merge the branches in a
--   <a>UnionBase</a> container and maintain a representation invariant for
--   them. To perform this merging procedure, Grisette relies on a type
--   class called <a>Mergeable</a> and the merging strategy defined by it.
--   
--   <a>UnionBase</a> is a monad, so we can easily write code with the
--   do-notation and monadic combinators. However, the standard monadic
--   operators cannot resolve any extra constraints, including the
--   <a>Mergeable</a> constraint (see <a>The constrained-monad problem</a>
--   by Sculthorpe et al.). This prevents the standard do-notations to
--   merge the results automatically, and would result in bad performance
--   or very verbose code.
--   
--   To reduce this boilerplate, Grisette provide another monad,
--   <a>Union</a> that would try to cache the merging strategy. The
--   <a>Union</a> has a data constructor (hidden intentionally) that
--   maintains an optional <a>MergingStrategy</a> and a <a>UnionBase</a>.
--   When the optional <a>MergingStrategy</a> presents (printed as
--   <tt>{...}</tt>), the <a>UnionBase</a> must have already been merged.
--   When the optional <a>MergingStrategy</a> is absent (printed as
--   <tt><a>...</a></tt>), the <a>UnionBase</a> does not guarantee to be
--   merged. When used in monadic context, Grisette would try to use this
--   cached merging strategy to merge the result, as the <a>&gt;&gt;=</a>
--   operator itself cannot resolve the <a>Mergeable</a> constraint.
--   
--   <b><i>Examples:</i></b>
--   
--   <a>return</a> cannot resolve the <a>Mergeable</a> constraint.
--   
--   <pre>
--   &gt;&gt;&gt; return 1 :: Union Integer
--   &lt;1&gt;
--   </pre>
--   
--   <a>mrgReturn</a> can resolve the <a>Mergeable</a> constraint.
--   
--   <pre>
--   &gt;&gt;&gt; import Grisette.Lib.Base
--   
--   &gt;&gt;&gt; mrgReturn 1 :: Union Integer
--   {1}
--   </pre>
--   
--   <a>mrgIfPropagatedStrategy</a> does not try to <a>Mergeable</a>
--   constraint.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfPropagatedStrategy "a" (return 1) (mrgIfPropagatedStrategy "b" (return 1) (return 2)) :: Union Integer
--   &lt;If a 1 (If b 1 2)&gt;
--   </pre>
--   
--   But <a>mrgIfPropagatedStrategy</a> is able to merge the result if some
--   of the branches are merged and have a cached merging strategy:
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfPropagatedStrategy "a" (return 1) (mrgIfPropagatedStrategy "b" (mrgReturn 1) (return 2)) :: Union Integer
--   {If (|| a b) 1 2}
--   </pre>
--   
--   The <a>&gt;&gt;=</a> operator uses <a>mrgIfPropagatedStrategy</a>
--   internally. When the final statement in a do-block merges the values,
--   the system can then merge the final result.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     do
--       x &lt;- mrgIfPropagatedStrategy (ssym "a") (return 1) (mrgIfPropagatedStrategy (ssym "b") (return 1) (return 2))
--       mrgSingle $ x + 1 :: Union Integer
--   :}
--   {If (|| a b) 2 3}
--   </pre>
--   
--   Calling a function that merges a result at the last line of a
--   do-notation will also merge the whole block. If you stick to these
--   <tt>mrg*</tt> combinators and all the functions will merge the
--   results, the whole program can be symbolically evaluated efficiently.
--   
--   <pre>
--   &gt;&gt;&gt; f x y = mrgIf "c" x y :: Union Integer
--   
--   &gt;&gt;&gt; :{
--     do
--       x &lt;- mrgIfPropagatedStrategy (ssym "a") (return 1) (mrgIfPropagatedStrategy (ssym "b") (return 1) (return 2))
--       f x (x + 1)
--   :}
--   {If (&amp;&amp; c (|| a b)) 1 (If (|| a (|| b c)) 2 3)}
--   </pre>
--   
--   In <a>Grisette.Lib.Base</a>, <a>Grisette.Lib.Mtl</a>, we also provided
--   more <tt>mrg*</tt> variants of other combinators. You should stick to
--   these combinators to ensure efficient merging by Grisette.
data Union a
Union :: Maybe (MergingStrategy a) -> UnionBase a -> Union a
[unionMergingStrategy] :: Union a -> Maybe (MergingStrategy a)
[unionBase] :: Union a -> UnionBase a

-- | <a>Union</a> with identity equality.
type UnionKey = AsKey1 Union

-- | Lift a unary operation to <a>Union</a>.
unionUnaryOp :: (a -> a) -> Union a -> Union a

-- | Lift a binary operation to <a>Union</a>.
unionBinOp :: (a -> a -> a) -> Union a -> Union a -> Union a

-- | Check if a <a>Union</a> is already merged.
isMerged :: Union a -> Bool

-- | The size of a union is defined as the number of branches. For example,
--   
--   <pre>
--   &gt;&gt;&gt; unionSize (return True)
--   1
--   
--   &gt;&gt;&gt; unionSize (mrgIf "a" (return 1) (return 2) :: Union Integer)
--   2
--   
--   &gt;&gt;&gt; unionSize (choose [1..7] "a" :: Union Integer)
--   7
--   </pre>
unionSize :: Union a -> Int


module Grisette.Internal.Core.Data.Class.SymOrd

-- | Symbolic total order. Note that we can't use Haskell's <a>Ord</a>
--   class since symbolic comparison won't necessarily return a concrete
--   <a>Bool</a> or <a>Ordering</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; let a = 1 :: SymInteger
--   
--   &gt;&gt;&gt; let b = 2 :: SymInteger
--   
--   &gt;&gt;&gt; a .&lt; b
--   true
--   
--   &gt;&gt;&gt; a .&gt; b
--   false
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = "a" :: SymInteger
--   
--   &gt;&gt;&gt; let b = "b" :: SymInteger
--   
--   &gt;&gt;&gt; a .&lt; b
--   (&lt; a b)
--   
--   &gt;&gt;&gt; a .&lt;= b
--   (&lt;= a b)
--   
--   &gt;&gt;&gt; a .&gt; b
--   (&lt; b a)
--   
--   &gt;&gt;&gt; a .&gt;= b
--   (&lt;= b a)
--   </pre>
--   
--   For <a>symCompare</a>, <a>Ordering</a> is not a solvable type, and the
--   result would be wrapped in a union-like monad. See <a>Union</a> and
--   <a>PlainUnion</a> for more information.
--   
--   <pre>
--   &gt;&gt;&gt; a `symCompare` b :: Union Ordering
--   {If (&lt; a b) LT (If (= a b) EQ GT)}
--   </pre>
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving SymOrd via (Default X)
--   </pre>
class SymEq a => SymOrd a
(.<) :: SymOrd a => a -> a -> SymBool
(.<=) :: SymOrd a => a -> a -> SymBool
(.>) :: SymOrd a => a -> a -> SymBool
(.>=) :: SymOrd a => a -> a -> SymBool
symCompare :: SymOrd a => a -> a -> Union Ordering
infix 4 .<
infix 4 .<=
infix 4 .>
infix 4 .>=

-- | Lifting of the <a>SymOrd</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftSymCompare symCompare</tt> should be equivalent to
--   <tt>symCompare</tt>, under the symbolic semantics.
--   
--   This class therefore represents the generalization of <a>SymOrd</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class (SymEq1 f, forall a. SymOrd a => SymOrd f a) => SymOrd1 (f :: Type -> Type)

-- | Lift a <a>symCompare</a> function through the type constructor.
--   
--   The function will usually be applied to an symbolic comparison
--   function, but the more general type ensures that the implementation
--   uses it to compare elements of the first container with elements of
--   the second.
liftSymCompare :: SymOrd1 f => (a -> b -> Union Ordering) -> f a -> f b -> Union Ordering

-- | Lift the standard <a>symCompare</a> function to binary type
--   constructors.
symCompare1 :: (SymOrd1 f, SymOrd a) => f a -> f a -> Union Ordering

-- | Lifting of the <a>SymOrd</a> class to binary type constructors.
class (SymEq2 f, forall a. SymOrd a => SymOrd1 f a) => SymOrd2 (f :: Type -> Type -> Type)

-- | Lift a <a>symCompare</a> function through the type constructor.
--   
--   The function will usually be applied to an symbolic comparison
--   function, but the more general type ensures that the implementation
--   uses it to compare elements of the first container with elements of
--   the second.
liftSymCompare2 :: SymOrd2 f => (a -> b -> Union Ordering) -> (c -> d -> Union Ordering) -> f a c -> f b d -> Union Ordering

-- | Lift the standard <a>symCompare</a> function through the type
--   constructors.
symCompare2 :: (SymOrd2 f, SymOrd a, SymOrd b) => f a b -> f a b -> Union Ordering

-- | Symbolic maximum.
symMax :: (SymOrd a, ITEOp a) => a -> a -> a

-- | Symbolic minimum.
symMin :: (SymOrd a, ITEOp a) => a -> a -> a

-- | Symbolic maximum, with a union-like monad.
mrgMax :: (SymOrd a, Mergeable a, SymBranching m, Applicative m) => a -> a -> m a

-- | Symbolic minimum, with a union-like monad.
mrgMin :: (SymOrd a, Mergeable a, SymBranching m, Applicative m) => a -> a -> m a

-- | The arguments to the generic comparison function.
data family SymOrdArgs arity a b

-- | The class of types that can be generically symbolically compared.
class GSymOrd arity (f :: Type -> Type)
gsymCompare :: GSymOrd arity f => SymOrdArgs arity a b -> f a -> f b -> Union Ordering

-- | Generic <a>symCompare</a> function.
genericSymCompare :: (Generic a, GSymOrd Arity0 (Rep a)) => a -> a -> Union Ordering

-- | Generic <a>liftSymCompare</a> function.
genericLiftSymCompare :: (Generic1 f, GSymOrd Arity1 (Rep1 f)) => (a -> b -> Union Ordering) -> f a -> f b -> Union Ordering


module Grisette.Internal.Core.Data.Class.SafeSymShift

-- | Safe version for <a>shiftL</a> or <a>shiftR</a>.
--   
--   The <a>safeSymShiftL</a> and <a>safeSymShiftR</a> are defined for all
--   non-negative shift amounts.
--   
--   <ul>
--   <li>Shifting by negative shift amounts is an error.</li>
--   <li>The result is defined to be 0 when shifting left by more than or
--   equal to the bit size of the number.</li>
--   <li>The result is defined to be 0 when shifting right by more than or
--   equal to the bit size of the number and the number is unsigned or
--   signed non-negative.</li>
--   <li>The result is defined to be -1 when shifting right by more than or
--   equal to the bit size of the number and the number is signed
--   negative.</li>
--   </ul>
--   
--   The <a>safeSymStrictShiftL</a> and <a>safeSymStrictShiftR</a> are
--   defined for all non-negative shift amounts that is less than the bit
--   size. Shifting by more than or equal to the bit size is an error,
--   otherwise they are the same as the non-strict versions.
class (MonadError e m, TryMerge m, Mergeable a) => SafeSymShift e a (m :: Type -> Type)
safeSymShiftL :: SafeSymShift e a m => a -> a -> m a
safeSymShiftR :: SafeSymShift e a m => a -> a -> m a
safeSymStrictShiftL :: SafeSymShift e a m => a -> a -> m a
safeSymStrictShiftR :: SafeSymShift e a m => a -> a -> m a
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int16 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int32 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int64 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int8 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Types.Int m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word16 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word32 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word64 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word8 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift GHC.Internal.Exception.Type.ArithException GHC.Types.Word m


module Grisette.Internal.Core.Data.Class.SafeSymRotate

-- | Safe rotation operations. The operators will reject negative shift
--   amounts.
class (MonadError e m, TryMerge m, Mergeable a) => SafeSymRotate e a (m :: Type -> Type)
safeSymRotateL :: SafeSymRotate e a m => a -> a -> m a
safeSymRotateR :: SafeSymRotate e a m => a -> a -> m a
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int16 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int32 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int64 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int8 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Types.Int m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word16 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word32 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word64 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word8 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate GHC.Internal.Exception.Type.ArithException GHC.Types.Word m


module Grisette.Internal.Core.Data.Class.SafeLinearArith

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
DivideByZero :: ArithException

-- | Safe division with monadic error handling in multi-path execution.
--   These procedures throw an exception when overflow or underflow
--   happens. The result should be able to handle errors with
--   <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a) => SafeLinearArith e a (m :: Type -> Type)

-- | Safe <a>+</a> with monadic error handling in multi-path execution.
--   Overflows or underflows are treated as errors.
--   
--   <pre>
--   &gt;&gt;&gt; safeAdd (ssym "a") (ssym "b") :: ExceptT ArithException Union SymInteger
--   ExceptT {Right (+ a b)}
--   
--   &gt;&gt;&gt; safeAdd (ssym "a") (ssym "b") :: ExceptT ArithException Union (SymIntN 4)
--   ExceptT {If (ite (&lt; 0x0 a) (&amp;&amp; (&lt; 0x0 b) (&lt; (+ a b) 0x0)) (&amp;&amp; (&lt; a 0x0) (&amp;&amp; (&lt; b 0x0) (&lt;= 0x0 (+ a b))))) (If (&lt; 0x0 a) (Left arithmetic overflow) (Left arithmetic underflow)) (Right (+ a b))}
--   </pre>
safeAdd :: SafeLinearArith e a m => a -> a -> m a

-- | Safe <a>negate</a> with monadic error handling in multi-path
--   execution. Overflows or underflows are treated as errors.
--   
--   <pre>
--   &gt;&gt;&gt; safeNeg (ssym "a") :: ExceptT ArithException Union SymInteger
--   ExceptT {Right (- a)}
--   
--   &gt;&gt;&gt; safeNeg (ssym "a") :: ExceptT ArithException Union (SymIntN 4)
--   ExceptT {If (= a 0x8) (Left arithmetic overflow) (Right (- a))}
--   </pre>
safeNeg :: SafeLinearArith e a m => a -> m a

-- | Safe <a>-</a> with monadic error handling in multi-path execution.
--   Overflows or underflows are treated as errors.
--   
--   <pre>
--   &gt;&gt;&gt; safeSub (ssym "a") (ssym "b") :: ExceptT ArithException Union SymInteger
--   ExceptT {Right (+ a (- b))}
--   
--   &gt;&gt;&gt; safeSub (ssym "a") (ssym "b") :: ExceptT ArithException Union (SymIntN 4)
--   ExceptT {If (ite (&lt;= 0x0 a) (&amp;&amp; (&lt; b 0x0) (&lt; (+ a (- b)) 0x0)) (&amp;&amp; (&lt; a 0x0) (&amp;&amp; (&lt; 0x0 b) (&lt; 0x0 (+ a (- b)))))) (If (&lt;= 0x0 a) (Left arithmetic overflow) (Left arithmetic underflow)) (Right (+ a (- b)))}
--   </pre>
safeSub :: SafeLinearArith e a m => a -> a -> m a
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int16 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int32 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int64 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Int.Int8 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Num.Integer.Integer m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Types.Int m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.SymInteger.SymInteger m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word16 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word32 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word64 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Internal.Word.Word8 m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith GHC.Internal.Exception.Type.ArithException GHC.Types.Word m
instance Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith e a m => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith e (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) m


module Grisette.Experimental.MonadParallelUnion

-- | Parallel union monad.
--   
--   With the <tt>QualifiedDo</tt> extension and the
--   <a>Grisette.Qualified.ParallelUnionDo</a> module, one can execute the
--   paths in parallel and merge the results with:
--   
--   <pre>
--   import Grisette
--   import qualified Grisette.Qualified.ParallelUnionDo as P
--   P.do
--     x &lt;- mrgIf "a" (return 1) (return 2) :: Union Int
--     return $ x + 1
--   
--   -- {If a 2 3}
--   </pre>
class (MonadUnion m, TryMerge m) => MonadParallelUnion (m :: Type -> Type)
parBindUnion :: (MonadParallelUnion m, Mergeable b, NFData b) => m a -> (a -> m b) -> m b
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Control.DeepSeq.NFData e) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.Except.ExceptT e m)
instance Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.Identity.IdentityT m)
instance Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.Maybe.MaybeT m)
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable s, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable r, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable w, GHC.Internal.Base.Monoid w, Control.DeepSeq.NFData r, Control.DeepSeq.NFData w, Control.DeepSeq.NFData s) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable s, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable r, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable w, GHC.Internal.Base.Monoid w, Control.DeepSeq.NFData r, Control.DeepSeq.NFData w, Control.DeepSeq.NFData s) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Control.DeepSeq.NFData a) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.Reader.ReaderT a m)
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable s, Control.DeepSeq.NFData s) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.State.Strict.StateT s m)
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable s, Control.DeepSeq.NFData s) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.State.Lazy.StateT s m)
instance Grisette.Experimental.MonadParallelUnion.MonadParallelUnion Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable s, GHC.Internal.Base.Monoid s, Control.DeepSeq.NFData s) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.Writer.Strict.WriterT s m)
instance (Grisette.Experimental.MonadParallelUnion.MonadParallelUnion m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable s, GHC.Internal.Base.Monoid s, Control.DeepSeq.NFData s) => Grisette.Experimental.MonadParallelUnion.MonadParallelUnion (Control.Monad.Trans.Writer.Lazy.WriterT s m)


module Grisette.Experimental.Qualified.ParallelUnionDo

-- | Parallel <a>(&gt;&gt;=)</a> operation.
(>>=) :: (MonadParallelUnion m, Mergeable b, NFData b) => m a -> (a -> m b) -> m b

-- | Parallel <a>(&gt;&gt;)</a> operation.
(>>) :: (MonadParallelUnion m, Mergeable b, NFData b) => m a -> m b -> m b


module Grisette.Internal.Core.Data.Class.CEGISSolver

-- | The response from a verifier.
data VerifierResult cex exception
CEGISVerifierFoundCex :: cex -> VerifierResult cex exception

-- | True indicates that the verifier is sure that there is no
--   counter-example, while False indicates that the verifier is not sure,
--   but it cannot find a counter-example.
CEGISVerifierNoCex :: Bool -> VerifierResult cex exception
CEGISVerifierException :: exception -> VerifierResult cex exception

-- | Build the synthesizer constraint from the verfication result. The
--   first argument will be guaranteed to be distinct during each
--   invocation of the function in the CEGIS algorithm, so it can be used
--   to instantiate the identifiers for fresh variables.
type SynthesisConstraintFun cex = cex -> IO SymBool

-- | The verifier.
type VerifierFun cex exception = Model -> IO VerifierResult cex exception

-- | The result of the CEGIS procedure.
data CEGISResult exception
CEGISSuccess :: Model -> CEGISResult exception
CEGISVerifierFailure :: exception -> CEGISResult exception
CEGISSolverFailure :: SolvingFailure -> CEGISResult exception

-- | Generic CEGIS procedure. See <a>genericCEGIS</a> for more details.
--   
--   The difference from <a>genericCEGIS</a> is that this function accepts
--   a solver handle for the synthesizer, instead of a solver
--   configuration.
solverGenericCEGIS :: Solver handle => handle -> Bool -> SymBool -> SynthesisConstraintFun input -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | Generic CEGIS procedure with refinement. See
--   <a>genericCEGISWithRefinement</a> for more details.
--   
--   The difference from <a>genericCEGISWithRefinement</a> is that this
--   function accepts a solver handle for the synthesizer, instead of a
--   solver configuration.
solverGenericCEGISWithRefinement :: Solver handle => handle -> Bool -> SymBool -> SynthesisConstraintFun input -> Maybe RefinementConditionFun -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | Generic CEGIS procedure.
--   
--   The CEGIS procedure will try to find a model that satisfies the
--   initial synthesis constraint, and satisfies all the inputs generated
--   by the verifier.
genericCEGIS :: ConfigurableSolver config handle => config -> Bool -> SymBool -> SynthesisConstraintFun input -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | Generic CEGIS procedure.
--   
--   The CEGIS procedure will try to find a model that satisfies the
--   initial synthesis constraint, and satisfies all the inputs generated
--   by the verifier.
genericCEGISWithRefinement :: ConfigurableSolver config handle => config -> Bool -> SymBool -> SynthesisConstraintFun input -> Maybe RefinementConditionFun -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | The condition for CEGIS to solve.
--   
--   The first argument is the pre-condition, and the second argument is
--   the post-condition.
--   
--   The CEGIS procedures would try to find a model for the formula
--   
--   &lt;math&gt;
--   
--   In program synthesis tasks, &lt;math&gt; is the symbolic constants in
--   the symbolic program, and &lt;math&gt; is the input. The pre-condition
--   is used to restrict the search space of the program. The procedure
--   would only return programs that meets the pre-conditions on every
--   possible inputs, and there are at least one possible input. The
--   post-condition is used to specify the desired program behaviors.
data CEGISCondition
CEGISCondition :: SymBool -> SymBool -> CEGISCondition

-- | Construct a CEGIS condition with only a post-condition. The
--   pre-condition would be set to true, meaning that all programs in the
--   program space are allowed.
cegisPostCond :: SymBool -> CEGISCondition

-- | Construct a CEGIS condition with both pre- and post-conditions.
cegisPrePost :: SymBool -> SymBool -> CEGISCondition

-- | CEGIS with multiple (possibly symbolic) inputs. See
--   <a>cegisMultiInputs</a> for more details.
--   
--   The difference from <a>cegisMultiInputs</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisMultiInputs :: (EvalSym input, ExtractSym input, Solver handle) => handle -> handle -> [input] -> (input -> CEGISCondition) -> IO ([input], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs. See
--   <a>cegis</a> for more details.
--   
--   The difference from <a>cegis</a> is that this function accepts two
--   solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegis :: (Solver handle, EvalSym inputs, ExtractSym inputs, SymEq inputs) => handle -> handle -> inputs -> (inputs -> CEGISCondition) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs. See <a>cegisExcept</a>
--   for more details.
--   
--   The difference from <a>cegisExcept</a> is that this function accepts
--   two solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExcept :: forall t (u :: Type -> Type) e v inputs handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs. See
--   <a>cegisExceptStdVC</a> for more details.
--   
--   The difference from <a>cegisExceptStdVC</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptStdVC :: forall t (u :: Type -> Type) inputs handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
--   
--   The difference from <a>cegisExceptVC</a> is that this function accepts
--   two solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
--   
--   The difference from <a>cegisExceptMultiInputs</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptMultiInputs :: forall handle inputs t (u :: Type -> Type) e v. (Solver handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => handle -> handle -> [inputs] -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs. See
--   <a>cegisExceptStdVCMultiInputs</a> for more details.
--   
--   The difference from <a>cegisExceptStdVCMultiInputs</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptStdVCMultiInputs :: forall handle inputs t (u :: Type -> Type). (Solver handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u VerificationConditions (), UnionView u, Monad u) => handle -> handle -> [inputs] -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
--   
--   The difference from <a>cegisExceptVCMultiInputs</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptVCMultiInputs :: (Solver handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => handle -> handle -> [inputs] -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs. See
--   <a>cegisForAll</a> for more details.
--   
--   The difference from <a>cegisForAll</a> is that this function accepts
--   two solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAll :: (ExtractSym forallInput, Solver handle) => handle -> handle -> forallInput -> CEGISCondition -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAllExcept</a>, <a>cegisForAll</a> and
--   <a>cegisExcept</a>.
--   
--   The difference from <a>cegisForAllExcept</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAllExcept :: forall t (u :: Type -> Type) e v inputs handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> CEGISCondition) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAllExceptStdVC</a> <a>cegisForAll</a> and
--   <a>cegisExceptStdVC</a>.
--   
--   The difference from <a>cegisForAllExceptStdVC</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAllExceptStdVC :: forall t (u :: Type -> Type) inputs handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAllExceptVC</a> <a>cegisForAll</a> and
--   <a>cegisExceptVC</a>.
--   
--   The difference from <a>cegisForAllExceptVC</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAllExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS with multiple (possibly symbolic) inputs. Solves the following
--   formula (see <a>CEGISCondition</a> for details).
--   
--   &lt;math&gt;
--   
--   For simpler queries, where the inputs are representable by a single
--   symbolic value, you may want to use <a>cegis</a> or <a>cegisExcept</a>
--   instead. We have an example for the <a>cegis</a> call.
cegisMultiInputs :: (EvalSym input, ExtractSym input, ConfigurableSolver config handle) => config -> [input] -> (input -> CEGISCondition) -> IO ([input], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> clause is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; cegis z3 x (\x -&gt; cegisPrePost (x .&gt; 0) (x * c .&lt; 0 .&amp;&amp; c .&gt; -2))
--   (...,CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegis :: (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, SymEq inputs) => config -> inputs -> (inputs -> CEGISCondition) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs.
--   
--   <a>cegisExcept</a> is particularly useful when custom error types are
--   used. With <a>cegisExcept</a>, you define how the errors are
--   interpreted to the CEGIS conditions after the symbolic evaluation.
--   This could increase the readability and modularity of the code.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> assertion is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; import Control.Monad.Except
--   
--   &gt;&gt;&gt; :{
--     res :: SymInteger -&gt; ExceptT VerificationConditions Union ()
--     res x = do
--       symAssume $ x .&gt; 0
--       symAssert $ x * c .&lt; 0
--       symAssert $ c .&gt; -2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     translation (Left AssumptionViolation) = cegisPrePost (con False) (con True)
--     translation (Left AssertionViolation) = cegisPostCond (con False)
--     translation _ = cegisPostCond (con True)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cegisExcept z3 x translation res
--   ([...],CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegisExcept :: forall t (u :: Type -> Type) e v inputs config handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs. This function saves the
--   efforts to implement the translation function for the standard error
--   type <a>VerificationConditions</a>, and the standard result type
--   <tt>()</tt>.
--   
--   This function translates assumption violations to failed
--   pre-conditions, and translates assertion violations to failed
--   post-conditions. The <tt>()</tt> result will not fail any conditions.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> assertion is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; import Control.Monad.Except
--   
--   &gt;&gt;&gt; :{
--     res :: SymInteger -&gt; ExceptT VerificationConditions Union ()
--     res x = do
--       symAssume $ x .&gt; 0
--       symAssert $ x * c .&lt; 0
--       symAssert $ c .&gt; -2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cegisExceptStdVC z3 x res
--   ([...],CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegisExceptStdVC :: forall t (u :: Type -> Type) inputs config handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
cegisExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
cegisExceptMultiInputs :: forall config handle inputs t (u :: Type -> Type) e v. (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => config -> [inputs] -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs. This function
--   saves the efforts to implement the translation function for the
--   standard error type <a>VerificationConditions</a>, and the standard
--   result type <tt>()</tt>.
--   
--   This function translates assumption violations to failed
--   pre-conditions, and translates assertion violations to failed
--   post-conditions. The <tt>()</tt> result will not fail any conditions.
cegisExceptStdVCMultiInputs :: forall config handle inputs t (u :: Type -> Type). (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u VerificationConditions (), UnionView u, Monad u) => config -> [inputs] -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
cegisExceptVCMultiInputs :: (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => config -> [inputs] -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> clause is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; cegisForAll z3 x $ cegisPrePost (x .&gt; 0) (x * c .&lt; 0 .&amp;&amp; c .&gt; -2)
--   (...,CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegisForAll :: (ExtractSym forallInput, ConfigurableSolver config handle) => config -> forallInput -> CEGISCondition -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAll</a> and <a>cegisExcept</a>.
cegisForAllExcept :: forall t (u :: Type -> Type) e v inputs config handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> CEGISCondition) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAll</a> and <a>cegisExceptStdVC</a>.
cegisForAllExceptStdVC :: forall t (u :: Type -> Type) inputs config handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAll</a> and <a>cegisExceptVC</a>.
cegisForAllExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> t -> IO ([Model], CEGISResult SolvingFailure)
instance Data.Bytes.Serial.Serial exception => Data.Binary.Class.Binary (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance GHC.Classes.Eq exception => GHC.Classes.Eq (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance (GHC.Classes.Eq cex, GHC.Classes.Eq exception) => GHC.Classes.Eq (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISCondition
instance GHC.Internal.Generics.Generic Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISCondition
instance GHC.Internal.Generics.Generic (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance GHC.Internal.Generics.Generic (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance Data.Hashable.Class.Hashable exception => Data.Hashable.Class.Hashable (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance (Data.Hashable.Class.Hashable cex, Data.Hashable.Class.Hashable exception) => Data.Hashable.Class.Hashable (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance Language.Haskell.TH.Syntax.Lift exception => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance (Language.Haskell.TH.Syntax.Lift cex, Language.Haskell.TH.Syntax.Lift exception) => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISCondition
instance Control.DeepSeq.NFData exception => Control.DeepSeq.NFData (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance (Control.DeepSeq.NFData cex, Control.DeepSeq.NFData exception) => Control.DeepSeq.NFData (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint cex, Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint exception) => Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance Data.Bytes.Serial.Serial exception => Data.Bytes.Serial.Serial (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance Data.Bytes.Serial.Serial exception => Data.Serialize.Serialize (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance GHC.Internal.Show.Show exception => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISResult exception)
instance (GHC.Internal.Show.Show cex, GHC.Internal.Show.Show exception) => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.CEGISSolver.VerifierResult cex exception)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SimpleMergeable Grisette.Internal.Core.Data.Class.CEGISSolver.CEGISCondition


module Grisette.Internal.Core.Data.Class.SafeLogBase

-- | Safe <a>logBase</a> with monadic error handling in multi-path
--   execution. These procedures throw an exception when the base is 1. The
--   result should be able to handle errors with <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a) => SafeLogBase e a (m :: Type -> Type)

-- | Safe <a>logBase</a> with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeLogBase (ssym "base") (ssym "val") :: ExceptT ArithException Union SymAlgReal
--   ExceptT {If (= base 1.0) (Left Ratio has zero denominator) (Right (fdiv (log val) (log base)))}
--   </pre>
safeLogBase :: SafeLogBase e a m => a -> a -> m a

-- | Safe <a>logBase</a> with default values returned on exception.
class LogBaseOr a

-- | Safe <a>logBase</a> with default values returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; logBaseOr "d" "base" "val" :: SymAlgReal
--   (ite (= base 1.0) d (fdiv (log val) (log base)))
--   </pre>
logBaseOr :: LogBaseOr a => a -> a -> a -> a

-- | Safe <a>logBase</a> with 0 returned on exception.
logBaseOrZero :: (LogBaseOr a, Num a) => a -> a -> a
instance Grisette.Internal.Core.Data.Class.SafeLogBase.LogBaseOr a => Grisette.Internal.Core.Data.Class.SafeLogBase.LogBaseOr (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.SafeLogBase.LogBaseOr Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m) => Grisette.Internal.Core.Data.Class.SafeLogBase.SafeLogBase GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal m
instance Grisette.Internal.Core.Data.Class.SafeLogBase.SafeLogBase e a m => Grisette.Internal.Core.Data.Class.SafeLogBase.SafeLogBase e (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) m


module Grisette.Internal.Core.Data.Class.SafeFromFP

-- | Safe conversion from floating point numbers that throws exceptions
--   when the result isn't representable by the type.
class (MonadError e m, TryMerge m, IEEEFPConvertible a fp fprd) => SafeFromFP e a fp fprd (m :: Type -> Type)
safeFromFP :: SafeFromFP e a fp fprd m => fprd -> fp -> m a
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.AlgReal.AlgReal (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m


module Grisette.Internal.Core.Data.Class.SafeFdiv

-- | Safe fractional division with monadic error handling in multi-path
--   execution. These procedures throw an exception when the denominator is
--   zero. The result should be able to handle errors with
--   <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a) => SafeFdiv e a (m :: Type -> Type)

-- | Safe fractional division with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeFdiv "a" "b" :: ExceptT ArithException Union SymAlgReal
--   ExceptT {If (= b 0.0) (Left Ratio has zero denominator) (Right (fdiv a b))}
--   </pre>
safeFdiv :: SafeFdiv e a m => a -> a -> m a

-- | Safe fractional reciprocal with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeRecip "a" :: ExceptT ArithException Union SymAlgReal
--   ExceptT {If (= a 0.0) (Left Ratio has zero denominator) (Right (recip a))}
--   </pre>
safeRecip :: SafeFdiv e a m => a -> m a
($dmsafeRecip) :: (SafeFdiv e a m, Fractional a) => a -> m a

-- | Safe fractional with default values returned on exception.
class FdivOr a

-- | Safe <a>/</a> with default values returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; fdivOr "d" "a" "b" :: SymAlgReal
--   (ite (= b 0.0) d (fdiv a b))
--   </pre>
fdivOr :: FdivOr a => a -> a -> a -> a

-- | Safe <a>recip</a> with default values returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; recipOr "d" "a" :: SymAlgReal
--   (ite (= a 0.0) d (recip a))
--   </pre>
recipOr :: FdivOr a => a -> a -> a

-- | Safe <a>/</a> with 0 returned on exception.
fdivOrZero :: (FdivOr a, Num a) => a -> a -> a

-- | Safe <a>recip</a> with 0 returned on exception.
recipOrZero :: (FdivOr a, Num a) => a -> a
instance Grisette.Internal.Core.Data.Class.SafeFdiv.FdivOr Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Core.Data.Class.SafeFdiv.FdivOr a => Grisette.Internal.Core.Data.Class.SafeFdiv.FdivOr (Grisette.Internal.Core.Data.Class.AsKey.AsKey a)
instance Grisette.Internal.Core.Data.Class.SafeFdiv.FdivOr Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m) => Grisette.Internal.Core.Data.Class.SafeFdiv.SafeFdiv GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.AlgReal.AlgReal m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Core.Control.Monad.Class.Union.MonadUnion m) => Grisette.Internal.Core.Data.Class.SafeFdiv.SafeFdiv GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal m
instance Grisette.Internal.Core.Data.Class.SafeFdiv.SafeFdiv e a m => Grisette.Internal.Core.Data.Class.SafeFdiv.SafeFdiv e (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) m


module Grisette.Lib.Control.Monad.Trans.Class

-- | <a>lift</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLift :: (TryMerge (t m), MonadTrans t, Monad m, Mergeable a) => m a -> t m a


module Grisette.Lib.Control.Monad.Trans


module Grisette.Lib.Control.Monad.Trans.Except

-- | <a>except</a> with <a>MergingStrategy</a> knowledge propagation.
mrgExcept :: forall (m :: Type -> Type) e a. (MonadTryMerge m, Mergeable e, Mergeable a) => Either e a -> ExceptT e m a

-- | <a>runExceptT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgRunExceptT :: (MonadTryMerge m, Mergeable e, Mergeable a) => ExceptT e m a -> m (Either e a)

-- | <a>withExceptT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgWithExceptT :: forall (m :: Type -> Type) a e e'. (MonadTryMerge m, Mergeable a, Mergeable e, Mergeable e') => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | <a>throwE</a> with <a>MergingStrategy</a> knowledge propagation.
mrgThrowE :: forall (m :: Type -> Type) e a. (MonadTryMerge m, Mergeable e, Mergeable a) => e -> ExceptT e m a

-- | <a>catchE</a> with <a>MergingStrategy</a> knowledge propagation.
mrgCatchE :: forall (m :: Type -> Type) e a. (MonadTryMerge m, Mergeable e, Mergeable a) => ExceptT e m a -> (e -> ExceptT e m a) -> ExceptT e m a


module Grisette.Lib.Data.Bool

-- | Smart constructor for <a>True</a> to construct values wrapped and
--   possibly merged in a container.
mrgTrue :: (Mergeable Bool, Applicative m, TryMerge m) => m Bool

-- | Smart constructor for <a>False</a> to construct values wrapped and
--   possibly merged in a container.
mrgFalse :: (Mergeable Bool, Applicative m, TryMerge m) => m Bool


module Grisette.Lib.Data.Either

-- | Smart constructor for <a>Left</a> to construct values wrapped and
--   possibly merged in a container.
mrgLeft :: (Mergeable (Either a b), Applicative m, TryMerge m) => a -> m (Either a b)

-- | Smart constructor for <a>Right</a> to construct values wrapped and
--   possibly merged in a container.
mrgRight :: (Mergeable (Either a b), Applicative m, TryMerge m) => b -> m (Either a b)


module Grisette.Lib.Data.Functor.Sum

-- | Smart constructor for <a>InR</a> to construct values wrapped and
--   possibly merged in a container.
mrgInR :: forall k (f :: k -> Type) g (a :: k) m. (Mergeable (Sum f g a), Applicative m, TryMerge m) => g a -> m (Sum f g a)

-- | Smart constructor for <a>InL</a> to construct values wrapped and
--   possibly merged in a container.
mrgInL :: forall k f (g :: k -> Type) (a :: k) m. (Mergeable (Sum f g a), Applicative m, TryMerge m) => f a -> m (Sum f g a)


module Grisette.Lib.Data.Maybe

-- | Smart constructor for <a>Nothing</a> to construct values wrapped and
--   possibly merged in a container.
mrgNothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) => m (Maybe a)

-- | Smart constructor for <a>Just</a> to construct values wrapped and
--   possibly merged in a container.
mrgJust :: (Mergeable (Maybe a), Applicative m, TryMerge m) => a -> m (Maybe a)


module Grisette.Lib.Data.Tuple

-- | Smart constructor for v'GHC.Tuple.()' to construct values wrapped and
--   possibly merged in a container.
mrgUnit :: (Mergeable (), Applicative m, TryMerge m) => m ()

-- | Smart constructor for v'GHC.Tuple.(,)' to construct values wrapped and
--   possibly merged in a container.
mrgTuple2 :: (Mergeable (a, b), Applicative m, TryMerge m) => a -> b -> m (a, b)

-- | Smart constructor for v'GHC.Tuple.(,,)' to construct values wrapped
--   and possibly merged in a container.
mrgTuple3 :: (Mergeable (a, b, c), Applicative m, TryMerge m) => a -> b -> c -> m (a, b, c)

-- | Smart constructor for v'GHC.Tuple.(,,,)' to construct values wrapped
--   and possibly merged in a container.
mrgTuple4 :: (Mergeable (a, b, c, d), Applicative m, TryMerge m) => a -> b -> c -> d -> m (a, b, c, d)

-- | Smart constructor for v'GHC.Tuple.(,,,,)' to construct values wrapped
--   and possibly merged in a container.
mrgTuple5 :: (Mergeable (a, b, c, d, e), Applicative m, TryMerge m) => a -> b -> c -> d -> e -> m (a, b, c, d, e)

-- | Smart constructor for v'GHC.Tuple.(,,,,,)' to construct values wrapped
--   and possibly merged in a container.
mrgTuple6 :: (Mergeable (a, b, c, d, e, f), Applicative m, TryMerge m) => a -> b -> c -> d -> e -> f -> m (a, b, c, d, e, f)

-- | Smart constructor for v'GHC.Tuple.(,,,,,,)' to construct values
--   wrapped and possibly merged in a container.
mrgTuple7 :: (Mergeable (a, b, c, d, e, f, g), Applicative m, TryMerge m) => a -> b -> c -> d -> e -> f -> g -> m (a, b, c, d, e, f, g)

-- | Smart constructor for v'GHC.Tuple.(,,,,,,,)' to construct values
--   wrapped and possibly merged in a container.
mrgTuple8 :: (Mergeable (a, b, c, d, e, f, g, h), Applicative m, TryMerge m) => a -> b -> c -> d -> e -> f -> g -> h -> m (a, b, c, d, e, f, g, h)


module Grisette.Unified.Lib.Data.Functor

-- | <a>fmap</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFmap :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b

-- | <a>&lt;$</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => b -> f a -> f b
infixl 4 .<$

-- | <a>$&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.$>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => f a -> b -> f b
infixl 4 .$>

-- | <a>&lt;$&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b
infixl 4 .<$>

-- | <a>&lt;&amp;&gt;</a> with <a>MergingStrategy</a> knowledge
--   propagation.
(.<&>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => f a -> (a -> b) -> f b
infixl 1 .<&>

-- | <a>unzip</a> with <a>MergingStrategy</a> knowledge propagation.
mrgUnzip :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => f (a, b) -> (f a, f b)

-- | <a>void</a> with <a>MergingStrategy</a> knowledge propagation.
mrgVoid :: (TryMerge f, Functor f) => f a -> f ()


module Grisette.Lib.Data.Functor

-- | <a>fmap</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFmap :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b

-- | <a>&lt;$</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => b -> f a -> f b
infixl 4 .<$

-- | <a>$&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.$>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => f a -> b -> f b
infixl 4 .$>

-- | <a>&lt;$&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b
infixl 4 .<$>

-- | <a>&lt;&amp;&gt;</a> with <a>MergingStrategy</a> knowledge
--   propagation.
(.<&>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => f a -> (a -> b) -> f b
infixl 1 .<&>

-- | <a>unzip</a> with <a>MergingStrategy</a> knowledge propagation.
mrgUnzip :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => f (a, b) -> (f a, f b)

-- | <a>void</a> with <a>MergingStrategy</a> knowledge propagation.
mrgVoid :: (TryMerge f, Functor f) => f a -> f ()


module Grisette.Unified.Lib.Control.Applicative

-- | Alias for <a>mrgSingleWithStrategy</a>.
mrgPureWithStrategy :: (TryMerge m, Applicative m) => MergingStrategy a -> a -> m a

-- | Alias for <a>mrgSingle</a>.
mrgPure :: (TryMerge m, Applicative m, Mergeable a) => a -> m a

-- | <a>&lt;*&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<*>) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f (a -> b) -> f a -> f b
infixl 4 .<*>

-- | <a>liftA2</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftA2 :: (Applicative f, TryMerge f, Mergeable a, Mergeable b, Mergeable c) => (a -> b -> c) -> f a -> f b -> f c

-- | <a>*&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.*>) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f a -> f b -> f b
infixl 4 .*>

-- | <a>&lt;*</a> with <a>MergingStrategy</a> knowledge propagation.
(.<*) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f a -> f b -> f a
infixl 4 .<*

-- | <a>empty</a> with <a>MergingStrategy</a> knowledge propagation.
mrgEmpty :: (Alternative f, TryMerge f, Mergeable a) => f a

-- | <a>&lt;|&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<|>) :: (Alternative f, TryMerge f, Mergeable a) => f a -> f a -> f a
infixl 3 .<|>

-- | <a>some</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSome :: (Alternative f, TryMerge f, Mergeable a) => f a -> f [a]

-- | <a>many</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMany :: (Alternative f, TryMerge f, Mergeable a) => f a -> f [a]

-- | <a>&lt;$&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b
infixl 4 .<$>

-- | <a>&lt;$</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => b -> f a -> f b
infixl 4 .<$

-- | <a>&lt;**&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<**>) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f a -> f (a -> b) -> f b
infixl 4 .<**>

-- | <a>liftA</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftA :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => (a -> b) -> f a -> f b

-- | <a>liftA3</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftA3 :: (Applicative f, TryMerge f, Mergeable a, Mergeable b, Mergeable c, Mergeable d) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | <a>optional</a> with <a>MergingStrategy</a> knowledge propagation.
mrgOptional :: (Alternative f, TryMerge f, Mergeable a) => f a -> f (Maybe a)

-- | <a>asum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgAsum :: (Alternative f, TryMerge f, Mergeable a, Foldable t) => t (f a) -> f a


module Grisette.Lib.Control.Applicative

-- | Alias for <a>mrgSingleWithStrategy</a>.
mrgPureWithStrategy :: (TryMerge m, Applicative m) => MergingStrategy a -> a -> m a

-- | Alias for <a>mrgSingle</a>.
mrgPure :: (TryMerge m, Applicative m, Mergeable a) => a -> m a

-- | <a>&lt;*&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<*>) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f (a -> b) -> f a -> f b
infixl 4 .<*>

-- | <a>liftA2</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftA2 :: (Applicative f, TryMerge f, Mergeable a, Mergeable b, Mergeable c) => (a -> b -> c) -> f a -> f b -> f c

-- | <a>*&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.*>) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f a -> f b -> f b
infixl 4 .*>

-- | <a>&lt;*</a> with <a>MergingStrategy</a> knowledge propagation.
(.<*) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f a -> f b -> f a
infixl 4 .<*

-- | <a>empty</a> with <a>MergingStrategy</a> knowledge propagation.
mrgEmpty :: (Alternative f, TryMerge f, Mergeable a) => f a

-- | <a>&lt;|&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<|>) :: (Alternative f, TryMerge f, Mergeable a) => f a -> f a -> f a
infixl 3 .<|>

-- | <a>some</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSome :: (Alternative f, TryMerge f, Mergeable a) => f a -> f [a]

-- | <a>many</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMany :: (Alternative f, TryMerge f, Mergeable a) => f a -> f [a]

-- | <a>&lt;$&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$>) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b
infixl 4 .<$>

-- | <a>&lt;$</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => b -> f a -> f b
infixl 4 .<$

-- | <a>&lt;**&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<**>) :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => f a -> f (a -> b) -> f b
infixl 4 .<**>

-- | <a>liftA</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftA :: (Applicative f, TryMerge f, Mergeable a, Mergeable b) => (a -> b) -> f a -> f b

-- | <a>liftA3</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftA3 :: (Applicative f, TryMerge f, Mergeable a, Mergeable b, Mergeable c, Mergeable d) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | <a>optional</a> with <a>MergingStrategy</a> knowledge propagation.
mrgOptional :: (Alternative f, TryMerge f, Mergeable a) => f a -> f (Maybe a)

-- | <a>asum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgAsum :: (Alternative f, TryMerge f, Mergeable a, Foldable t) => t (f a) -> f a


module Grisette.Lib.Data.Traversable

-- | <a>traverse</a> with <a>MergingStrategy</a> knowledge propagation.
mrgTraverse :: forall a b t f. (Mergeable b, Mergeable1 t, TryMerge f, Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)

-- | <a>sequenceA</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequenceA :: (Mergeable a, Mergeable1 t, Applicative f, TryMerge f, Traversable t) => t (f a) -> f (t a)

-- | <a>mapM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM :: forall a b t f. (Mergeable b, Mergeable1 t, MonadTryMerge f, Traversable t) => (a -> f b) -> t a -> f (t b)

-- | <a>sequence</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence :: (Mergeable a, Mergeable1 t, MonadTryMerge f, Traversable t) => t (f a) -> f (t a)

-- | <a>for</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFor :: (Mergeable b, Mergeable1 t, Traversable t, TryMerge m, Applicative m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM :: (Mergeable b, Mergeable1 t, Traversable t, MonadTryMerge m) => t a -> (a -> m b) -> m (t b)

-- | <a>mapAccumM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapAccumM :: (MonadTryMerge m, Traversable t, Mergeable s, Mergeable b, Mergeable1 t) => (s -> a -> m (s, b)) -> s -> t a -> m (s, t b)

-- | <a>forAccumM</a> and <a>MergingStrategy</a> knowledge propagation.
mrgForAccumM :: (MonadTryMerge m, Traversable t, Mergeable s, Mergeable b, Mergeable1 t) => s -> t a -> (s -> a -> m (s, b)) -> m (s, t b)


module Grisette.Internal.Core.Data.Class.SafeDiv

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
DivideByZero :: ArithException

-- | Safe division with monadic error handling in multi-path execution.
--   These procedures throw an exception when the divisor is zero. The
--   result should be able to handle errors with <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a, DivOr a) => SafeDiv e a (m :: Type -> Type)

-- | Safe <a>div</a> with monadic error handling in multi-path execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv "a" "b" :: ExceptT ArithException Union SymInteger
--   ExceptT {If (= b 0) (Left divide by zero) (Right (div a b))}
--   </pre>
safeDiv :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>mod</a> with monadic error handling in multi-path execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeMod "a" "b" :: ExceptT ArithException Union SymInteger
--   ExceptT {If (= b 0) (Left divide by zero) (Right (mod a b))}
--   </pre>
safeMod :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>divMod</a> with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeDivMod "a" "b" :: ExceptT ArithException Union (SymInteger, SymInteger)
--   ExceptT {If (= b 0) (Left divide by zero) (Right ((div a b),(mod a b)))}
--   </pre>
safeDivMod :: SafeDiv e a m => a -> a -> m (a, a)

-- | Safe <a>quot</a> with monadic error handling in multi-path execution.
safeQuot :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>rem</a> with monadic error handling in multi-path execution.
safeRem :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>quotRem</a> with monadic error handling in multi-path
--   execution.
safeQuotRem :: SafeDiv e a m => a -> a -> m (a, a)

-- | Safe division handling with default values returned on exception.
class DivOr a

-- | Safe <a>div</a> with default value returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; divOr "d" "a" "b" :: SymInteger
--   (ite (= b 0) d (div a b))
--   </pre>
divOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>mod</a> with default value returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; modOr "d" "a" "b" :: SymInteger
--   (ite (= b 0) d (mod a b))
--   </pre>
modOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>divMod</a> with default value returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; divModOr ("d", "m") "a" "b" :: (SymInteger, SymInteger)
--   ((ite (= b 0) d (div a b)),(ite (= b 0) m (mod a b)))
--   </pre>
divModOr :: DivOr a => (a, a) -> a -> a -> (a, a)

-- | Safe <a>quot</a> with default value returned on exception.
quotOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>rem</a> with default value returned on exception.
remOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>quotRem</a> with default value returned on exception.
quotRemOr :: DivOr a => (a, a) -> a -> a -> (a, a)

-- | Safe <a>div</a> with 0 returned on exception.
divOrZero :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>mod</a> with dividend returned on exception.
modOrDividend :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>quot</a> with 0 returned on exception.
quotOrZero :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>rem</a> with dividend returned on exception.
remOrDividend :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>divMod</a> with 0 returned on exception.
divModOrZeroDividend :: (DivOr a, Num a) => a -> a -> (a, a)

-- | Safe <a>quotRem</a> with 0 returned on exception.
quotRemOrZeroDividend :: (DivOr a, Num a) => a -> a -> (a, a)


module Grisette.Internal.Core.Data.Class.GenSym

-- | Index type used for <a>GenSym</a>.
--   
--   To generate fresh variables, a monadic stateful context will be
--   maintained. The index should be increased every time a new symbolic
--   constant is generated.
newtype FreshIndex
FreshIndex :: Int -> FreshIndex

-- | Monad class for fresh symbolic value generation.
--   
--   The monad should be a reader monad for the <a>Identifier</a> and a
--   state monad for the <a>FreshIndex</a>.
class Monad m => MonadFresh (m :: Type -> Type)

-- | Get the current index for fresh variable generation.
getFreshIndex :: MonadFresh m => m FreshIndex

-- | Set the current index for fresh variable generation.
setFreshIndex :: MonadFresh m => FreshIndex -> m ()

-- | Get the identifier.
getIdentifier :: MonadFresh m => m Identifier

-- | Change the identifier locally and use a new index from 0 locally.
localIdentifier :: MonadFresh m => (Identifier -> Identifier) -> m a -> m a

-- | Get the next fresh index and increase the current index.
nextFreshIndex :: MonadFresh m => m FreshIndex

-- | Lifts an <tt><a>Fresh</a> a</tt> into any <a>MonadFresh</a>.
liftFresh :: MonadFresh m => Fresh a -> m a

-- | A symbolic generation monad transformer.
--   
--   It is a reader monad transformer for an identifier and a state monad
--   transformer for indices.
--   
--   Each time a fresh symbolic variable is generated, the index should be
--   increased.
newtype FreshT (m :: Type -> Type) a
FreshT :: (Identifier -> FreshIndex -> m (a, FreshIndex)) -> FreshT (m :: Type -> Type) a
[runFreshTFromIndex] :: FreshT (m :: Type -> Type) a -> Identifier -> FreshIndex -> m (a, FreshIndex)

-- | <a>FreshT</a> specialized with Identity.
type Fresh = FreshT Identity

-- | Run the symbolic generation with the given identifier and 0 as the
--   initial index.
runFreshT :: Monad m => FreshT m a -> Identifier -> m a

-- | Run the symbolic generation with the given identifier and 0 as the
--   initial index.
runFresh :: Fresh a -> Identifier -> a

-- | Run the symbolic generation with the given identifier and 0 as the
--   initial index, and try to merge the result.
mrgRunFreshT :: (Monad m, TryMerge m, Mergeable a) => FreshT m a -> Identifier -> m a

-- | Generate a fresh string with the given postfix.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (freshString "b") "a" :: String
--   "a@0[b]"
--   </pre>
freshString :: (MonadFresh m, IsString s) => String -> m s

-- | Class of types in which symbolic values can be generated with respect
--   to some specification.
--   
--   The result will be wrapped in a union-like monad. This ensures that we
--   can generate those types with complex merging rules.
--   
--   The uniqueness of symbolic constants is managed with the a monadic
--   context. <a>Fresh</a> and <a>FreshT</a> can be useful.
class Mergeable a => GenSym spec a

-- | Generate a symbolic value given some specification. Within a single
--   <a>MonadFresh</a> context, calls to <a>fresh</a> would generate unique
--   symbolic constants.
--   
--   The following example generates a symbolic boolean. No specification
--   is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh ()) "a" :: Union SymBool
--   {a@0}
--   </pre>
--   
--   The following example generates booleans, which cannot be merged into
--   a single value with type <a>Bool</a>. No specification is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh ()) "a" :: Union Bool
--   {If a@0 False True}
--   </pre>
--   
--   The following example generates <tt>Maybe Bool</tt>s. There are more
--   than one symbolic constants introduced, and their uniqueness is
--   ensured. No specification is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh ()) "a" :: Union (Maybe Bool)
--   {If a@0 Nothing (If a@1 (Just False) (Just True))}
--   </pre>
--   
--   The following example generates lists of symbolic booleans with length
--   1 to 2.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (ListSpec 1 2 ())) "a" :: Union [SymBool]
--   {If a@2 [a@1] [a@0,a@1]}
--   </pre>
--   
--   When multiple symbolic values are generated, there will not be any
--   identifier collision
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (do; a &lt;- fresh (); b &lt;- fresh (); return (a, b)) "a" :: (Union SymBool, Union SymBool)
--   ({a@0},{a@1})
--   </pre>
fresh :: (GenSym spec a, MonadFresh m) => spec -> m (Union a)
($dmfresh) :: (GenSym spec a, GenSymSimple spec a, MonadFresh m) => spec -> m (Union a)

-- | Class of types in which symbolic values can be generated with respect
--   to some specification.
--   
--   The result will <b><i>not</i></b> be wrapped in a union-like monad.
--   
--   The uniqueness of symbolic constants is managed with the a monadic
--   context. <a>Fresh</a> and <a>FreshT</a> can be useful.
class GenSymSimple spec a

-- | Generate a symbolic value given some specification. The uniqueness is
--   ensured.
--   
--   The following example generates a symbolic boolean. No specification
--   is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (simpleFresh ()) "a" :: SymBool
--   a@0
--   </pre>
--   
--   The following code generates list of symbolic boolean with length 2.
--   As the length is fixed, we don't have to wrap the result in unions.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (simpleFresh (SimpleListSpec 2 ())) "a" :: [SymBool]
--   [a@0,a@1]
--   </pre>
simpleFresh :: (GenSymSimple spec a, MonadFresh m) => spec -> m a

-- | Generate a symbolic variable wrapped in a Union without the monadic
--   context. A globally unique identifier should be supplied to ensure the
--   uniqueness of symbolic constants in the generated symbolic values.
--   
--   <pre>
--   &gt;&gt;&gt; genSym (ListSpec 1 2 ()) "a" :: Union [SymBool]
--   {If a@2 [a@1] [a@0,a@1]}
--   </pre>
genSym :: GenSym spec a => spec -> Identifier -> Union a

-- | Generate a simple symbolic variable wrapped in a Union without the
--   monadic context. A globally unique identifier should be supplied to
--   ensure the uniqueness of symbolic constants in the generated symbolic
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; genSymSimple (SimpleListSpec 2 ()) "a" :: [SymBool]
--   [a@0,a@1]
--   </pre>
genSymSimple :: GenSymSimple spec a => spec -> Identifier -> a

-- | We cannot provide DerivingVia style derivation for <a>GenSym</a>,
--   while you can use this <a>fresh</a> implementation to implement
--   <a>GenSym</a> for your own types.
--   
--   This <a>fresh</a> implementation is for the types that does not need
--   any specification. It will generate product types by generating each
--   fields with <tt>()</tt> as specification, and generate all possible
--   values for a sum type.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedNoSpecFresh :: (Generic a, GenSymNoSpec (Rep a), Mergeable a, MonadFresh m) => () -> m (Union a)

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimple</a>, while you can use this <a>simpleFresh</a>
--   implementation to implement <a>GenSymSimple</a> fo your own types.
--   
--   This <a>simpleFresh</a> implementation is for the types that does not
--   need any specification. It will generate product types by generating
--   each fields with <tt>()</tt> as specification. It will not work on sum
--   types.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedNoSpecSimpleFresh :: (Generic a, GenSymSimpleNoSpec (Rep a), MonadFresh m) => () -> m a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimple</a>, while you can use this <a>simpleFresh</a>
--   implementation to implement <a>GenSymSimple</a> fo your own types.
--   
--   This <a>simpleFresh</a> implementation is for the types that can be
--   generated with a reference value of the same type.
--   
--   For sum types, it will generate the result with the same data
--   constructor. For product types, it will generate the result by
--   generating each field with the corresponding reference value.
--   
--   <b>Note:</b> <b>Can</b> be used on recursive types.
derivedSameShapeSimpleFresh :: (Generic a, GenSymSameShape (Rep a), MonadFresh m) => a -> m a

-- | Symbolically chooses one of the provided values. The procedure creates
--   <tt>n - 1</tt> fresh symbolic boolean variables every time it is
--   evaluated, and use these variables to conditionally select one of the
--   <tt>n</tt> provided expressions.
--   
--   The result will be wrapped in a union-like monad, and also a monad
--   maintaining the <a>MonadFresh</a> context.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (chooseFresh [1,2,3]) "a" :: Union Integer
--   {If a@0 1 (If a@1 2 3)}
--   </pre>
chooseFresh :: (Mergeable a, MonadFresh m) => [a] -> m (Union a)

-- | Symbolically chooses one of the provided values. The procedure creates
--   <tt>n - 1</tt> fresh symbolic boolean variables every time it is
--   evaluated, and use these variables to conditionally select one of the
--   <tt>n</tt> provided expressions.
--   
--   The result will <b><i>not</i></b> be wrapped in a union-like monad,
--   but will be wrapped in a monad maintaining the <a>Fresh</a> context.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; runFresh (chooseSimpleFresh [ssym "b", ssym "c", ssym "d"]) "a" :: SymInteger
--   (ite a@0 b (ite a@1 c d))
--   </pre>
chooseSimpleFresh :: (SimpleMergeable a, MonadFresh m) => [a] -> m a

-- | Symbolically chooses one of the provided values wrapped in union-like
--   monads. The procedure creates <tt>n - 1</tt> fresh symbolic boolean
--   variables every time it is evaluated, and use these variables to
--   conditionally select one of the <tt>n</tt> provided expressions.
--   
--   The result will be wrapped in a union-like monad, and also a monad
--   maintaining the <a>Fresh</a> context.
--   
--   <pre>
--   &gt;&gt;&gt; let a = runFresh (chooseFresh [1, 2]) "a" :: Union Integer
--   
--   &gt;&gt;&gt; let b = runFresh (chooseFresh [2, 3]) "b" :: Union Integer
--   
--   &gt;&gt;&gt; runFresh (chooseUnionFresh [a, b]) "c" :: Union Integer
--   {If (&amp;&amp; c@0 a@0) 1 (If (|| c@0 b@0) 2 3)}
--   </pre>
chooseUnionFresh :: (Mergeable a, MonadFresh m) => [Union a] -> m (Union a)

-- | A wrapper for <a>chooseFresh</a> that executes the <a>MonadFresh</a>
--   context. A globally unique identifier should be supplied to ensure the
--   uniqueness of symbolic constants in the generated symbolic values.
choose :: Mergeable a => [a] -> Identifier -> Union a

-- | A wrapper for <a>chooseSimpleFresh</a> that executes the
--   <a>MonadFresh</a> context. A globally unique identifier should be
--   supplied to ensure the uniqueness of symbolic constants in the
--   generated symbolic values.
chooseSimple :: SimpleMergeable a => [a] -> Identifier -> a

-- | A wrapper for <a>chooseUnionFresh</a> that executes the
--   <a>MonadFresh</a> context. A globally unique identifier should be
--   supplied to ensure the uniqueness of symbolic constants in the
--   generated symbolic values.
chooseUnion :: Mergeable a => [Union a] -> Identifier -> Union a

-- | Specification for list generation.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (ListSpec 0 2 ())) "c" :: Union [SymBool]
--   {If c@2 [] (If c@3 [c@1] [c@0,c@1])}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (ListSpec 0 2 (SimpleListSpec 1 ()))) "c" :: Union [[SymBool]]
--   {If c@2 [] (If c@3 [[c@1]] [[c@0],[c@1]])}
--   </pre>
data ListSpec spec
ListSpec :: Int -> Int -> spec -> ListSpec spec

-- | The minimum length of the generated lists
[genListMinLength] :: ListSpec spec -> Int

-- | The maximum length of the generated lists
[genListMaxLength] :: ListSpec spec -> Int

-- | Each element in the lists will be generated with the sub-specification
[genListSubSpec] :: ListSpec spec -> spec

-- | Specification for list generation of a specific length.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (simpleFresh (SimpleListSpec 2 ())) "c" :: [SymBool]
--   [c@0,c@1]
--   </pre>
data SimpleListSpec spec
SimpleListSpec :: Int -> spec -> SimpleListSpec spec

-- | The length of the generated list
[genSimpleListLength] :: SimpleListSpec spec -> Int

-- | Each element in the list will be generated with the sub-specification
[genSimpleListSubSpec] :: SimpleListSpec spec -> spec

-- | Specification for numbers with lower bound (inclusive) and upper bound
--   (exclusive)
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (EnumGenBound @Integer 0 4)) "c" :: Union Integer
--   {If c@0 0 (If c@1 1 (If c@2 2 3))}
--   </pre>
data EnumGenBound a
EnumGenBound :: a -> a -> EnumGenBound a

-- | Specification for enum values with upper bound (exclusive). The result
--   would chosen from [0 .. upperbound].
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (EnumGenUpperBound @Integer 4)) "c" :: Union Integer
--   {If c@0 0 (If c@1 1 (If c@2 2 3))}
--   </pre>
newtype EnumGenUpperBound a
EnumGenUpperBound :: a -> EnumGenUpperBound a
instance (GHC.Internal.Base.Applicative m, GHC.Internal.Base.Monad m) => GHC.Internal.Base.Applicative (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance GHC.Classes.Eq Grisette.Internal.Core.Data.Class.GenSym.FreshIndex
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (Grisette.Internal.Core.Data.Class.GenSym.FreshT f)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec (a GHC.Internal.Generics.:*: b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec b, forall x. Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (a x), forall x. Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (b x)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec (a GHC.Internal.Generics.:+: b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () c => Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec (GHC.Internal.Generics.K1 i c)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec a => Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec (GHC.Internal.Generics.M1 i c a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymNoSpec GHC.Internal.Generics.U1
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape (a GHC.Internal.Generics.:*: b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape (a GHC.Internal.Generics.:+: b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple c c => Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape (GHC.Internal.Generics.K1 i c)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape a => Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape (GHC.Internal.Generics.M1 i c a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSameShape GHC.Internal.Generics.U1
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec (a GHC.Internal.Generics.:*: b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec (GHC.Internal.Generics.K1 i c)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec a => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec (GHC.Internal.Generics.M1 i c a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimpleNoSpec GHC.Internal.Generics.U1
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb) (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb) (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (f a) (f b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (f a) b => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a) b
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a b => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a b => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Bool GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Char GHC.Types.Char
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Double GHC.Types.Double
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (GHC.Internal.Data.Either.Either aspec bspec) (GHC.Internal.Data.Either.Either a b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (m (GHC.Internal.Data.Either.Either e a)) (m (GHC.Internal.Data.Either.Either e a)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Control.Monad.Trans.Except.ExceptT e m a) (Control.Monad.Trans.Except.ExceptT e m a)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Grisette.Internal.SymPrim.FP.FPRoundingMode Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Float GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Int.Int16 GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Int.Int32 GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Int.Int64 GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Int.Int8 GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Int GHC.Types.Int
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Num.Integer.Integer GHC.Num.Integer.Integer
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a a => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple [a] [a]
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (GHC.Internal.Maybe.Maybe aspec) (GHC.Internal.Maybe.Maybe a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (m (GHC.Internal.Maybe.Maybe a)) (m (GHC.Internal.Maybe.Maybe a)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Control.Monad.Trans.Maybe.MaybeT m a) (Control.Monad.Trans.Maybe.MaybeT m a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (GHC.Internal.Real.Ratio a) (GHC.Internal.Real.Ratio a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec a => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Data.Class.GenSym.SimpleListSpec spec) [a]
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Grisette.Internal.SymPrim.SymBool.SymBool Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Grisette.Internal.SymPrim.SymInteger.SymInteger Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple Data.Text.Internal.Text Data.Text.Internal.Text
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec) (a, b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple cspec c) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec, cspec) (a, b, c)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple cspec c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple dspec d) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec, cspec, dspec) (a, b, c, d)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple cspec c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple dspec d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple espec e) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec, cspec, dspec, espec) (a, b, c, d, e)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple cspec c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple dspec d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple espec e, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple fspec f) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec, cspec, dspec, espec, fspec) (a, b, c, d, e, f)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple cspec c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple dspec d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple espec e, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple fspec f, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple gspec g) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec, cspec, dspec, espec, fspec, gspec) (a, b, c, d, e, f, g)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple aspec a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple bspec b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple cspec c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple dspec d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple espec e, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple fspec f, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple gspec g, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple hspec h) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (aspec, bspec, cspec, dspec, espec, fspec, gspec, hspec) (a, b, c, d, e, f, g, h)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b, c)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () d) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b, c, d)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () e) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b, c, d, e)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () e, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () f) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b, c, d, e, f)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () e, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () f, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () g) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b, c, d, e, f, g)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () b, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () c, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () d, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () e, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () f, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () g, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () h) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (a, b, c, d, e, f, g, h)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () ()
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Word.Word16 GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Word.Word32 GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Word.Word64 GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Internal.Word.Word8 GHC.Internal.Word.Word8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Word GHC.Types.Word
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a b => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a (f b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (m (GHC.Internal.Data.Either.Either a b)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (Control.Monad.Trans.Except.ExceptT a m b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (m (GHC.Internal.Maybe.Maybe a)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (Control.Monad.Trans.Maybe.MaybeT m a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb) (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb) (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym (f a) (f b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym (f a) b => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f a) b
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym a b => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym a b => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.AsKey.AsKey a) b
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Bool GHC.Types.Bool
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Char GHC.Types.Char
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Double GHC.Types.Double
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (GHC.Internal.Data.Either.Either aspec bspec) (GHC.Internal.Data.Either.Either a b)
instance (GHC.Internal.Enum.Enum v, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable v) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.GenSym.EnumGenBound v) v
instance (GHC.Internal.Enum.Enum v, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable v) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.GenSym.EnumGenUpperBound v) v
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (m (GHC.Internal.Data.Either.Either e a)) (m (GHC.Internal.Data.Either.Either e a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Control.Monad.Trans.Except.ExceptT e m a) (Control.Monad.Trans.Except.ExceptT e m a)
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.FP.FP eb sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Grisette.Internal.SymPrim.FP.FPRoundingMode Grisette.Internal.SymPrim.FP.FPRoundingMode
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Float GHC.Types.Float
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Int.Int16 GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Int.Int32 GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Int.Int64 GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Int.Int8 GHC.Internal.Int.Int8
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Int GHC.Types.Int
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Num.Integer.Integer GHC.Num.Integer.Integer
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Num.Integer.Integer [a]
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym a a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym [a] [a]
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.GenSym.ListSpec spec) [a]
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (GHC.Internal.Maybe.Maybe aspec) (GHC.Internal.Maybe.Maybe a)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (m (GHC.Internal.Maybe.Maybe a)) (m (GHC.Internal.Maybe.Maybe a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Control.Monad.Trans.Maybe.MaybeT m a) (Control.Monad.Trans.Maybe.MaybeT m a)
instance (GHC.Internal.Real.Integral a, GHC.Internal.Data.Typeable.Internal.Typeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (GHC.Internal.Real.Ratio a) (GHC.Internal.Real.Ratio a)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Data.Class.GenSym.SimpleListSpec spec) [a]
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Grisette.Internal.SymPrim.SymBool.SymBool Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Grisette.Internal.SymPrim.SymInteger.SymInteger Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym Data.Text.Internal.Text Data.Text.Internal.Text
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec) (GHC.Internal.Data.Either.Either a b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec) (a, b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec, cspec) (a, b, c)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec, cspec, dspec) (a, b, c, d)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec, cspec, dspec, espec) (a, b, c, d, e)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Core.Data.Class.GenSym.GenSym fspec f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec, cspec, dspec, espec, fspec) (a, b, c, d, e, f)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Core.Data.Class.GenSym.GenSym fspec f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f, Grisette.Internal.Core.Data.Class.GenSym.GenSym gspec g, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable g) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec, cspec, dspec, espec, fspec, gspec) (a, b, c, d, e, f, g)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Core.Data.Class.GenSym.GenSym fspec f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f, Grisette.Internal.Core.Data.Class.GenSym.GenSym gspec g, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable g, Grisette.Internal.Core.Data.Class.GenSym.GenSym hspec h, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable h) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (aspec, bspec, cspec, dspec, espec, fspec, gspec, hspec) (a, b, c, d, e, f, g, h)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym a a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union a) a
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.GeneralFun.--> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (sa Grisette.Internal.SymPrim.SymGeneralFun.-~> sb)
instance (Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedPrim (ca Grisette.Internal.SymPrim.TabularFun.=-> cb), Grisette.Internal.SymPrim.Prim.Internal.Term.SupportedNonFuncPrim ca, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep ca sa, Grisette.Internal.SymPrim.Prim.Internal.Term.LinkedRep cb sb) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (sa Grisette.Internal.SymPrim.SymTabularFun.=~> sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () GHC.Types.Bool
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (GHC.Internal.Data.Either.Either a b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () Grisette.Internal.SymPrim.SymBool.SymBool
instance Grisette.Internal.SymPrim.FP.ValidFP eb sb => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (Grisette.Internal.SymPrim.SymFP.SymFP eb sb)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () Grisette.Internal.SymPrim.SymInteger.SymInteger
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (Grisette.Internal.SymPrim.SymBV.SymWordN n)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym () c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b, c)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym () c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym () d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b, c, d)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym () c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym () d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym () e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b, c, d, e)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym () c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym () d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym () e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Core.Data.Class.GenSym.GenSym () f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b, c, d, e, f)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym () c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym () d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym () e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Core.Data.Class.GenSym.GenSym () f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f, Grisette.Internal.Core.Data.Class.GenSym.GenSym () g, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable g) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b, c, d, e, f, g)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Internal.Core.Data.Class.GenSym.GenSym () c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Internal.Core.Data.Class.GenSym.GenSym () d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Internal.Core.Data.Class.GenSym.GenSym () e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Core.Data.Class.GenSym.GenSym () f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f, Grisette.Internal.Core.Data.Class.GenSym.GenSym () g, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable g, Grisette.Internal.Core.Data.Class.GenSym.GenSym () h, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable h) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (a, b, c, d, e, f, g, h)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym () ()
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Word.Word16 GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Word.Word32 GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Word.Word64 GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Internal.Word.Word8 GHC.Internal.Word.Word8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Word GHC.Types.Word
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym a b => Grisette.Internal.Core.Data.Class.GenSym.GenSym a (Grisette.Internal.Core.Data.Class.AsKey.AsKey b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSym a (f b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym a (Grisette.Internal.Core.Data.Class.AsKey.AsKey1 f b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym aspec (GHC.Internal.Maybe.Maybe a)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (m (GHC.Internal.Data.Either.Either a b)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (Control.Monad.Trans.Except.ExceptT a m b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (m (GHC.Internal.Maybe.Maybe a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union a)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable Grisette.Internal.Core.Data.Class.GenSym.FreshIndex
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m) => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.Core.Data.Class.GenSym.FreshT m a)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Internal.Base.Monad m => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance (Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m, GHC.Internal.Base.Monoid w) => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m, GHC.Internal.Base.Monoid w) => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.Reader.ReaderT r m)
instance Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.State.Strict.StateT s m)
instance Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m, GHC.Internal.Base.Monoid w) => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Grisette.Internal.Core.Data.Class.GenSym.MonadFresh m, GHC.Internal.Base.Monoid w) => Grisette.Internal.Core.Data.Class.GenSym.MonadFresh (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Control.Monad.RWS.Class.MonadRWS r w s m => Control.Monad.RWS.Class.MonadRWS r w s (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Control.Monad.Trans.Class.MonadTrans Grisette.Internal.Core.Data.Class.GenSym.FreshT
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance GHC.Internal.Num.Num Grisette.Internal.Core.Data.Class.GenSym.FreshIndex
instance GHC.Classes.Ord Grisette.Internal.Core.Data.Class.GenSym.FreshIndex
instance GHC.Internal.Show.Show Grisette.Internal.Core.Data.Class.GenSym.FreshIndex
instance GHC.Internal.Show.Show spec => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.GenSym.ListSpec spec)
instance GHC.Internal.Show.Show spec => GHC.Internal.Show.Show (Grisette.Internal.Core.Data.Class.GenSym.SimpleListSpec spec)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching m => Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SimpleMergeable1 (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SimpleMergeable Grisette.Internal.Core.Data.Class.GenSym.FreshIndex
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SimpleMergeable (Grisette.Internal.Core.Data.Class.GenSym.FreshT m a)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching m => Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m => Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge (Grisette.Internal.Core.Data.Class.GenSym.FreshT m)


module Grisette.Internal.SymPrim.SymPrim

-- | A type that is used as a constraint for all the primitive types
--   (including concrete primitives) in Grisette.
type Prim a = (Show a, Binary a, Serial a, Serialize a, NFData a, Eq a, EvalSym a, ExtractSym a, Mergeable a, PPrint a, SubstSym a, SymEq a, SymOrd a, AllSyms a, KeyEq a, KeyHashable a, Lift a, Typeable a)

-- | A type that is used as a constraint for all the symbolic primitive
--   types in Grisette.
type SymPrim a = (Prim a, ITEOp a, GenSymSimple a a)

-- | A type that is used as a constraint for all the basic symbolic
--   primitive types in Grisette.
--   
--   <a>SomeSymWordN</a> is not considered as a basic symbolic primitive
--   type.
type BasicSymPrim a = (SymPrim a, SimpleMergeable a, GenSymSimple () a, Solvable ConType a a, ConRep a, LinkedRep ConType a a, ToCon a ConType a, ToSym ConType a a, Apply a, a ~ FunType a, SupportedNonFuncPrim ConType a)


module Grisette.Internal.Unified.UnifiedBool

-- | Evaluation mode with unified <a>Bool</a> type.
class (Prim GetBool mode, UnifiedConRep GetBool mode, UnifiedSymRep GetBool mode, ConType GetBool mode ~ Bool, SymType GetBool mode ~ SymBool, ConSymConversion Bool SymBool GetBool mode, LogicalOp GetBool mode) => UnifiedBool (mode :: EvalModeTag) where {
    
    -- | Get a unified Boolean type. Resolves to <a>Bool</a> in <a>C</a> mode,
    --   and <a>SymBool</a> in <a>S</a> mode.
    type GetBool (mode :: EvalModeTag) = (bool :: Type) | bool -> mode;
}


module Grisette.Internal.Unified.Class.UnifiedSymOrd

-- | A class that provides unified comparison.
--   
--   We use this type class to help resolve the constraints for <a>Ord</a>
--   and <a>SymOrd</a>.
class UnifiedSymOrd (mode :: EvalModeTag) a
withBaseSymOrd :: UnifiedSymOrd mode a => (If (IsConMode mode) (Ord a) (SymOrd a) => r) -> r

-- | A class that provides unified lifting of comparison.
--   
--   We use this type class to help resolve the constraints for <a>Ord1</a>
--   and <a>SymOrd1</a>.
class UnifiedSymOrd1 (mode :: EvalModeTag) (f :: Type -> Type)
withBaseSymOrd1 :: UnifiedSymOrd1 mode f => (If (IsConMode mode) (Ord1 f) (SymOrd1 f) => r) -> r

-- | A class that provides unified lifting of comparison.
--   
--   We use this type class to help resolve the constraints for <a>Ord2</a>
--   and <a>SymOrd2</a>.
class UnifiedSymOrd2 (mode :: EvalModeTag) (f :: Type -> Type -> Type)
withBaseSymOrd2 :: UnifiedSymOrd2 mode f => (If (IsConMode mode) (Ord2 f) (SymOrd2 f) => r) -> r

-- | Unified <a>(.&lt;=)</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   a .&lt;= b :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
(.<=) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .<=

-- | Unified <a>(.&lt;)</a>.
(.<) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .<

-- | Unified <a>(.&gt;=)</a>.
(.>=) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .>=

-- | Unified <a>(.&gt;)</a>.
(.>) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .>

-- | Unified <a>symMax</a>.
symMax :: forall (mode :: EvalModeTag) a. (UnifiedSymOrd mode a, UnifiedITEOp mode a, DecideEvalMode mode) => a -> a -> a

-- | Unified <a>symMin</a>.
symMin :: forall (mode :: EvalModeTag) a. (UnifiedSymOrd mode a, UnifiedITEOp mode a, DecideEvalMode mode) => a -> a -> a

-- | Unified <a>mrgMax</a>.
mrgMax :: forall (mode :: EvalModeTag) a m. (UnifiedSymOrd mode a, UnifiedBranching mode m, DecideEvalMode mode, Applicative m, Mergeable a) => a -> a -> m a

-- | Unified <a>mrgMin</a>.
mrgMin :: forall (mode :: EvalModeTag) a m. (UnifiedSymOrd mode a, UnifiedBranching mode m, DecideEvalMode mode, Applicative m, Mergeable a) => a -> a -> m a


module Grisette.Internal.Unified.Class.UnifiedSymEq

-- | A class that provides unified equality comparison.
--   
--   We use this type class to help resolve the constraints for <a>Eq</a>
--   and <a>SymEq</a>.
class UnifiedSymEq (mode :: EvalModeTag) a
withBaseSymEq :: UnifiedSymEq mode a => (If (IsConMode mode) (Eq a) (SymEq a) => r) -> r

-- | A class that provides unified lifting of equality comparison.
--   
--   We use this type class to help resolve the constraints for <a>Eq1</a>
--   and <a>SymEq1</a>.
class forall a. UnifiedSymEq mode a => UnifiedSymEq mode f a => UnifiedSymEq1 (mode :: EvalModeTag) (f :: Type -> Type)
withBaseSymEq1 :: UnifiedSymEq1 mode f => (If (IsConMode mode) (Eq1 f) (SymEq1 f) => r) -> r

-- | A class that provides unified lifting of equality comparison.
--   
--   We use this type class to help resolve the constraints for <a>Eq2</a>
--   and <a>SymEq2</a>.
class forall a. UnifiedSymEq mode a => UnifiedSymEq1 mode f a => UnifiedSymEq2 (mode :: EvalModeTag) (f :: Type -> Type -> Type)
withBaseSymEq2 :: UnifiedSymEq2 mode f => (If (IsConMode mode) (Eq2 f) (SymEq2 f) => r) -> r

-- | Unified <a>(.==)</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   a .== b :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
(.==) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymEq mode a) => a -> a -> GetBool mode
infix 4 .==

-- | Unified <a>(./=)</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   a ./= b :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
(./=) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymEq mode a) => a -> a -> GetBool mode
infix 4 ./=

-- | Unified <a>symDistinct</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   symDistinct l :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
symDistinct :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymEq mode a) => [a] -> GetBool mode

-- | Unified <a>liftSymEq</a>.
liftSymEq :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymEq1 mode f) => (a -> b -> GetBool mode) -> f a -> f b -> GetBool mode

-- | Unified <a>symEq1</a>.
symEq1 :: forall (mode :: EvalModeTag) f a. (DecideEvalMode mode, UnifiedSymEq mode a, UnifiedSymEq1 mode f) => f a -> f a -> GetBool mode

-- | Unified <a>liftSymEq2</a>.
liftSymEq2 :: forall (mode :: EvalModeTag) f a b c d. (DecideEvalMode mode, UnifiedSymEq2 mode f) => (a -> b -> GetBool mode) -> (c -> d -> GetBool mode) -> f a c -> f b d -> GetBool mode

-- | Unified <a>symEq2</a>.
symEq2 :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymEq mode a, UnifiedSymEq mode b, UnifiedSymEq2 mode f) => f a b -> f a b -> GetBool mode


module Grisette.Internal.Unified.Class.UnifiedITEOp

-- | Unified <a>symIte</a> operation.
--   
--   This function isn't able to infer the mode of the boolean variable, so
--   you need to provide the mode explicitly. For example:
--   
--   <pre>
--   symIte @mode (a .== b) ...
--   symIte (a .== b :: SymBool) ...
--   symIte (a .== b :: GetBool mode) ...
--   </pre>
symIte :: forall (mode :: EvalModeTag) v. (DecideEvalMode mode, UnifiedITEOp mode v) => GetBool mode -> v -> v -> v

-- | Unified <a>symIteMerge</a> operation.
--   
--   This function isn't able to infer the mode of the base monad from the
--   result, so you need to provide the mode explicitly. For example:
--   
--   <pre>
--   symIteMerge @mode ...
--   symIteMerge (... :: GetData mode v) ...
--   </pre>
symIteMerge :: forall (mode :: EvalModeTag) u v. (DecideEvalMode mode, UnifiedITEOp mode v, Mergeable v, UnionViewMode mode u, UnionView u) => u v -> v

-- | A class that provides unified equality comparison.
--   
--   We use this type class to help resolve the constraints for
--   <a>ITEOp</a>.
class UnifiedITEOp (mode :: EvalModeTag) v
withBaseITEOp :: UnifiedITEOp mode v => (If (IsConMode mode) () (ITEOp v) => r) -> r


module Grisette.Internal.SymPrim.SomeBV

-- | Non-indexed bitvectors.
--   
--   The creation of <a>SomeBV</a> can be done with the <a>bv</a> function
--   with a positive bit width and a value:
--   
--   <pre>
--   &gt;&gt;&gt; bv 4 0xf :: SomeBV IntN
--   0xf
--   </pre>
--   
--   Operations on two <a>SomeBV</a> values require the bitwidths to be the
--   same. So you should check for the bit width (via <a>finiteBitSize</a>)
--   before performing operations:
--   
--   <pre>
--   &gt;&gt;&gt; bv 4 0x3 + bv 4 0x3 :: SomeBV IntN
--   0x6
--   
--   &gt;&gt;&gt; bv 4 0x3 + bv 8 0x3 :: SomeBV IntN
--   *** Exception: BitwidthMismatch
--   </pre>
--   
--   One exception is that the equality testing (both concrete and symbolic
--   via <a>SymEq</a>) does not require the bitwidths to be the same.
--   Different bitwidths means the values are not equal:
--   
--   <pre>
--   &gt;&gt;&gt; (bv 4 0x3 :: SomeBV IntN) == (bv 8 0x3)
--   False
--   </pre>
--   
--   <b>Note</b>: <a>SomeBV</a> can be constructed out of integer literals
--   without the bit width provided. Further binary operations will usually
--   require at least one operand has the bit-width, and will use that as
--   the bit-width for the result.
--   
--   For example:
--   
--   3 :: SomeBV IntN bvlit(3) &gt;&gt;&gt; bv 4 0x1 + 3 :: SomeBV IntN 0x4
--   &gt;&gt;&gt; 3 * bv 4 0x1 :: SomeBV IntN 0x3 &gt;&gt;&gt; 3 * 3 ::
--   SomeBV IntN *** Exception: UndeterminedBitwidth "(*)"
--   
--   Some operations allows the literals to be used without the bit-width,
--   such as <a>(+)</a>, <a>(-)</a>, <a>negate</a>, <a>toUnsigned</a>,
--   <a>toSigned</a>, <a>.&amp;.</a>, <a>.|.</a>, <a>xor</a>,
--   <a>complement</a>, <a>setBit</a>, <a>clearBit</a>,
--   <a>complementBit</a>, <a>shiftL</a>, and <a>unsafeShiftL</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 3 + 3 :: SomeBV IntN
--   bvlit(6)
--   </pre>
data SomeBV (bv :: Nat -> Type)
[SomeBV] :: forall (n :: Nat) (bv :: Nat -> Type). (KnownNat n, 1 <= n) => bv n -> SomeBV bv
[SomeBVLit] :: forall (bv :: Nat -> Type). SomeBVLit -> SomeBV bv

-- | <tt><a>SomeBV</a> bv</tt> type with identity equality.
type SomeBVKey (bv :: Nat -> Type) = AsKey SomeBV bv

-- | An exception that would be thrown when operations are performed on
--   incompatible bit widths.
data SomeBVException
BitwidthMismatch :: SomeBVException
UndeterminedBitwidth :: Text -> SomeBVException

-- | Construct a <a>SomeBV</a> with a given run-time bitwidth and a
--   polymorphic value for the underlying bitvector.
unsafeSomeBV :: Int -> (forall (proxy :: Nat -> Type) (n :: Nat). (KnownNat n, 1 <= n) => proxy n -> bv n) -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given concrete
--   <a>SomeBV</a>. Similar to <a>con</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a = bv 8 0x12 :: SomeIntN
--   
--   &gt;&gt;&gt; conBV a :: SomeSymIntN
--   0x12
--   </pre>
conBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => SomeBV cbv -> SomeBV bv

-- | View pattern for symbolic <a>SomeBV</a> to see if it contains a
--   concrete value and extract it. Similar to <a>conView</a> but for
--   <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; conBVView (bv 8 0x12 :: SomeSymIntN)
--   Just 0x12
--   
--   &gt;&gt;&gt; conBVView (ssymBV 4 "a" :: SomeSymIntN)
--   Nothing
--   </pre>
conBVView :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => SomeBV bv -> Maybe (SomeBV cbv)

-- | Pattern synonym for symbolic <a>SomeBV</a> to see if it contains a
--   concrete value and extract it. Similar to <a>Con</a> but for
--   <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; case (bv 8 0x12 :: SomeSymIntN) of { ConBV c -&gt; c; _ -&gt; error "impossible" }
--   0x12
--   </pre>
pattern ConBV :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => SomeBV cbv -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given run-time bitwidth and
--   a symbol. Similar to <a>sym</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; symBV 8 "a" :: SomeSymIntN
--   a
--   </pre>
symBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => Int -> Symbol -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given run-time bitwidth and
--   an identifier. Similar to <a>ssym</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ssymBV 8 "a" :: SomeSymIntN
--   a
--   </pre>
ssymBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => Int -> Identifier -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given run-time bitwidth, an
--   identifier and an index. Similar to <a>isym</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; isymBV 8 "a" 1 :: SomeSymIntN
--   a@1
--   </pre>
isymBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => Int -> Identifier -> Int -> SomeBV bv

-- | Generate an arbitrary <a>SomeBV</a> with a given run-time bitwidth.
arbitraryBV :: forall (bv :: Nat -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Arbitrary (bv n)) => Int -> Gen (SomeBV bv)

-- | Pattern synonym for <a>SomeBV</a> for concrete signed bitvectors.
pattern SomeIntN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => IntN n -> SomeIntN

-- | Type synonym for <a>SomeBV</a> for concrete signed bitvectors.
type SomeIntN = SomeBV IntN

-- | Pattern synonym for <a>SomeBV</a> for concrete unsigned bitvectors.
pattern SomeWordN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => WordN n -> SomeWordN

-- | Type synonym for <a>SomeBV</a> for concrete unsigned bitvectors.
type SomeWordN = SomeBV WordN

-- | Pattern synonym for <a>SomeBV</a> for symbolic signed bitvectors.
pattern SomeSymIntN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymIntN n -> SomeSymIntN

-- | Type synonym for <a>SomeBV</a> for symbolic signed bitvectors.
type SomeSymIntN = SomeBV SymIntN
pattern SomeSymIntNKey :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymIntN n -> SomeSymIntNKey

-- | <a>SomeSymIntN</a> with identity equality.
type SomeSymIntNKey = SomeBVKey SymIntN

-- | Pattern synonym for <a>SomeBV</a> for symbolic unsigned bitvectors.
pattern SomeSymWordN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymWordN n -> SomeSymWordN

-- | Type synonym for <a>SomeBV</a> for symbolic unsigned bitvectors.
type SomeSymWordN = SomeBV SymWordN
pattern SomeSymWordNKey :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymWordN n -> SomeSymWordNKey

-- | <a>SomeSymWordN</a> with identity equality.
type SomeSymWordNKey = SomeBVKey SymWordN

-- | Lift a unary operation on sized bitvectors that returns anything to
--   <a>SomeBV</a>.
unarySomeBV :: (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> r) -> (SomeBVLit -> r) -> SomeBV bv -> r

-- | Lift a unary operation on sized bitvectors that returns a bitvector to
--   <a>SomeBV</a>. The result will also be wrapped with <a>SomeBV</a>.
unarySomeBVR1 :: (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n) -> (SomeBVLit -> SomeBVLit) -> SomeBV bv -> SomeBV bv

-- | Lift a binary operation on sized bitvectors that returns anything to
--   <a>SomeBV</a>. Crash if the bitwidths do not match.
binSomeBV :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> r) -> (SomeBVLit -> SomeBVLit -> r) -> SomeBV bv -> SomeBV bv -> r

-- | Lift a binary operation on sized bitvectors that returns a bitvector
--   to <a>SomeBV</a>. The result will also be wrapped with <a>SomeBV</a>.
--   Crash if the bitwidths do not match.
binSomeBVR1 :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> bv n) -> (SomeBVLit -> SomeBVLit -> SomeBVLit) -> SomeBV bv -> SomeBV bv -> SomeBV bv

-- | Lift a binary operation on sized bitvectors that returns two
--   bitvectors to <a>SomeBV</a>. The results will also be wrapped with
--   <a>SomeBV</a>. Crash if the bitwidths do not match.
binSomeBVR2 :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> (bv n, bv n)) -> (SomeBVLit -> SomeBVLit -> (SomeBVLit, SomeBVLit)) -> SomeBV bv -> SomeBV bv -> (SomeBV bv, SomeBV bv)

-- | Lift a binary operation on sized bitvectors that returns anything
--   wrapped with <a>ExceptT</a> to <a>SomeBV</a>. If the bitwidths do not
--   match, throw an <a>BitwidthMismatch</a> error to the monadic context.
binSomeBVSafe :: (MonadError (Either SomeBVException e) m, TryMerge m, Mergeable e, Mergeable r, forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> ExceptT e m r) -> (SomeBVLit -> SomeBVLit -> ExceptT (Either SomeBVException e) m r) -> SomeBV bv -> SomeBV bv -> m r

-- | Lift a binary operation on sized bitvectors that returns a bitvector
--   wrapped with <a>ExceptT</a> to <a>SomeBV</a>. The result will also be
--   wrapped with <a>SomeBV</a>.
--   
--   If the bitwidths do not match, throw an <a>BitwidthMismatch</a> error
--   to the monadic context.
binSomeBVSafeR1 :: (MonadError (Either SomeBVException e) m, TryMerge m, Mergeable e, forall (n :: Nat). (KnownNat n, 1 <= n) => Mergeable (bv n), forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> ExceptT e m (bv n)) -> (SomeBVLit -> SomeBVLit -> ExceptT (Either SomeBVException e) m SomeBVLit) -> SomeBV bv -> SomeBV bv -> m (SomeBV bv)

-- | Lift a binary operation on sized bitvectors that returns two
--   bitvectors wrapped with <a>ExceptT</a> to <a>SomeBV</a>. The results
--   will also be wrapped with <a>SomeBV</a>.
--   
--   If the bitwidths do not match, throw an <a>BitwidthMismatch</a> error
--   to the monadic context.
binSomeBVSafeR2 :: (MonadError (Either SomeBVException e) m, TryMerge m, Mergeable e, forall (n :: Nat). (KnownNat n, 1 <= n) => Mergeable (bv n), forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> ExceptT e m (bv n, bv n)) -> (SomeBVLit -> SomeBVLit -> ExceptT (Either SomeBVException e) m (SomeBVLit, SomeBVLit)) -> SomeBV bv -> SomeBV bv -> m (SomeBV bv, SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.SymPrim.AllSyms.AllSyms Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.SymPrim.SomeBV.AssignBitWidth (Grisette.Internal.SymPrim.SomeBV.SomeBV bv, Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.SymPrim.SomeBV.AssignBitWidth (Grisette.Internal.SymPrim.SomeBV.SomeBV bv, Grisette.Internal.SymPrim.SomeBV.SomeBV bv, Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.SymPrim.SomeBV.AssignBitWidth (Grisette.Internal.SymPrim.SomeBV.SomeBV bv, Grisette.Internal.SymPrim.SomeBV.SomeBV bv, Grisette.Internal.SymPrim.SomeBV.SomeBV bv, Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Core.Data.Class.BitVector.SizedBV bv => Grisette.Internal.Core.Data.Class.BitVector.BV (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (bv n)) => Data.Binary.Class.Binary (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Data.Binary.Class.Binary Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.Bits (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Internal.Bits.Bits (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Internal.Bits.Bits Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.SafeDiv.DivOr (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Internal.Decl.Core.Data.Class.SafeDiv.DivOr (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Enum.Enum (bv n)) => GHC.Internal.Enum.Enum (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SomeBV.CompileTimeNat
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Eq (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Classes.Eq (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance GHC.Classes.Eq Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym (bv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance GHC.Internal.Exception.Type.Exception Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym (bv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Bits.FiniteBits (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Internal.Bits.FiniteBits (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (bv n), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple GHC.Types.Int (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, forall (m :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (bv m), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (GHC.Internal.Data.Proxy.Proxy n) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (m :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple () (bv m), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.SymPrim.SomeBV.SomeBV bv) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (bv n), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)) => Grisette.Internal.Core.Data.Class.GenSym.GenSym GHC.Types.Int (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, forall (m :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (bv m), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (GHC.Internal.Data.Proxy.Proxy n) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (m :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat m, 1 GHC.Internal.Data.Type.Ord.<= m) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (bv m), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.SymPrim.SomeBV.SomeBV bv) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance GHC.Internal.Generics.Generic Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Hashable.Class.Hashable (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Data.Hashable.Class.Hashable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance Data.Hashable.Class.Hashable Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.ITEOp.ITEOp (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Integral (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Internal.Real.Integral (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.AsKey.KeyEq (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyEq Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.AsKey.KeyHashable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Core.Data.Class.AsKey.KeyHashable Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Language.Haskell.TH.Syntax.Lift (bv n)) => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Language.Haskell.TH.Syntax.Lift Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance Grisette.Internal.SymPrim.SomeBV.MaySomeBV Grisette.Internal.SymPrim.BV.IntN
instance Grisette.Internal.SymPrim.SomeBV.MaySomeBV Grisette.Internal.SymPrim.SymBV.SymIntN
instance Grisette.Internal.SymPrim.SomeBV.MaySomeBV Grisette.Internal.SymPrim.SymBV.SymWordN
instance Grisette.Internal.SymPrim.SomeBV.MaySomeBV Grisette.Internal.SymPrim.BV.WordN
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (bv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Control.DeepSeq.NFData (bv n)) => Control.DeepSeq.NFData (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance Control.DeepSeq.NFData Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Internal.Num.Num (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Internal.Num.Num Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance GHC.Classes.Ord Grisette.Internal.SymPrim.SomeBV.CompileTimeNat
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Classes.Ord (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Classes.Ord (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Classes.Ord Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint (bv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.PPrint Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Real.Real (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => GHC.Internal.Real.Real (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.SafeDiv.SafeDiv e (bv n) (Control.Monad.Trans.Except.ExceptT e m), Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Internal.Decl.Core.Data.Class.SafeDiv.SafeDiv (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv) m
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith e (bv n) (Control.Monad.Trans.Except.ExceptT e m), Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv) m
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate e (bv n) (Control.Monad.Trans.Except.ExceptT e m), Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv) m
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift e (bv n) (Control.Monad.Trans.Except.ExceptT e m), Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) m, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException e) (Grisette.Internal.SymPrim.SomeBV.SomeBV bv) m
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (bv n)) => Data.Bytes.Serial.Serial (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Data.Bytes.Serial.Serial Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Data.Bytes.Serial.Serial (bv n)) => Data.Serialize.Serialize (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Data.Serialize.Serialize Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SomeBV.CompileTimeNat
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Show.Show (bv n)) => GHC.Internal.Show.Show (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance GHC.Internal.Show.Show Grisette.Internal.SymPrim.SomeBV.SomeBVLit
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SignConversion.SignConversion (ubv n) (sbv n), Grisette.Internal.Core.Data.Class.SignConversion.SignConversion (ubv 1) (sbv 1)) => Grisette.Internal.Core.Data.Class.SignConversion.SignConversion (Grisette.Internal.SymPrim.SomeBV.SomeBV ubv) (Grisette.Internal.SymPrim.SomeBV.SomeBV sbv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.SubstSym.SubstSym (bv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.SubstSym.SubstSym (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SubstSym.SubstSym Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.SymRotate.SymRotate (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (bv n), forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => GHC.Internal.Num.Num (bv n), Grisette.Internal.SymPrim.SomeBV.MaySomeBV bv) => Grisette.Internal.Core.Data.Class.SymShift.SymShift (Grisette.Internal.SymPrim.SomeBV.SomeBV bv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon Grisette.Internal.SymPrim.SomeBV.SomeBVException Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (sbv n) (cbv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (Grisette.Internal.SymPrim.SomeBV.SomeBV sbv) (Grisette.Internal.SymPrim.SomeBV.SomeBV cbv)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym Grisette.Internal.SymPrim.SomeBV.SomeBVException Grisette.Internal.SymPrim.SomeBV.SomeBVException
instance (forall (n :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym (cbv n) (sbv n)) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym (Grisette.Internal.SymPrim.SomeBV.SomeBV cbv) (Grisette.Internal.SymPrim.SomeBV.SomeBV sbv)


module Grisette.Internal.Core.Data.Class.SymFiniteBits

-- | Extract the least significant bit of a concrete value.
lsb :: Bits a => a -> Bool

-- | Extract the most significant bit of a concrete value.
msb :: FiniteBits a => a -> Bool

-- | Set a bit in a concrete value to a specific value.
setBitTo :: Bits a => a -> Int -> Bool -> a

-- | Bit-blast a concrete value into a list of concrete bits. The first
--   element in the resulting list corresponds to the least significant
--   bit.
bitBlast :: FiniteBits a => a -> [Bool]

-- | Type class for assembling concrete bits to a bit-vector.
class FiniteBits a => FromBits a

-- | Assembling concrete bits to a bit-vector. The first boolean value in
--   the list corresponding to the least signification value.
fromBits :: FromBits a => [Bool] -> a

-- | A class for symbolic finite bit operations.
class (FiniteBits a, ITEOp a) => SymFiniteBits a

-- | Test a symbolic bit in a symbolic bit-vector.
symTestBit :: SymFiniteBits a => a -> Int -> SymBool

-- | Set a bit in a symbolic value to a specific value.
symSetBitTo :: SymFiniteBits a => a -> Int -> SymBool -> a

-- | Assembling symbolic bits to a symbolic bit-vector. The first symbolic
--   boolean value in the list corresponding to the least signification
--   value.
symFromBits :: SymFiniteBits a => [SymBool] -> a

-- | Bit-blast a symbolic value into a list of symbolic bits. The first
--   element in the resulting list corresponds to the least significant
--   bit.
symBitBlast :: SymFiniteBits a => a -> [SymBool]

-- | Extract the least significant bit of a symbolic value.
symLsb :: SymFiniteBits a => a -> SymBool

-- | Extract the most significant bit of a symbolic value.
symMsb :: SymFiniteBits a => a -> SymBool

-- | Count the number of set bits in a symbolic value.
symPopCount :: (Num a, ITEOp a, SymFiniteBits a) => a -> a

-- | Count the number of leading zeros in a symbolic value.
symCountLeadingZeros :: (Num a, ITEOp a, SymFiniteBits a) => a -> a

-- | Count the number of trailing zeros in a symbolic value.
symCountTrailingZeros :: (Num a, ITEOp a, SymFiniteBits a) => a -> a
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Types.Int
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Int.Int16
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Int.Int32
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Int.Int64
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Int.Int8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits Grisette.Internal.SymPrim.SomeBV.SomeIntN
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits Grisette.Internal.SymPrim.SomeBV.SomeWordN
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Types.Word
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Word.Word16
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Word.Word32
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Word.Word64
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits GHC.Internal.Word.Word8
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFiniteBits.FromBits (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.SymFiniteBits (Grisette.Internal.SymPrim.SomeBV.SomeBV Grisette.Internal.SymPrim.SymBV.SymIntN)
instance Grisette.Internal.Core.Data.Class.SymFiniteBits.SymFiniteBits (Grisette.Internal.SymPrim.SomeBV.SomeBV Grisette.Internal.SymPrim.SymBV.SymWordN)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFiniteBits.SymFiniteBits (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Core.Data.Class.SymFiniteBits.SymFiniteBits (Grisette.Internal.SymPrim.SymBV.SymWordN n)


module Grisette.Internal.Unified.Class.UnifiedFiniteBits

-- | A class that provides unified equality comparison.
--   
--   We use this type class to help resolve the constraints for
--   <a>FiniteBits</a>, <a>FromBits</a> and <a>SymFiniteBits</a>.
class UnifiedFiniteBits (mode :: EvalModeTag) a
withBaseFiniteBits :: UnifiedFiniteBits mode a => (If (IsConMode mode) (FiniteBits a, FromBits a) (SymFiniteBits a) => r) -> r

-- | Unified <a>symTestBit</a>.
symTestBit :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> Int -> GetBool mode

-- | Unified <a>symSetBitTo</a>.
symSetBitTo :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> Int -> GetBool mode -> a

-- | Unified <a>symFromBits</a>.
symFromBits :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => [GetBool mode] -> a

-- | Unified <a>symBitBlast</a>.
symBitBlast :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> [GetBool mode]

-- | Unified <a>symLsb</a>.
symLsb :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> GetBool mode

-- | Unified <a>symMsb</a>.
symMsb :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> GetBool mode

-- | Unified <a>symPopCount</a>.
symPopCount :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a, Num a, UnifiedITEOp mode a) => a -> a

-- | Unified <a>symCountLeadingZeros</a>.
symCountLeadingZeros :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a, Num a, UnifiedITEOp mode a) => a -> a

-- | Unified <a>symCountTrailingZeros</a>.
symCountTrailingZeros :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a, Num a, UnifiedITEOp mode a) => a -> a
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.IntN n)
instance Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.SomeBV.SomeWordN
instance Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.SomeBV.SomeIntN
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.C (Grisette.Internal.SymPrim.BV.WordN n)
instance Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SomeBV.SomeSymWordN
instance Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SomeBV.SomeSymIntN
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymIntN n)
instance (GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedFiniteBits.UnifiedFiniteBits 'Grisette.Internal.Unified.EvalModeTag.S (Grisette.Internal.SymPrim.SymBV.SymWordN n)


module Grisette.Internal.SymPrim.Quantifier

-- | Forall quantifier over a set of constant symbols. Quantifier over
--   functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let xsym = "x" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let ysym = "y" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let x = "x" :: SymInteger
--   
--   &gt;&gt;&gt; let y = "y" :: SymInteger
--   
--   &gt;&gt;&gt; forallSet (buildSymbolSet [xsym, ysym]) (x .== y)
--   (forall x :: Integer (forall y :: Integer (= x y)))
--   </pre>
--   
--   Only available with SBV 10.1.0 or later.
forallSet :: ConstantSymbolSet -> SymBool -> SymBool

-- | Forall quantifier over all symbolic constants in a value. Quantifier
--   over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let a = ["x", "y"] :: [SymInteger]
--   
--   &gt;&gt;&gt; forallSym a $ sum a .== 0
--   (forall x :: Integer (forall y :: Integer (= (+ x y) 0)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
forallSym :: (HasCallStack, ExtractSym a) => a -> SymBool -> SymBool

-- | Exists quantifier over a set of constant symbols. Quantifier over
--   functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let xsym = "x" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let ysym = "y" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let x = "x" :: SymInteger
--   
--   &gt;&gt;&gt; let y = "y" :: SymInteger
--   
--   &gt;&gt;&gt; existsSet (buildSymbolSet [xsym, ysym]) (x .== y)
--   (exists x :: Integer (exists y :: Integer (= x y)))
--   </pre>
--   
--   Only available with SBV 10.1.0 or later.
existsSet :: ConstantSymbolSet -> SymBool -> SymBool

-- | Exists quantifier over all symbolic constants in a value. Quantifier
--   over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let a = ["x", "y"] :: [SymInteger]
--   
--   &gt;&gt;&gt; existsSym a $ sum a .== 0
--   (exists x :: Integer (exists y :: Integer (= (+ x y) 0)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
existsSym :: (HasCallStack, ExtractSym a) => a -> SymBool -> SymBool

-- | Forall quantifier over symbolic constants in a freshly generated
--   value. Quantifier over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   x :: Fresh SymBool
--   x = forallFresh () $ \(a :: SymBool) -&gt;
--         existsFresh () $ \(b :: SymBool) -&gt;
--           mrgReturn $ a .== b
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runFresh x "x"
--   (forall x@0 :: Bool (exists x@1 :: Bool (= x@0 x@1)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
forallFresh :: (HasCallStack, ExtractSym v, MonadFresh m, GenSym spec v, TryMerge m) => spec -> (v -> FreshT Union SymBool) -> m SymBool

-- | Exists quantifier over symbolic constants in a freshly generated
--   value. Quantifier over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   x :: Fresh SymBool
--   x = forallFresh () $ \(a :: SymBool) -&gt;
--         existsFresh () $ \(b :: SymBool) -&gt;
--           mrgReturn $ a .== b
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runFresh x "x"
--   (forall x@0 :: Bool (exists x@1 :: Bool (= x@0 x@1)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
existsFresh :: (HasCallStack, ExtractSym v, MonadFresh m, GenSym spec v, TryMerge m) => spec -> (v -> FreshT Union SymBool) -> m SymBool


module Grisette.SymPrim

-- | Signed bit vector type. Indexed with the bit width. Signedness affects
--   the semantics of the operations, including comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; 3 + 5 :: IntN 5
--   0b01000
--   
--   &gt;&gt;&gt; sizedBVConcat (0b101 :: IntN 3) (0b110 :: IntN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: IntN 3)
--   0b111101
--   
--   &gt;&gt;&gt; (8 :: IntN 4) &lt; (7 :: IntN 4)
--   True
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
data IntN (n :: Nat)

-- | 8-bit signed bit-vector
type IntN8 = IntN 8

-- | 16-bit signed bit-vector
type IntN16 = IntN 16

-- | 32-bit signed bit-vector
type IntN32 = IntN 32

-- | 64-bit signed bit-vector
type IntN64 = IntN 64

-- | Unsigned bit vector type. Indexed with the bit width. Signedness
--   affect the semantics of the operations, including
--   comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; 3 + 5 :: WordN 5
--   0b01000
--   
--   &gt;&gt;&gt; sizedBVConcat (0b101 :: WordN 3) (0b110 :: WordN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: WordN 3)
--   0b000101
--   
--   &gt;&gt;&gt; (8 :: WordN 4) &lt; (7 :: WordN 4)
--   False
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
data WordN (n :: Nat)

-- | 8-bit unsigned bit-vector
type WordN8 = WordN 8

-- | 16-bit unsigned bit-vector
type WordN16 = WordN 16

-- | 32-bit unsigned bit-vector
type WordN32 = WordN 32

-- | 64-bit unsigned bit-vector
type WordN64 = WordN 64

-- | Non-indexed bitvectors.
--   
--   The creation of <a>SomeBV</a> can be done with the <a>bv</a> function
--   with a positive bit width and a value:
--   
--   <pre>
--   &gt;&gt;&gt; bv 4 0xf :: SomeBV IntN
--   0xf
--   </pre>
--   
--   Operations on two <a>SomeBV</a> values require the bitwidths to be the
--   same. So you should check for the bit width (via <a>finiteBitSize</a>)
--   before performing operations:
--   
--   <pre>
--   &gt;&gt;&gt; bv 4 0x3 + bv 4 0x3 :: SomeBV IntN
--   0x6
--   
--   &gt;&gt;&gt; bv 4 0x3 + bv 8 0x3 :: SomeBV IntN
--   *** Exception: BitwidthMismatch
--   </pre>
--   
--   One exception is that the equality testing (both concrete and symbolic
--   via <a>SymEq</a>) does not require the bitwidths to be the same.
--   Different bitwidths means the values are not equal:
--   
--   <pre>
--   &gt;&gt;&gt; (bv 4 0x3 :: SomeBV IntN) == (bv 8 0x3)
--   False
--   </pre>
--   
--   <b>Note</b>: <a>SomeBV</a> can be constructed out of integer literals
--   without the bit width provided. Further binary operations will usually
--   require at least one operand has the bit-width, and will use that as
--   the bit-width for the result.
--   
--   For example:
--   
--   3 :: SomeBV IntN bvlit(3) &gt;&gt;&gt; bv 4 0x1 + 3 :: SomeBV IntN 0x4
--   &gt;&gt;&gt; 3 * bv 4 0x1 :: SomeBV IntN 0x3 &gt;&gt;&gt; 3 * 3 ::
--   SomeBV IntN *** Exception: UndeterminedBitwidth "(*)"
--   
--   Some operations allows the literals to be used without the bit-width,
--   such as <a>(+)</a>, <a>(-)</a>, <a>negate</a>, <a>toUnsigned</a>,
--   <a>toSigned</a>, <a>.&amp;.</a>, <a>.|.</a>, <a>xor</a>,
--   <a>complement</a>, <a>setBit</a>, <a>clearBit</a>,
--   <a>complementBit</a>, <a>shiftL</a>, and <a>unsafeShiftL</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 3 + 3 :: SomeBV IntN
--   bvlit(6)
--   </pre>
data SomeBV (bv :: Nat -> Type)
[SomeBV] :: forall (n :: Nat) (bv :: Nat -> Type). (KnownNat n, 1 <= n) => bv n -> SomeBV bv
[SomeBVLit] :: forall (bv :: Nat -> Type). SomeBVLit -> SomeBV bv

-- | <tt><a>SomeBV</a> bv</tt> type with identity equality.
type SomeBVKey (bv :: Nat -> Type) = AsKey SomeBV bv

-- | An exception that would be thrown when operations are performed on
--   incompatible bit widths.
data SomeBVException
BitwidthMismatch :: SomeBVException
UndeterminedBitwidth :: Text -> SomeBVException

-- | Pattern synonym for <a>SomeBV</a> for concrete signed bitvectors.
pattern SomeIntN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => IntN n -> SomeIntN

-- | Type synonym for <a>SomeBV</a> for concrete signed bitvectors.
type SomeIntN = SomeBV IntN

-- | Pattern synonym for <a>SomeBV</a> for concrete unsigned bitvectors.
pattern SomeWordN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => WordN n -> SomeWordN

-- | Type synonym for <a>SomeBV</a> for concrete unsigned bitvectors.
type SomeWordN = SomeBV WordN

-- | Construct a symbolic <a>SomeBV</a> with a given concrete
--   <a>SomeBV</a>. Similar to <a>con</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a = bv 8 0x12 :: SomeIntN
--   
--   &gt;&gt;&gt; conBV a :: SomeSymIntN
--   0x12
--   </pre>
conBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => SomeBV cbv -> SomeBV bv

-- | View pattern for symbolic <a>SomeBV</a> to see if it contains a
--   concrete value and extract it. Similar to <a>conView</a> but for
--   <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; conBVView (bv 8 0x12 :: SomeSymIntN)
--   Just 0x12
--   
--   &gt;&gt;&gt; conBVView (ssymBV 4 "a" :: SomeSymIntN)
--   Nothing
--   </pre>
conBVView :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => SomeBV bv -> Maybe (SomeBV cbv)

-- | Pattern synonym for symbolic <a>SomeBV</a> to see if it contains a
--   concrete value and extract it. Similar to <a>Con</a> but for
--   <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; case (bv 8 0x12 :: SomeSymIntN) of { ConBV c -&gt; c; _ -&gt; error "impossible" }
--   0x12
--   </pre>
pattern ConBV :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => SomeBV cbv -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given run-time bitwidth and
--   a symbol. Similar to <a>sym</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; symBV 8 "a" :: SomeSymIntN
--   a
--   </pre>
symBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => Int -> Symbol -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given run-time bitwidth and
--   an identifier. Similar to <a>ssym</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ssymBV 8 "a" :: SomeSymIntN
--   a
--   </pre>
ssymBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => Int -> Identifier -> SomeBV bv

-- | Construct a symbolic <a>SomeBV</a> with a given run-time bitwidth, an
--   identifier and an index. Similar to <a>isym</a> but for <a>SomeBV</a>.
--   
--   <pre>
--   &gt;&gt;&gt; isymBV 8 "a" 1 :: SomeSymIntN
--   a@1
--   </pre>
isymBV :: forall (cbv :: Natural -> Type) (bv :: Natural -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Solvable (cbv n) (bv n), Solvable (cbv 1) (bv 1)) => Int -> Identifier -> Int -> SomeBV bv

-- | Generate an arbitrary <a>SomeBV</a> with a given run-time bitwidth.
arbitraryBV :: forall (bv :: Nat -> Type). (forall (n :: Nat). (KnownNat n, 1 <= n) => Arbitrary (bv n)) => Int -> Gen (SomeBV bv)

-- | Construct a <a>SomeBV</a> with a given run-time bitwidth and a
--   polymorphic value for the underlying bitvector.
unsafeSomeBV :: Int -> (forall (proxy :: Nat -> Type) (n :: Nat). (KnownNat n, 1 <= n) => proxy n -> bv n) -> SomeBV bv

-- | Lift a unary operation on sized bitvectors that returns anything to
--   <a>SomeBV</a>.
unarySomeBV :: (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> r) -> (SomeBVLit -> r) -> SomeBV bv -> r

-- | Lift a unary operation on sized bitvectors that returns a bitvector to
--   <a>SomeBV</a>. The result will also be wrapped with <a>SomeBV</a>.
unarySomeBVR1 :: (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n) -> (SomeBVLit -> SomeBVLit) -> SomeBV bv -> SomeBV bv

-- | Lift a binary operation on sized bitvectors that returns anything to
--   <a>SomeBV</a>. Crash if the bitwidths do not match.
binSomeBV :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> r) -> (SomeBVLit -> SomeBVLit -> r) -> SomeBV bv -> SomeBV bv -> r

-- | Lift a binary operation on sized bitvectors that returns a bitvector
--   to <a>SomeBV</a>. The result will also be wrapped with <a>SomeBV</a>.
--   Crash if the bitwidths do not match.
binSomeBVR1 :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> bv n) -> (SomeBVLit -> SomeBVLit -> SomeBVLit) -> SomeBV bv -> SomeBV bv -> SomeBV bv

-- | Lift a binary operation on sized bitvectors that returns two
--   bitvectors to <a>SomeBV</a>. The results will also be wrapped with
--   <a>SomeBV</a>. Crash if the bitwidths do not match.
binSomeBVR2 :: (forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> (bv n, bv n)) -> (SomeBVLit -> SomeBVLit -> (SomeBVLit, SomeBVLit)) -> SomeBV bv -> SomeBV bv -> (SomeBV bv, SomeBV bv)

-- | Lift a binary operation on sized bitvectors that returns anything
--   wrapped with <a>ExceptT</a> to <a>SomeBV</a>. If the bitwidths do not
--   match, throw an <a>BitwidthMismatch</a> error to the monadic context.
binSomeBVSafe :: (MonadError (Either SomeBVException e) m, TryMerge m, Mergeable e, Mergeable r, forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> ExceptT e m r) -> (SomeBVLit -> SomeBVLit -> ExceptT (Either SomeBVException e) m r) -> SomeBV bv -> SomeBV bv -> m r

-- | Lift a binary operation on sized bitvectors that returns a bitvector
--   wrapped with <a>ExceptT</a> to <a>SomeBV</a>. The result will also be
--   wrapped with <a>SomeBV</a>.
--   
--   If the bitwidths do not match, throw an <a>BitwidthMismatch</a> error
--   to the monadic context.
binSomeBVSafeR1 :: (MonadError (Either SomeBVException e) m, TryMerge m, Mergeable e, forall (n :: Nat). (KnownNat n, 1 <= n) => Mergeable (bv n), forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> ExceptT e m (bv n)) -> (SomeBVLit -> SomeBVLit -> ExceptT (Either SomeBVException e) m SomeBVLit) -> SomeBV bv -> SomeBV bv -> m (SomeBV bv)

-- | Lift a binary operation on sized bitvectors that returns two
--   bitvectors wrapped with <a>ExceptT</a> to <a>SomeBV</a>. The results
--   will also be wrapped with <a>SomeBV</a>.
--   
--   If the bitwidths do not match, throw an <a>BitwidthMismatch</a> error
--   to the monadic context.
binSomeBVSafeR2 :: (MonadError (Either SomeBVException e) m, TryMerge m, Mergeable e, forall (n :: Nat). (KnownNat n, 1 <= n) => Mergeable (bv n), forall (n :: Nat). (KnownNat n, 1 <= n) => Num (bv n), MaySomeBV bv) => (forall (n :: Nat). (KnownNat n, 1 <= n) => bv n -> bv n -> ExceptT e m (bv n, bv n)) -> (SomeBVLit -> SomeBVLit -> ExceptT (Either SomeBVException e) m (SomeBVLit, SomeBVLit)) -> SomeBV bv -> SomeBV bv -> m (SomeBV bv, SomeBV bv)

-- | A type-level proof that the given bit-widths are valid for a
--   floating-point number.
type ValidFP (eb :: Nat) (sb :: Nat) = ValidFloat eb sb

-- | IEEE 754 floating-point number with <tt>eb</tt> exponent bits and
--   <tt>sb</tt> significand bits.
--   
--   <pre>
--   &gt;&gt;&gt; 1.0 + 2.0 :: FP 11 53
--   3.0
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
data FP (eb :: Nat) (sb :: Nat)

-- | IEEE 754 half-precision floating-point number.
type FP16 = FP 5 11

-- | IEEE 754 single-precision floating-point number.
type FP32 = FP 8 24

-- | IEEE 754 double-precision floating-point number.
type FP64 = FP 11 53

-- | Some type-level witnesses that could be derived from <a>ValidFP</a>.
withValidFPProofs :: forall (eb :: Nat) (sb :: Nat) r. ValidFP eb sb => ((KnownNat (eb + sb), BVIsNonZero (eb + sb), 1 <= (eb + sb), 1 <= eb, 1 <= sb) => r) -> r

-- | Rounding mode for floating-point operations.
data FPRoundingMode

-- | Round to nearest, ties to even.
RNE :: FPRoundingMode

-- | Round to nearest, ties to away from zero.
RNA :: FPRoundingMode

-- | Round towards positive infinity.
RTP :: FPRoundingMode

-- | Round towards negative infinity.
RTN :: FPRoundingMode

-- | Round towards zero.
RTZ :: FPRoundingMode

-- | All IEEE 754 rounding modes.
allFPRoundingMode :: [FPRoundingMode]

-- | Algebraic real numbers. The representation can be abstract for
--   roots-of-polynomials or intervals.
data AlgReal

-- | Exact rational number.
[AlgExactRational] :: Rational -> AlgReal

-- | Inexact rational numbers. SMT-solver return it with ? at the end.
[AlgInexactRational] :: Rational -> AlgReal

-- | Algebraic real number as a root of a polynomial.
[AlgPolyRoot] :: Integer -> AlgRealPoly -> Maybe String -> AlgReal

-- | Interval with low and high bounds.
[AlgInterval] :: RealPoint -> RealPoint -> AlgReal

-- | A univariate polynomial with integer coefficients.
--   
--   For instance, <tt>5x^3+2x-5</tt> is represented as
--   <tt><a>AlgRealPoly</a> [(5, 3), (2, 1), (-5, 0)]</tt>.
newtype AlgRealPoly
AlgRealPoly :: [(Integer, Integer)] -> AlgRealPoly

-- | Boundary point for real intervals.
data RealPoint

-- | Open point.
OpenPoint :: Rational -> RealPoint

-- | Closed point.
ClosedPoint :: Rational -> RealPoint

-- | Exception for unsupported operations on algebraic real numbers.
--   
--   We only support operations on exact rationals.
data UnsupportedAlgRealOperation
UnsupportedAlgRealOperation :: String -> String -> UnsupportedAlgRealOperation
[op] :: UnsupportedAlgRealOperation -> String
[msg] :: UnsupportedAlgRealOperation -> String

-- | Functions as a table. Use the <a>#</a> operator to apply the function.
--   
--   <pre>
--   &gt;&gt;&gt; let f = TabularFun [(1, 2), (3, 4)] 0 :: Int =-&gt; Int
--   
--   &gt;&gt;&gt; f # 1
--   2
--   
--   &gt;&gt;&gt; f # 2
--   0
--   
--   &gt;&gt;&gt; f # 3
--   4
--   </pre>
data a =-> b
TabularFun :: [(a, b)] -> b -> (=->) a b
[funcTable] :: (=->) a b -> [(a, b)]
[defaultFuncValue] :: (=->) a b -> b
infixr 0 =->

-- | General symbolic function type. Use the <a>#</a> operator to apply the
--   function. Note that this function should be applied to symbolic values
--   only. It is by itself already a symbolic value, but can be considered
--   partially concrete as the function body is specified. Use
--   <a>-~&gt;</a> for uninterpreted general symbolic functions.
--   
--   The result would be partially evaluated.
--   
--   <pre>
--   &gt;&gt;&gt; let f = ("x" :: TypedConstantSymbol Integer) --&gt; ("x" + 1 + "y" :: SymInteger) :: Integer --&gt; Integer
--   
--   &gt;&gt;&gt; f # 1    -- 1 has the type SymInteger
--   (+ 2 y)
--   
--   &gt;&gt;&gt; f # "a"  -- "a" has the type SymInteger
--   (+ 1 (+ a y))
--   </pre>
data a --> b
infixr 0 -->

-- | Construction of general symbolic functions.
--   
--   <pre>
--   &gt;&gt;&gt; f = "a" --&gt; "a" + 1 :: Integer --&gt; Integer
--   
--   &gt;&gt;&gt; f
--   \(arg@0 :: Integer) -&gt; (+ 1 arg@0)
--   </pre>
--   
--   This general symbolic function needs to be applied to symbolic values:
--   
--   <pre>
--   &gt;&gt;&gt; f # ("a" :: SymInteger)
--   (+ 1 a)
--   
--   &gt;&gt;&gt; f # (2 :: SymInteger)
--   3
--   </pre>
(-->) :: (SupportedNonFuncPrim ca, SupportedPrim cb, LinkedRep cb sb) => TypedConstantSymbol ca -> sb -> ca --> cb
infixr 0 -->

-- | Symbolic Boolean type.
--   
--   <pre>
--   &gt;&gt;&gt; "a" :: SymBool
--   a
--   
--   &gt;&gt;&gt; "a" .&amp;&amp; "b" :: SymBool
--   (&amp;&amp; a b)
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymBool
SymBool :: Term Bool -> SymBool

-- | <a>SymBool</a> type with identity equality.
type SymBoolKey = AsKey SymBool

-- | Symbolic (unbounded, mathematical) integer type.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 1 :: SymInteger
--   (+ 1 a)
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymInteger
SymInteger :: Term Integer -> SymInteger

-- | <a>SymInteger</a> type with identity equality.
type SymIntegerKey = AsKey SymInteger

-- | Symbolic unsigned bit vector type. Indexed with the bit width.
--   Signedness affects the semantics of the operations, including
--   comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 5 :: SymWordN 5
--   (+ 0b00101 a)
--   
--   &gt;&gt;&gt; sizedBVConcat (con 0b101 :: SymWordN 3) (con 0b110 :: SymWordN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (con 0b101 :: SymWordN 3)
--   0b000101
--   
--   &gt;&gt;&gt; (8 :: SymWordN 4) .&lt; (7 :: SymWordN 4)
--   false
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymWordN (n :: Nat)
SymWordN :: Term (WordN n) -> SymWordN (n :: Nat)

-- | <a>SymWordN</a> type with identity equality.
type SymWordNKey (n :: Nat) = AsKey SymWordN n

-- | Symbolic 8-bit unsigned bit-vector.
type SymWordN8 = SymWordN 8

-- | <a>SymWordN</a> 8@ type with identity equality.
type SymWordN8Key = SymWordNKey 8

-- | Symbolic 16-bit unsigned bit-vector.
type SymWordN16 = SymWordN 16

-- | <a>SymWordN</a> 16@ type with identity equality.
type SymWordN16Key = SymWordNKey 16

-- | Symbolic 32-bit unsigned bit-vector.
type SymWordN32 = SymWordN 32

-- | <a>SymWordN</a> 32@ type with identity equality.
type SymWordN32Key = SymWordNKey 32

-- | Symbolic 64-bit unsigned bit-vector.
type SymWordN64 = SymWordN 64

-- | <a>SymWordN</a> 64@ type with identity equality.
type SymWordN64Key = SymWordNKey 64

-- | Symbolic signed bit vector type. Indexed with the bit width.
--   Signedness affects the semantics of the operations, including
--   comparison/extension, etc.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 5 :: SymIntN 5
--   (+ 0b00101 a)
--   
--   &gt;&gt;&gt; sizedBVConcat (con 0b101 :: SymIntN 3) (con 0b110 :: SymIntN 3)
--   0b101110
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (con 0b101 :: SymIntN 3)
--   0b111101
--   
--   &gt;&gt;&gt; (8 :: SymIntN 4) .&lt; (7 :: SymIntN 4)
--   true
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymIntN (n :: Nat)
SymIntN :: Term (IntN n) -> SymIntN (n :: Nat)

-- | <a>SymIntN</a> type with identity equality.
type SymIntNKey (n :: Nat) = AsKey SymIntN n

-- | Symbolic 8-bit signed bit-vector.
type SymIntN8 = SymIntN 8

-- | <tt><a>SymIntN</a> 8</tt> type with identity equality.
type SymIntN8Key = SymIntNKey 8

-- | Symbolic 16-bit signed bit-vector.
type SymIntN16 = SymIntN 16

-- | <tt><a>SymIntN</a> 16</tt> type with identity equality.
type SymIntN16Key = SymIntNKey 16

-- | Symbolic 32-bit signed bit-vector.
type SymIntN32 = SymIntN 32

-- | <tt><a>SymIntN</a> 32</tt> type with identity equality.
type SymIntN32Key = SymIntNKey 32

-- | Symbolic 64-bit signed bit-vector.
type SymIntN64 = SymIntN 64

-- | <tt><a>SymIntN</a> 64</tt> type with identity equality.
type SymIntN64Key = SymIntNKey 64

-- | Type synonym for <a>SomeBV</a> for symbolic signed bitvectors.
type SomeSymIntN = SomeBV SymIntN

-- | <a>SomeSymIntN</a> with identity equality.
type SomeSymIntNKey = SomeBVKey SymIntN

-- | Type synonym for <a>SomeBV</a> for symbolic unsigned bitvectors.
type SomeSymWordN = SomeBV SymWordN

-- | <a>SomeSymWordN</a> with identity equality.
type SomeSymWordNKey = SomeBVKey SymWordN

-- | Pattern synonym for <a>SomeBV</a> for symbolic signed bitvectors.
pattern SomeSymIntN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymIntN n -> SomeSymIntN

-- | Pattern synonym for <a>SomeBV</a> for symbolic unsigned bitvectors.
pattern SomeSymWordN :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymWordN n -> SomeSymWordN
pattern SomeSymIntNKey :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymIntN n -> SomeSymIntNKey
pattern SomeSymWordNKey :: forall (n :: Nat). () => (KnownNat n, 1 <= n) => SymWordN n -> SomeSymWordNKey

-- | Symbolic IEEE 754 floating-point number with <tt>eb</tt> exponent bits
--   and <tt>sb</tt> significand bits.
--   
--   <pre>
--   &gt;&gt;&gt; "a" + 2.0 :: SymFP 11 53
--   (+ a 2.0)
--   
--   &gt;&gt;&gt; fpAdd rne "a" 2.0 :: SymFP 11 53
--   (fp.add rne a 2.0)
--   </pre>
--   
--   More operations are available. Please refer to
--   <a>Grisette.Core#g:symops</a> for more information.
newtype SymFP (eb :: Nat) (sb :: Nat)
SymFP :: Term (FP eb sb) -> SymFP (eb :: Nat) (sb :: Nat)

-- | <a>SymFP</a> type with identity equality.
type SymFPKey (eb :: Nat) (sb :: Nat) = AsKey SymFP eb sb

-- | Symbolic floating-point rounding mode.
newtype SymFPRoundingMode
SymFPRoundingMode :: Term FPRoundingMode -> SymFPRoundingMode

-- | <a>SymFPRoundingMode</a> type with identity equality.
type SymFPRoundingModeKey = AsKey SymFPRoundingMode

-- | Symbolic IEEE 754 half-precision floating-point number.
type SymFP16 = SymFP 5 11

-- | <tt><a>SymFP</a> 16</tt> type with identity equality.
type SymFP16Key = SymFPKey 5 11

-- | Symbolic IEEE 754 single-precision floating-point number.
type SymFP32 = SymFP 8 24

-- | <tt><a>SymFP</a> 32</tt> type with identity equality.
type SymFP32Key = SymFPKey 8 24

-- | Symbolic IEEE 754 double-precision floating-point number.
type SymFP64 = SymFP 11 53

-- | <tt><a>SymFP</a> 64</tt> type with identity equality.
type SymFP64Key = SymFPKey 11 53

-- | Symbolic representation of algebraic real numbers.
newtype SymAlgReal
SymAlgReal :: Term AlgReal -> SymAlgReal

-- | <a>SymAlgReal</a> type with identity equality.
type SymAlgRealKey = AsKey SymAlgReal

-- | Symbolic tabular function type.
--   
--   <pre>
--   &gt;&gt;&gt; f' = "f" :: SymInteger =~&gt; SymInteger
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   (apply f 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f' = con (TabularFun [(1, 2), (2, 3)] 4) :: SymInteger =~&gt; SymInteger
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   2
--   
--   &gt;&gt;&gt; f 2
--   3
--   
--   &gt;&gt;&gt; f 3
--   4
--   
--   &gt;&gt;&gt; f "b"
--   (ite (= b 1) 2 (ite (= b 2) 3 4))
--   </pre>
data sa =~> sb
[SymTabularFun] :: forall ca sa cb sb. (LinkedRep ca sa, LinkedRep cb sb, SupportedPrim (ca =-> cb), SupportedNonFuncPrim ca) => Term (ca =-> cb) -> sa =~> sb
infixr 0 =~>

-- | Symbolic general function type.
--   
--   <pre>
--   &gt;&gt;&gt; f' = "f" :: SymInteger -~&gt; SymInteger
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   (apply f 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f' = con ("a" --&gt; "a" + 1) :: SymInteger -~&gt; SymInteger
--   
--   &gt;&gt;&gt; f'
--   \(arg@0 :: Integer) -&gt; (+ 1 arg@0)
--   
--   &gt;&gt;&gt; f = (f' #)
--   
--   &gt;&gt;&gt; f 1
--   2
--   
--   &gt;&gt;&gt; f 2
--   3
--   
--   &gt;&gt;&gt; f 3
--   4
--   
--   &gt;&gt;&gt; f "b"
--   (+ 1 b)
--   </pre>
data sa -~> sb
[SymGeneralFun] :: forall ca sa cb sb. (LinkedRep ca sa, LinkedRep cb sb, SupportedPrim (ca --> cb), SupportedNonFuncPrim ca) => Term (ca --> cb) -> sa -~> sb
infixr 0 -~>

-- | A type that is used as a constraint for all the primitive types
--   (including concrete primitives) in Grisette.
type Prim a = (Show a, Binary a, Serial a, Serialize a, NFData a, Eq a, EvalSym a, ExtractSym a, Mergeable a, PPrint a, SubstSym a, SymEq a, SymOrd a, AllSyms a, KeyEq a, KeyHashable a, Lift a, Typeable a)

-- | A type that is used as a constraint for all the symbolic primitive
--   types in Grisette.
type SymPrim a = (Prim a, ITEOp a, GenSymSimple a a)

-- | A type that is used as a constraint for all the basic symbolic
--   primitive types in Grisette.
--   
--   <a>SomeSymWordN</a> is not considered as a basic symbolic primitive
--   type.
type BasicSymPrim a = (SymPrim a, SimpleMergeable a, GenSymSimple () a, Solvable ConType a a, ConRep a, LinkedRep ConType a a, ToCon a ConType a, ToSym ConType a a, Apply a, a ~ FunType a, SupportedNonFuncPrim ConType a)

-- | Forall quantifier over a set of constant symbols. Quantifier over
--   functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let xsym = "x" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let ysym = "y" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let x = "x" :: SymInteger
--   
--   &gt;&gt;&gt; let y = "y" :: SymInteger
--   
--   &gt;&gt;&gt; forallSet (buildSymbolSet [xsym, ysym]) (x .== y)
--   (forall x :: Integer (forall y :: Integer (= x y)))
--   </pre>
--   
--   Only available with SBV 10.1.0 or later.
forallSet :: ConstantSymbolSet -> SymBool -> SymBool

-- | Forall quantifier over all symbolic constants in a value. Quantifier
--   over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let a = ["x", "y"] :: [SymInteger]
--   
--   &gt;&gt;&gt; forallSym a $ sum a .== 0
--   (forall x :: Integer (forall y :: Integer (= (+ x y) 0)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
forallSym :: (HasCallStack, ExtractSym a) => a -> SymBool -> SymBool

-- | Forall quantifier over symbolic constants in a freshly generated
--   value. Quantifier over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   x :: Fresh SymBool
--   x = forallFresh () $ \(a :: SymBool) -&gt;
--         existsFresh () $ \(b :: SymBool) -&gt;
--           mrgReturn $ a .== b
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runFresh x "x"
--   (forall x@0 :: Bool (exists x@1 :: Bool (= x@0 x@1)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
forallFresh :: (HasCallStack, ExtractSym v, MonadFresh m, GenSym spec v, TryMerge m) => spec -> (v -> FreshT Union SymBool) -> m SymBool

-- | Exists quantifier over a set of constant symbols. Quantifier over
--   functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let xsym = "x" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let ysym = "y" :: TypedConstantSymbol Integer
--   
--   &gt;&gt;&gt; let x = "x" :: SymInteger
--   
--   &gt;&gt;&gt; let y = "y" :: SymInteger
--   
--   &gt;&gt;&gt; existsSet (buildSymbolSet [xsym, ysym]) (x .== y)
--   (exists x :: Integer (exists y :: Integer (= x y)))
--   </pre>
--   
--   Only available with SBV 10.1.0 or later.
existsSet :: ConstantSymbolSet -> SymBool -> SymBool

-- | Exists quantifier over all symbolic constants in a value. Quantifier
--   over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; let a = ["x", "y"] :: [SymInteger]
--   
--   &gt;&gt;&gt; existsSym a $ sum a .== 0
--   (exists x :: Integer (exists y :: Integer (= (+ x y) 0)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
existsSym :: (HasCallStack, ExtractSym a) => a -> SymBool -> SymBool

-- | Exists quantifier over symbolic constants in a freshly generated
--   value. Quantifier over functions is not supported.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   x :: Fresh SymBool
--   x = forallFresh () $ \(a :: SymBool) -&gt;
--         existsFresh () $ \(b :: SymBool) -&gt;
--           mrgReturn $ a .== b
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runFresh x "x"
--   (forall x@0 :: Bool (exists x@1 :: Bool (= x@0 x@1)))
--   </pre>
--   
--   Only available with sbv 10.1.0 or later.
existsFresh :: (HasCallStack, ExtractSym v, MonadFresh m, GenSym spec v, TryMerge m) => spec -> (v -> FreshT Union SymBool) -> m SymBool

-- | Indicates that a type is supported, can be represented as a symbolic
--   term, and can be lowered to an SBV term.
class (Lift t, NFData t, Typeable t, SupportedPrimConstraint t, SBVRep t) => SupportedPrim t

-- | Type family to resolve the symbolic type associated with a concrete
--   type.
class SupportedPrim con => SymRep con where {
    type SymType con;
}

-- | Type family to resolve the concrete type associated with a symbolic
--   type.
class ConRep sym where {
    type ConType sym;
}

-- | One-to-one mapping between symbolic types and concrete types.
class (ConRep sym, SymRep con, sym ~ SymType con, con ~ ConType sym) => LinkedRep con sym | con -> sym, sym -> con
underlyingTerm :: LinkedRep con sym => sym -> Term con
wrapTerm :: LinkedRep con sym => Term con -> sym

-- | Some symbolic value with <a>LinkedRep</a> constraint.
data SomeSym
[SomeSym] :: forall con sym. LinkedRep con sym => sym -> SomeSym

-- | Extract all symbolic primitive values that are represented as SMT
--   terms.
--   
--   <pre>
--   &gt;&gt;&gt; allSyms (["a" + 1 :: SymInteger, -"b"], "c" :: SymBool)
--   [(+ 1 a),(- b),c]
--   </pre>
--   
--   This is usually used for getting a statistical summary of the size of
--   a symbolic value with <a>allSymsSize</a>.
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extenstions.
--   
--   <pre>
--   data X = ... deriving Generic deriving AllSyms via (Default X)
--   </pre>
class AllSyms a

-- | Convert a value to a list of symbolic primitive values. It should
--   prepend to an existing list of symbolic primitive values.
allSymsS :: AllSyms a => a -> [SomeSym] -> [SomeSym]

-- | Specialized <a>allSymsS</a> that prepends to an empty list.
allSyms :: AllSyms a => a -> [SomeSym]

-- | Lifting of the <a>AllSyms</a> class to unary type constructors.
class forall a. AllSyms a => AllSyms f a => AllSyms1 (f :: Type -> Type)

-- | Lift the <a>allSymsS</a> function to unary type constructors.
liftAllSymsS :: AllSyms1 f => (a -> [SomeSym] -> [SomeSym]) -> f a -> [SomeSym] -> [SomeSym]

-- | Lift the standard <a>allSymsS</a> function to unary type constructors.
allSymsS1 :: (AllSyms1 f, AllSyms a) => f a -> [SomeSym] -> [SomeSym]

-- | Lifting of the <a>AllSyms</a> class to binary type constructors.
class forall a. AllSyms a => AllSyms1 f a => AllSyms2 (f :: Type -> Type -> Type)

-- | Lift the <a>allSymsS</a> function to binary type constructors.
liftAllSymsS2 :: AllSyms2 f => (a -> [SomeSym] -> [SomeSym]) -> (b -> [SomeSym] -> [SomeSym]) -> f a b -> [SomeSym] -> [SomeSym]

-- | Lift the standard <a>allSymsS</a> function to binary type
--   constructors.
allSymsS2 :: (AllSyms2 f, AllSyms a, AllSyms b) => f a b -> [SomeSym] -> [SomeSym]

-- | Get the total size of symbolic terms in a value. Duplicate sub-terms
--   are counted for only once.
--   
--   <pre>
--   &gt;&gt;&gt; allSymsSize ("a" :: SymInteger, "a" + "b" :: SymInteger, ("a" + "b") * "c" :: SymInteger)
--   5
--   </pre>
--   
--   The 5 terms are <tt>a</tt>, <tt>b</tt>, <tt>(+ a b)</tt>, <tt>c</tt>,
--   and <tt>(* (+ a b) c)</tt>.
allSymsSize :: AllSyms a => a -> Int

-- | Get the size of a symbolic term. Duplicate sub-terms are counted for
--   only once.
--   
--   <pre>
--   &gt;&gt;&gt; symSize (1 :: SymInteger)
--   1
--   
--   &gt;&gt;&gt; symSize ("a" :: SymInteger)
--   1
--   
--   &gt;&gt;&gt; symSize ("a" + 1 :: SymInteger)
--   3
--   
--   &gt;&gt;&gt; symSize (("a" + 1) * ("a" + 1) :: SymInteger)
--   4
--   </pre>
symSize :: LinkedRep con sym => sym -> Int

-- | Get the sum of the sizes of a list of symbolic terms. Duplicate
--   sub-terms are counted for only once.
--   
--   <pre>
--   &gt;&gt;&gt; symsSize [1, "a" :: SymInteger, "a" + 1 :: SymInteger]
--   3
--   </pre>
symsSize :: LinkedRep con sym => [sym] -> Int

-- | The arguments to the generic <a>AllSyms</a> function.
data family AllSymsArgs arity a

-- | The class of types that can generically extract all symbolic
--   primitives.
class GAllSyms arity (f :: Type -> Type)
gallSymsS :: GAllSyms arity f => AllSymsArgs arity a -> f a -> [SomeSym] -> [SomeSym]

-- | Generic <a>allSymsS</a> function.
genericAllSymsS :: (Generic a, GAllSyms Arity0 (Rep a)) => a -> [SomeSym] -> [SomeSym]

-- | Generic <a>liftAllSymsS</a> function.
genericLiftAllSymsS :: (Generic1 f, GAllSyms Arity1 (Rep1 f)) => (a -> [SomeSym] -> [SomeSym]) -> f a -> [SomeSym] -> [SomeSym]

-- | The kind of a symbol.
--   
--   All symbols are <a>AnyKind</a>, and all symbols other than
--   general/tabular functions are <a>ConstantKind</a>.
data SymbolKind
ConstantKind :: SymbolKind
AnyKind :: SymbolKind

-- | Decision procedure for symbol kinds.
class IsSymbolKind (knd :: SymbolKind) where {
    type SymbolKindConstraint (knd :: SymbolKind) :: Type -> Constraint;
}
decideSymbolKind :: IsSymbolKind knd => Either (knd :~~: 'ConstantKind) (knd :~~: 'AnyKind)
withSymbolKindConstraint :: IsSymbolKind knd => TypedSymbol knd t -> (SymbolKindConstraint knd t => a) -> a

-- | A typed symbol is a symbol that is associated with a type. Note that
--   the same symbol bodies with different types are considered different
--   symbols and can coexist in a term.
--   
--   Simple symbols can be created with the <tt>OverloadedStrings</tt>
--   extension:
--   
--   <pre>
--   &gt;&gt;&gt; "a" :: TypedSymbol 'AnyKind Bool
--   a :: Bool
--   </pre>
data TypedSymbol (knd :: SymbolKind) t
[TypedSymbol] :: forall t (knd :: SymbolKind). (SupportedPrim t, SymbolKindConstraint knd t, IsSymbolKind knd) => Symbol -> TypedSymbol knd t

-- | Create a typed symbol with any kinds.
typedAnySymbol :: SupportedPrim t => Symbol -> TypedSymbol 'AnyKind t

-- | Any symbol
type TypedAnySymbol = TypedSymbol 'AnyKind

-- | Create a typed symbol with constant kinds.
typedConstantSymbol :: SupportedNonFuncPrim t => Symbol -> TypedSymbol 'ConstantKind t

-- | Constant symbol
type TypedConstantSymbol = TypedSymbol 'ConstantKind

-- | A non-indexed symbol. Type information are checked at runtime.
data SomeTypedSymbol (knd :: SymbolKind)
[SomeTypedSymbol] :: forall (knd :: SymbolKind) t. TypedSymbol knd t -> SomeTypedSymbol knd

-- | Non-indexed any symbol
type SomeTypedAnySymbol = SomeTypedSymbol 'AnyKind

-- | Non-indexed constant symbol
type SomeTypedConstantSymbol = SomeTypedSymbol 'ConstantKind

-- | Set of symbols.
--   
--   Check <a>SymbolSetOps</a> for operations, and <a>SymbolSetRep</a> for
--   manual constructions.
data SymbolSet (knd :: SymbolKind)

-- | Set of any symbols.
type AnySymbolSet = SymbolSet 'AnyKind

-- | Set of constant symbols. Excluding unintepreted functions.
type ConstantSymbolSet = SymbolSet 'ConstantKind

-- | Model returned by the solver.
--   
--   Check <a>ModelOps</a> for operations, and <a>ModelRep</a> for manual
--   constructions.
data Model

-- | A type used for building a model by hand.
--   
--   <pre>
--   &gt;&gt;&gt; buildModel ("x" ::= (1 :: Integer), "y" ::= True) :: Model
--   Model {x -&gt; 1 :: Integer, y -&gt; true :: Bool}
--   </pre>
data ModelValuePair t
(::=) :: TypedAnySymbol t -> t -> ModelValuePair t

-- | A pair of a symbolic constant and its value. This is used to build a
--   model from a list of symbolic constants and their values.
--   
--   <pre>
--   &gt;&gt;&gt; buildModel ("a" := (1 :: Integer), "b" := True) :: Model
--   Model {a -&gt; 1 :: Integer, b -&gt; true :: Bool}
--   </pre>
data ModelSymPair ct st
[:=] :: forall ct st. LinkedRep ct st => st -> ct -> ModelSymPair ct st

-- | Internal representation for Grisette symbolic terms.
data Term t

-- | Existential wrapper for symbolic Grisette terms.
data SomeTerm
[SomeTerm] :: forall a. SupportedPrim a => Term a -> SomeTerm

-- | Compute the size of a term.
termSize :: Term a -> Int

-- | Compute the size of a list of terms. Do not count the same term twice.
someTermSize :: SomeTerm -> Int

-- | Compute the size of a list of terms. Do not count the same term twice.
termsSize :: [Term a] -> Int

-- | Compute the size of a list of terms. Do not count the same term twice.
someTermsSize :: [SomeTerm] -> Int

-- | Pattern synonym to introduce the SupportedPrim constraint.
pattern SupportedTerm :: () => SupportedPrim t => Term t

-- | Pattern synonym to introduce constraints from a <a>TypedSymbol</a>.
pattern SupportedTypedSymbol :: () => (SupportedPrim t, SymbolKindConstraint k t, IsSymbolKind k) => TypedSymbol k t

-- | Pattern synonym to introduce constraints from a <a>TypedSymbol</a>.
--   Also checks that the symbol kind is <a>ConstantKind</a>.
pattern SupportedConstantTypedSymbol :: () => (SupportedPrim t, SymbolKindConstraint k t, IsSymbolKind k, k ~ 'ConstantKind) => TypedSymbol k t

-- | Pattern synonym for <a>ConTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ConTerm :: () => SupportedPrim t => t -> Term t

-- | Pattern synonym for <a>SymTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern SymTerm :: () => SupportedPrim t => TypedSymbol 'AnyKind t -> Term t

-- | Pattern synonym for <a>ForallTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern ForallTerm :: forall r t. () => (r ~ Bool, SupportedNonFuncPrim t) => TypedSymbol 'ConstantKind t -> Term Bool -> Term r

-- | Pattern synonym for <a>ExistsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern ExistsTerm :: forall r t. () => (r ~ Bool, SupportedNonFuncPrim t) => TypedSymbol 'ConstantKind t -> Term Bool -> Term r

-- | Pattern synonym for <a>NotTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern NotTerm :: () => r ~ Bool => Term Bool -> Term r

-- | Pattern synonym for <a>OrTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern OrTerm :: () => r ~ Bool => Term Bool -> Term Bool -> Term r

-- | Pattern synonym for <a>AndTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern AndTerm :: () => r ~ Bool => Term Bool -> Term Bool -> Term r

-- | Pattern synonym for <a>EqTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern EqTerm :: forall r t. () => (r ~ Bool, SupportedPrim t) => Term t -> Term t -> Term r

-- | Pattern synonym for <a>DistinctTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern DistinctTerm :: forall r t. () => (r ~ Bool, SupportedPrim t) => NonEmpty (Term t) -> Term r

-- | Pattern synonym for <a>ITETerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ITETerm :: () => SupportedPrim t => Term Bool -> Term t -> Term t -> Term t

-- | Pattern synonym for <a>AddNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern AddNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>NegNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern NegNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t

-- | Pattern synonym for <a>MulNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern MulNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>AbsNumTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern AbsNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t

-- | Pattern synonym for <a>SignumNumTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern SignumNumTerm :: () => (SupportedPrim t, PEvalNumTerm t) => Term t -> Term t

-- | Pattern synonym for <a>LtOrdTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern LtOrdTerm :: forall r t. () => (r ~ Bool, SupportedPrim t, PEvalOrdTerm t) => Term t -> Term t -> Term r

-- | Pattern synonym for <a>LeOrdTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern LeOrdTerm :: forall r t. () => (r ~ Bool, SupportedPrim t, PEvalOrdTerm t) => Term t -> Term t -> Term r

-- | Pattern synonym for <a>AndBitsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern AndBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>OrBitsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern OrBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>XorBitsTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern XorBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>ComplementBitsTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ComplementBitsTerm :: () => (SupportedPrim t, PEvalBitwiseTerm t) => Term t -> Term t

-- | Pattern synonym for <a>ShiftLeftTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ShiftLeftTerm :: () => (SupportedPrim t, PEvalShiftTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RotateLeftTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern RotateLeftTerm :: () => (SupportedPrim t, PEvalRotateTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>ShiftRightTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ShiftRightTerm :: () => (SupportedPrim t, PEvalShiftTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RotateRightTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern RotateRightTerm :: () => (SupportedPrim t, PEvalRotateTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>BitCastTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BitCastTerm :: forall b a. () => (SupportedPrim a, SupportedPrim b, PEvalBitCastTerm a b) => Term a -> Term b

-- | Pattern synonym for <a>BitCastOrTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern BitCastOrTerm :: () => (SupportedPrim a, SupportedPrim b, PEvalBitCastOrTerm a b) => Term b -> Term a -> Term b

-- | Pattern synonym for <a>BVConcatTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BVConcatTerm :: forall ret bv (l :: Nat) (r :: Nat). () => (PEvalBVTerm bv, KnownNat l, KnownNat r, KnownNat (l + r), 1 <= l, 1 <= r, 1 <= (l + r), SupportedPrim (bv l), SupportedPrim (bv r), SupportedPrim (bv (l + r)), ret ~ bv (l + r)) => Term (bv l) -> Term (bv r) -> Term ret

-- | Pattern synonym for <a>BVSelectTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BVSelectTerm :: forall ret bv (w :: Nat) (n :: Nat) (ix :: Nat). () => (PEvalBVTerm bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n, SupportedPrim (bv n), SupportedPrim (bv w), ret ~ bv w) => Proxy ix -> Proxy w -> Term (bv n) -> Term ret

-- | Pattern synonym for <a>BVExtendTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern BVExtendTerm :: forall ret bv (l :: Nat) (r :: Nat). () => (PEvalBVTerm bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r, l <= r, SupportedPrim (bv l), SupportedPrim (bv r), ret ~ bv r) => Bool -> Proxy r -> Term (bv l) -> Term ret

-- | Pattern synonym for <a>ApplyTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ApplyTerm :: forall b f a. () => (PEvalApplyTerm f a b, SupportedPrim f, SupportedPrim a, SupportedPrim b) => Term f -> Term a -> Term b

-- | Pattern synonym for <a>DivIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern DivIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>ModIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern ModIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>QuotIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern QuotIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RemIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern RemIntegralTerm :: () => (SupportedPrim t, PEvalDivModIntegralTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>FPTraitTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FPTraitTerm :: forall r (eb :: Nat) (sb :: Nat) fp. () => (r ~ Bool, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPTrait -> Term (fp eb sb) -> Term r

-- | Pattern synonym for <a>FdivTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern FdivTerm :: () => (SupportedPrim t, PEvalFractionalTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>RecipTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern RecipTerm :: () => (SupportedPrim t, PEvalFractionalTerm t) => Term t -> Term t

-- | Pattern synonym for <a>FloatingUnaryTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FloatingUnaryTerm :: () => (SupportedPrim t, PEvalFloatingTerm t) => FloatingUnaryOp -> Term t -> Term t

-- | Pattern synonym for <a>PowerTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern PowerTerm :: () => (SupportedPrim t, PEvalFloatingTerm t) => Term t -> Term t -> Term t

-- | Pattern synonym for <a>FPUnaryTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FPUnaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPUnaryOp -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPBinaryTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FPBinaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPBinaryOp -> Term (fp eb sb) -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPRoundingUnaryTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FPRoundingUnaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPRoundingUnaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPRoundingBinaryTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FPRoundingBinaryTerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => FPRoundingBinaryOp -> Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FPFMATerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern FPFMATerm :: forall ret fp (eb :: Nat) (sb :: Nat). () => (ret ~ fp eb sb, ValidFP eb sb, SupportedPrim (fp eb sb), PEvalFPTerm fp) => Term FPRoundingMode -> Term (fp eb sb) -> Term (fp eb sb) -> Term (fp eb sb) -> Term ret

-- | Pattern synonym for <a>FromIntegralTerm'</a>. Note that using this
--   pattern to construct a <a>Term</a> will do term simplification.
pattern FromIntegralTerm :: forall b a. () => (PEvalFromIntegralTerm a b, SupportedPrim a, SupportedPrim b) => Term a -> Term b

-- | Pattern synonym for <a>FromFPOrTerm'</a>. Note that using this pattern
--   to construct a <a>Term</a> will do term simplification.
pattern FromFPOrTerm :: forall a (eb :: Nat) (sb :: Nat). () => (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim a) => Term a -> Term FPRoundingMode -> Term (FP eb sb) -> Term a

-- | Pattern synonym for <a>ToFPTerm'</a>. Note that using this pattern to
--   construct a <a>Term</a> will do term simplification.
pattern ToFPTerm :: forall ret (eb :: Nat) (sb :: Nat) a. () => (PEvalIEEEFPConvertibleTerm a, ValidFP eb sb, SupportedPrim (FP eb sb), SupportedPrim a, ret ~ FP eb sb) => Term FPRoundingMode -> Term a -> Proxy eb -> Proxy sb -> Term ret

-- | Extract all the subterms of a term.
pattern SubTerms :: [SomeTerm] -> Term a


module Grisette.Internal.Unified.UnifiedData
class (UnifiedSimpleMergeable1 mode GetData mode, UnifiedBranching mode GetData mode, UnionView GetData mode, UnionViewMode mode GetData mode, Monad GetData mode, TryMerge GetData mode) => UnifiedDataBase (mode :: EvalModeTag)

-- | Get a unified data type. Resolves to <a>Identity</a> in <a>C</a> mode,
--   and <a>Union</a> in <a>S</a> mode.
type family GetData (mode :: EvalModeTag) = (r :: Type -> Type) | r -> mode

-- | A type family that specifies the base monad for the evaluation mode.
--   
--   Resolves to <a>Identity</a> for <a>C</a> mode, and <a>Union</a> for
--   <a>S</a> mode.
type BaseMonad (mode :: EvalModeTag) = GetData mode

-- | Wraps a value into the unified data type.
wrapData :: UnifiedDataImpl mode v u => v -> u

-- | Extracts a value from the unified data type.
extractData :: (UnifiedDataImpl mode v u, Mergeable v, Monad m, UnifiedBranching mode m) => u -> m v

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>IsMode</a>.
class UnifiedDataImpl mode v GetData mode v => UnifiedData (mode :: EvalModeTag) v

-- | Evaluation mode with unified data types.
class (forall v. () => UnifiedData bool v, forall v. Mergeable v => UnifiedDataSimpleMergeable v) => AllUnifiedData (bool :: EvalModeTag)

-- | Unified <a>symCompare</a>.
symCompare :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetData mode Ordering

-- | Unified <a>liftSymCompare</a>.
liftSymCompare :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymOrd1 mode f) => (a -> b -> GetData mode Ordering) -> f a -> f b -> GetData mode Ordering

-- | Unified <a>symCompare1</a>.
symCompare1 :: forall (mode :: EvalModeTag) f a. (DecideEvalMode mode, UnifiedSymOrd mode a, UnifiedSymOrd1 mode f) => f a -> f a -> GetData mode Ordering

-- | Unified <a>liftSymCompare2</a>.
liftSymCompare2 :: forall (mode :: EvalModeTag) f a b c d. (DecideEvalMode mode, UnifiedSymOrd2 mode f) => (a -> b -> GetData mode Ordering) -> (c -> d -> GetData mode Ordering) -> f a c -> f b d -> GetData mode Ordering

-- | Unified <a>symCompare2</a>.
symCompare2 :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymOrd mode a, UnifiedSymOrd mode b, UnifiedSymOrd2 mode f) => f a b -> f a b -> GetData mode Ordering
instance (forall v. Grisette.Internal.Unified.UnifiedData.UnifiedData bool v, forall v. Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable v => Grisette.Internal.Unified.UnifiedData.UnifiedDataSimpleMergeable v) => Grisette.Internal.Unified.UnifiedData.AllUnifiedData bool
instance Grisette.Internal.Unified.UnifiedData.UnifiedDataBase 'Grisette.Internal.Unified.EvalModeTag.C
instance Grisette.Internal.Unified.UnifiedData.UnifiedDataBase 'Grisette.Internal.Unified.EvalModeTag.S
instance Grisette.Internal.Unified.UnifiedData.UnifiedDataImpl 'Grisette.Internal.Unified.EvalModeTag.C v (GHC.Internal.Data.Functor.Identity.Identity v)
instance Grisette.Internal.Unified.UnifiedData.UnifiedDataImpl 'Grisette.Internal.Unified.EvalModeTag.S v (Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union v)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable v => Grisette.Internal.Unified.UnifiedData.UnifiedDataSimpleMergeable v
instance Grisette.Internal.Unified.UnifiedData.UnifiedDataImpl bool v (Grisette.Internal.Unified.UnifiedData.GetData bool v) => Grisette.Internal.Unified.UnifiedData.UnifiedData bool v


module Grisette.Internal.TH.Ctor.UnifiedConstructor

-- | Generate smart constructors to create unified values with provided
--   name transformer.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the name transformed, e.g., given the name transformer <tt>(name -&gt;
--   "mk" ++ name)</tt>, it will generate <tt>mkT1</tt>, <tt>mkT2</tt>,
--   <tt>mkT2</tt>, etc.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makeUnifiedCtorWith :: [Name] -> (String -> String) -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the given prefix, e.g., <tt>mkT1</tt>, <tt>mkT2</tt>, etc.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makePrefixedUnifiedCtor :: [Name] -> String -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the given names.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makeNamedUnifiedCtor :: [Name] -> [String] -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the names decapitalized, e.g., <tt>t1</tt>, <tt>t2</tt>, etc.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makeUnifiedCtor :: [Name] -> Name -> Q [Dec]


module Grisette.TH

-- | Make an ADT compatible with Grisette.
--   
--   This will generate instances for the ADT with the given classes, and
--   smart constructors for each constructor.
--   
--   The derivation is done with the given configuration.
makeGrisetteADTWithClasses :: DeriveConfig -> Name -> [Name] -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   See <tt>derive</tt>, <a>basicClasses0</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   See <tt>derive</tt>, <a>basicClasses01</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT1 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   See <tt>derive</tt>, <a>basicClasses012</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT2 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>basicClasses0</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADTWith :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>basicClasses01</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteBasicADT1With :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate most useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This does not include <a>Ord</a> instances.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>basicClasses012</a>, and
--   <a>makeSmartCtor</a> for more details.
makeGrisetteBasicADT2With :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   See <tt>derive</tt>, <a>allClasses0</a>, and <a>makeSmartCtor</a> for
--   more details.
makeGrisetteADT :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   See <tt>derive</tt>, <a>allClasses01</a>, and <a>makeSmartCtor</a> for
--   more details.
makeGrisetteADT1 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   See <tt>derive</tt>, <a>allClasses012</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADT2 :: Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>allClasses0</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADTWith :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>allClasses01</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADT1With :: DeriveConfig -> Name -> Q [Dec]

-- | Make an ADT compatible with Grisette.
--   
--   This will generate almost all useful instances for the ADT, and smart
--   constructors for each constructor.
--   
--   This cannot be used for ADTs with existential type variables.
--   
--   The derivation is done with the given configuration.
--   
--   See <a>deriveWith</a>, <a>allClasses012</a>, and <a>makeSmartCtor</a>
--   for more details.
makeGrisetteADT2With :: DeriveConfig -> Name -> Q [Dec]

-- | Configuration for constraints for evaluation modes tag.
--   
--   <ul>
--   <li><a>EvalModeConstraints</a> specifies a list of constraints for the
--   tag, for example, we may use <a>EvalModeBase</a> and <a>EvalModeBV</a>
--   to specify that the evaluation mode must support both base (boolean
--   and data types) and bit vectors. This should be used when the data
--   type uses bit vectors.</li>
--   <li><a>EvalModeSpecified</a> specifies a that an evaluation mode tag
--   should be specialized to a specific tag for all the instances.</li>
--   </ul>
data EvalModeConfig
EvalModeConstraints :: [Name] -> EvalModeConfig
EvalModeSpecified :: EvalModeTag -> EvalModeConfig

-- | Configuration for deriving instances for a data type.
data DeriveConfig
DeriveConfig :: [(Int, EvalModeConfig)] -> [Int] -> [(Int, Int)] -> [Int] -> Bool -> Bool -> Bool -> Bool -> DeriveConfig
[evalModeConfig] :: DeriveConfig -> [(Int, EvalModeConfig)]
[bitSizePositions] :: DeriveConfig -> [Int]
[fpBitSizePositions] :: DeriveConfig -> [(Int, Int)]
[unconstrainedPositions] :: DeriveConfig -> [Int]
[needExtraMergeableUnderEvalMode] :: DeriveConfig -> Bool
[needExtraMergeableWithConcretizedEvalMode] :: DeriveConfig -> Bool
[useNoStrategy] :: DeriveConfig -> Bool
[useSerialForCerealAndBinary] :: DeriveConfig -> Bool

-- | Derive the specified classes for a data type with the given name.
--   
--   See <a>deriveWith</a> for more details.
derive :: [Name] -> [Name] -> Q [Dec]

-- | Derive the specified classes for a data type with the given name.
--   
--   Support the following classes for both vanilla data types and GADTs.
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>Mergeable1</a></li>
--   <li><a>Mergeable2</a></li>
--   <li><a>Mergeable3</a></li>
--   <li><a>EvalSym</a></li>
--   <li><a>EvalSym1</a></li>
--   <li><a>EvalSym2</a></li>
--   <li><a>ExtractSym</a></li>
--   <li><a>ExtractSym1</a></li>
--   <li><a>ExtractSym2</a></li>
--   <li><a>SubstSym</a></li>
--   <li><a>SubstSym1</a></li>
--   <li><a>SubstSym2</a></li>
--   <li><a>NFData</a></li>
--   <li><a>NFData1</a></li>
--   <li><a>NFData2</a></li>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable1</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable2</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Show</a></li>
--   <li><a>Show1</a></li>
--   <li><a>Show2</a></li>
--   <li><a>PPrint</a></li>
--   <li><a>PPrint1</a></li>
--   <li><a>PPrint2</a></li>
--   <li><a>AllSyms</a></li>
--   <li><a>AllSyms1</a></li>
--   <li><a>AllSyms2</a></li>
--   <li><a>Eq</a></li>
--   <li><a>Eq1</a></li>
--   <li><a>Eq2</a></li>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord1</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord2</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>SymOrd</a></li>
--   <li><a>SymOrd1</a></li>
--   <li><a>SymOrd2</a></li>
--   <li><a>SymEq</a></li>
--   <li><a>SymEq1</a></li>
--   <li><a>SymEq2</a></li>
--   <li><a>UnifiedSymEq</a></li>
--   <li><a>UnifiedSymEq1</a></li>
--   <li><a>UnifiedSymEq2</a></li>
--   <li><a>UnifiedSymOrd</a></li>
--   <li><a>UnifiedSymOrd1</a></li>
--   <li><a>UnifiedSymOrd2</a></li>
--   <li><a>ToSym</a></li>
--   <li><a>ToSym1</a></li>
--   <li><a>ToSym2</a></li>
--   <li><a>ToCon</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToCon2</a></li>
--   <li><a>Serial</a></li>
--   <li><a>Serial1</a></li>
--   <li><a>Serial2</a></li>
--   <li><a>SimpleMergeable</a></li>
--   <li><a>SimpleMergeable1</a></li>
--   <li><a>SimpleMergeable2</a></li>
--   <li><a>Binary</a></li>
--   <li><a>Serialize</a></li>
--   </ul>
--   
--   Note that the following type classes cannot be derived for GADTs with
--   existential type variables.
--   
--   <ul>
--   <li><a>ToCon</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToCon2</a></li>
--   <li><a>ToSym</a></li>
--   <li><a>ToSym1</a></li>
--   <li><a>ToSym2</a></li>
--   <li><a>Serial</a></li>
--   <li><a>Serial1</a></li>
--   <li><a>Serial2</a></li>
--   <li><a>Binary</a></li>
--   <li><a>Serialize</a></li>
--   </ul>
deriveWith :: DeriveConfig -> [Name] -> [Name] -> Q [Dec]

-- | All the classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>EvalSym</a></li>
--   <li><a>ExtractSym</a></li>
--   <li><a>SubstSym</a></li>
--   <li><a>NFData</a></li>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Show</a></li>
--   <li><a>PPrint</a></li>
--   <li><a>AllSyms</a></li>
--   <li><a>Eq</a></li>
--   <li><a>SymEq</a></li>
--   <li><a>SymOrd</a></li>
--   <li><a>UnifiedSymEq</a></li>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd</a></li>
--   <li><a>Serial</a></li>
--   <li><a>ToCon</a></li>
--   <li><a>ToSym</a></li>
--   </ul>
allClasses0 :: [Name]

-- | All the classes that can be derived for GADT functors.
--   
--   This includes all the classes in <a>allClasses0</a> and
--   <a>allClasses1</a>.
allClasses01 :: [Name]

-- | All the classes that can be derived for GADT functors.
--   
--   This includes all the classes in <a>allClasses0</a>,
--   <a>allClasses1</a>, and <a>allClasses2</a>.
allClasses012 :: [Name]

-- | Basic classes for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>EvalSym</a></li>
--   <li><a>ExtractSym</a></li>
--   <li><a>SubstSym</a></li>
--   <li><a>NFData</a></li>
--   <li><a>Show</a></li>
--   <li><a>PPrint</a></li>
--   <li><a>AllSyms</a></li>
--   <li><a>Eq</a></li>
--   <li><a>SymEq</a></li>
--   <li><a>SymOrd</a></li>
--   <li><a>UnifiedSymEq</a></li>
--   </ul>
--   
--   These classes can be derived for most GADTs.
basicClasses0 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable1</a></li>
--   <li><a>EvalSym1</a></li>
--   <li><a>ExtractSym1</a></li>
--   <li><a>SubstSym1</a></li>
--   <li><a>NFData1</a></li>
--   <li><a>Show1</a></li>
--   <li><a>PPrint1</a></li>
--   <li><a>AllSyms1</a></li>
--   <li><a>Eq1</a></li>
--   <li><a>SymEq1</a></li>
--   <li><a>SymOrd1</a></li>
--   <li><a>UnifiedSymEq1</a></li>
--   </ul>
basicClasses1 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable2</a></li>
--   <li><a>EvalSym2</a></li>
--   <li><a>ExtractSym2</a></li>
--   <li><a>SubstSym2</a></li>
--   <li><a>NFData2</a></li>
--   <li><a>Show2</a></li>
--   <li><a>PPrint2</a></li>
--   <li><a>AllSyms2</a></li>
--   <li><a>Eq2</a></li>
--   <li><a>SymEq2</a></li>
--   <li><a>SymOrd2</a></li>
--   <li><a>UnifiedSymEq2</a></li>
--   </ul>
basicClasses2 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes all the classes in <a>basicClasses0</a> and
--   <a>basicClasses1</a>.
basicClasses01 :: [Name]

-- | Basic classes for GADT functors.
--   
--   This includes all the classes in <a>basicClasses0</a> and
--   <a>basicClasses1</a> and <a>basicClasses2</a>.
basicClasses012 :: [Name]

-- | Classes that can only be derived for GADTs without existential type
--   variables.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial</a></li>
--   <li><a>Serialize</a></li>
--   <li><a>Binary</a></li>
--   <li><a>ToCon</a></li>
--   <li><a>ToSym</a></li>
--   </ul>
noExistentialClasses0 :: [Name]

-- | Concrete ordered classes that can be derived for GADTs that
--   
--   <ul>
--   <li>uses unified evaluation mode, or</li>
--   <li>does not contain any symbolic variables.</li>
--   </ul>
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd</a></li>
--   </ul>
concreteOrdClasses0 :: [Name]

-- | <tt>*1</tt> classes that can only be derived for GADT functors without
--   existential type variables.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial1</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToSym1</a></li>
--   </ul>
noExistentialClasses1 :: [Name]

-- | <tt>*1</tt> concrete ordered classes that can be derived for GADT
--   functors that
--   
--   <ul>
--   <li>uses unified evaluation mode, or</li>
--   <li>does not contain any symbolic variables.</li>
--   </ul>
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord1</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd1</a></li>
--   </ul>
concreteOrdClasses1 :: [Name]

-- | <tt>*2</tt> classes that can only be derived for GADT functors without
--   existential type variables.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial2</a></li>
--   <li><a>ToCon2</a></li>
--   <li><a>ToSym2</a></li>
--   </ul>
noExistentialClasses2 :: [Name]

-- | <tt>*2</tt> concrete ordered classes that can be derived for GADT
--   functors that
--   
--   <ul>
--   <li>uses unified evaluation mode, or</li>
--   <li>does not contain any symbolic variables.</li>
--   </ul>
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord2</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>UnifiedSymOrd2</a></li>
--   </ul>
concreteOrdClasses2 :: [Name]

-- | <a>Show</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Show</a></li>
--   <li><a>Show1</a></li>
--   <li><a>Show2</a></li>
--   </ul>
showClasses :: [Name]

-- | <a>PPrint</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>PPrint</a></li>
--   <li><a>PPrint1</a></li>
--   <li><a>PPrint2</a></li>
--   </ul>
pprintClasses :: [Name]

-- | <a>EvalSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>EvalSym</a></li>
--   <li><a>EvalSym1</a></li>
--   <li><a>EvalSym2</a></li>
--   </ul>
evalSymClasses :: [Name]

-- | <a>ExtractSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>ExtractSym</a></li>
--   <li><a>ExtractSym1</a></li>
--   <li><a>ExtractSym2</a></li>
--   </ul>
extractSymClasses :: [Name]

-- | <a>SubstSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SubstSym</a></li>
--   <li><a>SubstSym1</a></li>
--   <li><a>SubstSym2</a></li>
--   </ul>
substSymClasses :: [Name]

-- | <a>AllSyms</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>AllSyms</a></li>
--   <li><a>AllSyms1</a></li>
--   <li><a>AllSyms2</a></li>
--   </ul>
allSymsClasses :: [Name]

-- | <a>Eq</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Eq</a></li>
--   <li><a>Eq1</a></li>
--   <li><a>Eq2</a></li>
--   </ul>
eqClasses :: [Name]

-- | <a>Ord</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Ord</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord1</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   <li><a>Ord2</a> (will fail to derive if the type contains any symbolic
--   variables)</li>
--   </ul>
ordClasses :: [Name]

-- | <a>SymOrd</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SymOrd</a></li>
--   <li><a>SymOrd1</a></li>
--   <li><a>SymOrd2</a></li>
--   </ul>
symOrdClasses :: [Name]

-- | <a>SymEq</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SymEq</a></li>
--   <li><a>SymEq1</a></li>
--   <li><a>SymEq2</a></li>
--   </ul>
symEqClasses :: [Name]

-- | <a>UnifiedSymOrd</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>UnifiedSymOrd</a></li>
--   <li><a>UnifiedSymOrd1</a></li>
--   <li><a>UnifiedSymOrd2</a></li>
--   </ul>
unifiedSymOrdClasses :: [Name]

-- | <a>UnifiedSymEq</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>UnifiedSymEq</a></li>
--   <li><a>UnifiedSymEq1</a></li>
--   <li><a>UnifiedSymEq2</a></li>
--   </ul>
unifiedSymEqClasses :: [Name]

-- | <a>Mergeable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Mergeable</a></li>
--   <li><a>Mergeable1</a></li>
--   <li><a>Mergeable2</a></li>
--   <li><a>Mergeable3</a></li>
--   </ul>
mergeableClasses :: [Name]

-- | <a>NFData</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>NFData</a></li>
--   <li><a>NFData1</a></li>
--   <li><a>NFData2</a></li>
--   </ul>
nfDataClasses :: [Name]

-- | <a>Hashable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Hashable</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable1</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   <li><a>Hashable2</a> (will fail to derive if the type contains any
--   symbolic variables)</li>
--   </ul>
hashableClasses :: [Name]

-- | <a>ToSym</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>ToSym</a></li>
--   <li><a>ToSym1</a></li>
--   <li><a>ToSym2</a></li>
--   </ul>
toSymClasses :: [Name]

-- | <a>ToCon</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>ToCon</a></li>
--   <li><a>ToCon1</a></li>
--   <li><a>ToCon2</a></li>
--   </ul>
toConClasses :: [Name]

-- | <a>Serial</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>Serial</a></li>
--   <li><a>Serial1</a></li>
--   <li><a>Serial2</a></li>
--   </ul>
serialClasses :: [Name]

-- | <a>SimpleMergeable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>SimpleMergeable</a></li>
--   <li><a>SimpleMergeable1</a></li>
--   <li><a>SimpleMergeable2</a></li>
--   </ul>
simpleMergeableClasses :: [Name]

-- | <a>UnifiedSimpleMergeable</a> classes that can be derived for GADTs.
--   
--   This includes:
--   
--   <ul>
--   <li><a>UnifiedSimpleMergeable</a></li>
--   <li><a>UnifiedSimpleMergeable1</a></li>
--   <li><a>UnifiedSimpleMergeable2</a></li>
--   </ul>
unifiedSimpleMergeableClasses :: [Name]

-- | Filter classes that accepts type constructors with exactly <tt>n</tt>
--   arguments.
filterExactNumArgs :: Int -> [Name] -> [Name]

-- | Filter classes that accepts type constructors with at most <tt>n</tt>
--   arguments.
filterLeqNumArgs :: Int -> [Name] -> [Name]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a>.
--   
--   <pre>
--   makePrefixedSmartCtor "mrg" ''Maybe
--   </pre>
--   
--   generates
--   
--   <pre>
--   mrgNothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; m (Maybe a)
--   mrgNothing = mrgSingle Nothing
--   mrgJust :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; a -&gt; m (Maybe a)
--   mrgJust = \x -&gt; mrgSingle (Just x)
--   </pre>
makePrefixedSmartCtor :: String -> Name -> Q [Dec]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a> with provided names.
--   
--   <pre>
--   makeNamedSmartCtor ["mrgTuple2"] ''(,)
--   </pre>
--   
--   generates
--   
--   <pre>
--   mrgTuple2 :: (Mergeable (a, b), Applicative m, TryMerge m) =&gt; a -&gt; b -&gt; u (a, b)
--   mrgTuple2 = \v1 v2 -&gt; mrgSingle (v1, v2)
--   </pre>
makeNamedSmartCtor :: [String] -> Name -> Q [Dec]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a>.
--   
--   <pre>
--   makeSmartCtor ''Maybe
--   </pre>
--   
--   generates
--   
--   <pre>
--   nothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; m (Maybe a)
--   nothing = mrgSingle Nothing
--   just :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; a -&gt; m (Maybe a)
--   just = \x -&gt; mrgSingle (Just x)
--   </pre>
makeSmartCtor :: Name -> Q [Dec]

-- | Generate constructor wrappers that wraps the result in a container
--   with <a>TryMerge</a> with provided name transformer.
--   
--   <pre>
--   makeSmartCtorWith (\name -&gt; "mrg" ++ name) ''Maybe
--   </pre>
--   
--   generates
--   
--   <pre>
--   mrgNothing :: (Mergeable (Maybe a), Applicative m, TryMerge m) =&gt; m (Maybe a)
--   mrgNothing = mrgSingle Nothing
--   </pre>
makeSmartCtorWith :: (String -> String) -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the given prefix, e.g., <tt>mkT1</tt>, <tt>mkT2</tt>, etc.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makePrefixedUnifiedCtor :: [Name] -> String -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the given names.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makeNamedUnifiedCtor :: [Name] -> [String] -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the names decapitalized, e.g., <tt>t1</tt>, <tt>t2</tt>, etc.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makeUnifiedCtor :: [Name] -> Name -> Q [Dec]

-- | Generate smart constructors to create unified values with provided
--   name transformer.
--   
--   For a type <tt>T mode a b c</tt> with constructors <tt>T1</tt>,
--   <tt>T2</tt>, etc., this function will generate smart constructors with
--   the name transformed, e.g., given the name transformer <tt>(name -&gt;
--   "mk" ++ name)</tt>, it will generate <tt>mkT1</tt>, <tt>mkT2</tt>,
--   <tt>mkT2</tt>, etc.
--   
--   The generated smart constructors will contruct values of type
--   <tt>GetData mode (T mode a b c)</tt>.
makeUnifiedCtorWith :: [Name] -> (String -> String) -> Name -> Q [Dec]


module Grisette.Internal.Unified.Class.UnifiedSimpleMergeable

-- | A class that provides a unified branching operation.
--   
--   We use this type class to help resolve the constraints for
--   <a>SymBranching</a>.
class (DecideEvalMode mode, TryMerge m) => UnifiedBranching (mode :: EvalModeTag) (m :: Type -> Type)
withBaseBranching :: UnifiedBranching mode m => (If (IsConMode mode) (TryMerge m) (SymBranching m) => r) -> r

-- | A class that provides a unified simple merging.
--   
--   We use this type class to help resolve the constraints for
--   <a>SimpleMergeable</a>.
class (DecideEvalMode mode, Mergeable a) => UnifiedSimpleMergeable (mode :: EvalModeTag) a
withBaseSimpleMergeable :: UnifiedSimpleMergeable mode a => (If (IsConMode mode) () (SimpleMergeable a) => r) -> r

-- | A class that provides lifting of unified simple merging.
--   
--   We use this type class to help resolve the constraints for
--   <a>SimpleMergeable1</a>.
class DecideEvalMode mode => UnifiedSimpleMergeable1 (mode :: EvalModeTag) (f :: Type -> Type)
withBaseSimpleMergeable1 :: UnifiedSimpleMergeable1 mode f => (If (IsConMode mode) () (SimpleMergeable1 f) => r) -> r

-- | A class that provides lifting of unified simple merging.
--   
--   We use this type class to help resolve the constraints for
--   <a>SimpleMergeable2</a>.
class DecideEvalMode mode => UnifiedSimpleMergeable2 (mode :: EvalModeTag) (f :: Type -> Type -> Type)
withBaseSimpleMergeable2 :: UnifiedSimpleMergeable2 mode f => (If (IsConMode mode) () (SimpleMergeable2 f) => r) -> r

-- | Unified <a>mrgIf</a>.
--   
--   This function isn't able to infer the mode of the boolean variable, so
--   you need to provide the mode explicitly. For example:
--   
--   <pre>
--   mrgIf @mode (a .== b) ...
--   mrgIf (a .== b :: SymBool) ...
--   mrgIf (a .== b :: GetBool mode) ...
--   </pre>
mrgIf :: forall (mode :: EvalModeTag) a m. (DecideEvalMode mode, Mergeable a, UnifiedBranching mode m) => GetBool mode -> m a -> m a -> m a

-- | Unified lifting of a base monad.
liftUnion :: forall (mode :: EvalModeTag) a m u. (Applicative m, UnifiedBranching mode m, Mergeable a, UnionView u, UnionViewMode mode u) => u a -> m a

-- | Unified <a>mrgIte</a>.
mrgIte :: forall (mode :: EvalModeTag) a. UnifiedSimpleMergeable mode a => GetBool mode -> a -> a -> a

-- | Unified <a>mrgIte1</a>.
mrgIte1 :: forall (mode :: EvalModeTag) f a. (UnifiedSimpleMergeable1 mode f, UnifiedSimpleMergeable mode a) => GetBool mode -> f a -> f a -> f a

-- | Unified <a>liftMrgIte</a>.
liftMrgIte :: forall (mode :: EvalModeTag) f a. UnifiedSimpleMergeable1 mode f => (GetBool mode -> a -> a -> a) -> GetBool mode -> f a -> f a -> f a

-- | Unified <a>mrgIte2</a>.
mrgIte2 :: forall (mode :: EvalModeTag) f a b. (UnifiedSimpleMergeable2 mode f, UnifiedSimpleMergeable mode a, UnifiedSimpleMergeable mode b) => GetBool mode -> f a b -> f a b -> f a b

-- | Unified <a>liftMrgIte2</a>.
liftMrgIte2 :: forall (mode :: EvalModeTag) f a b. UnifiedSimpleMergeable2 mode f => (GetBool mode -> a -> a -> a) -> (GetBool mode -> b -> b -> b) -> GetBool mode -> f a b -> f a b -> f a b

-- | Unified merge of simply mergeable values in the base monad.
simpleMerge :: forall (mode :: EvalModeTag) a u. (UnifiedSimpleMergeable mode a, UnionView u, UnionViewMode mode u) => u a -> a


module Grisette.Internal.Unified.UnifiedPrim

-- | A type that is used as a constraint for all the (unified) primitive
--   types in Grisette.
type UnifiedPrim (mode :: EvalModeTag) a = (Prim a, UnifiedITEOp mode a, UnifiedSymEq mode a, UnifiedSymOrd mode a)

-- | A type that is used as a constraint for all the basic (unified)
--   primitive types in Grisette.
--   
--   <a>GetSomeWordN</a> is not considered as a basic (unified) primitive
--   type.
type UnifiedBasicPrim (mode :: EvalModeTag) a = (UnifiedPrim mode a, UnifiedSimpleMergeable mode a, UnifiedConRep a, UnifiedSymRep a, UnifiedSolvable mode a ConType a, ConSymConversion ConType a SymType a a)


module Grisette.Internal.Unified.Class.UnifiedSafeSymShift

-- | Unified <a>safeSymShiftL</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymShiftL @mode a b
--   </pre>
safeSymShiftL :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | Unified <a>safeSymShiftR</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymShiftR @mode a b
--   </pre>
safeSymShiftR :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | Unified <a>safeSymStrictShiftL</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymStrictShiftL @mode a b
--   </pre>
safeSymStrictShiftL :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | Unified <a>safeSymStrictShiftR</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymStrictShiftR @mode a b
--   </pre>
safeSymStrictShiftR :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | A class that provides unified safe symbolic rotation operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeSymShift</a>.
class UnifiedSafeSymShift (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeSymShift :: UnifiedSafeSymShift mode e a m => (SafeSymShift e a m => r) -> r
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymWordN m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeWordN m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Core.Data.Class.SafeSymShift.SafeSymShift e a m) => Grisette.Internal.Unified.Class.UnifiedSafeSymShift.UnifiedSafeSymShift mode e a m


module Grisette.Internal.Unified.Class.UnifiedSafeSymRotate

-- | Unified <a>safeSymRotateL</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymRotateL @mode a b
--   </pre>
safeSymRotateL :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymRotate mode e a m) => a -> a -> m a

-- | Unified <a>safeSymRotateR</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymRotateR @mode a b
--   </pre>
safeSymRotateR :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymRotate mode e a m) => a -> a -> m a

-- | A class that provides unified safe symbolic rotation operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeSymRotate</a>.
class UnifiedSafeSymRotate (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeSymRotate :: UnifiedSafeSymRotate mode e a m => (SafeSymRotate e a m => r) -> r
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymWordN m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeWordN m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Core.Data.Class.SafeSymRotate.SafeSymRotate e a m) => Grisette.Internal.Unified.Class.UnifiedSafeSymRotate.UnifiedSafeSymRotate mode e a m


module Grisette.Internal.Unified.Class.UnifiedSafeLinearArith

-- | Unified <a>safeAdd</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeAdd @mode a b
--   </pre>
safeAdd :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeLinearArith mode e a m) => a -> a -> m a

-- | Unified <a>safeNeg</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeNeg @mode a
--   </pre>
safeNeg :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeLinearArith mode e a m) => a -> m a

-- | Unified <a>safeSub</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSub @mode a b
--   </pre>
safeSub :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeLinearArith mode e a m) => a -> a -> m a

-- | A class that provides unified linear arithmetic operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeLinearArith</a>.
class UnifiedSafeLinearArith (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeLinearArith :: UnifiedSafeLinearArith mode e a m => (SafeLinearArith e a m => r) -> r
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.SymInteger.SymInteger m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymWordN m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith mode GHC.Internal.Exception.Type.ArithException GHC.Num.Integer.Integer m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeWordN m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Core.Data.Class.SafeLinearArith.SafeLinearArith e a m) => Grisette.Internal.Unified.Class.UnifiedSafeLinearArith.UnifiedSafeLinearArith mode e a m


module Grisette.Internal.Unified.Class.UnifiedSafeFromFP

-- | A class that provides unified safe conversion from floating points.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeFromFP</a>.
class UnifiedSafeFromFP (mode :: EvalModeTag) e a fp fprd (m :: Type -> Type)
withBaseSafeFromFP :: UnifiedSafeFromFP mode e a fp fprd m => (SafeFromFP e a fp fprd m => r) -> r

-- | Unified <a>safeFromFP</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeFromFP @mode mode fp
--   </pre>
safeFromFP :: forall (mode :: EvalModeTag) e a fp fprd m. (UnifiedSafeFromFP mode e a fp fprd m, MonadError e m) => fprd -> fp -> m a
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymBV.SymIntN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.SymInteger.SymInteger (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymBV.SymWordN n) (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) Grisette.Internal.SymPrim.SymFP.SymFPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP mode Grisette.Internal.SymPrim.FP.NotRepresentableFPError Grisette.Internal.SymPrim.AlgReal.AlgReal (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP mode Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.BV.IntN n) (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.SymPrim.FP.ValidFP eb sb) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP mode Grisette.Internal.SymPrim.FP.NotRepresentableFPError GHC.Num.Integer.Integer (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP mode Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.BV.WordN n) (Grisette.Internal.SymPrim.FP.FP eb sb) Grisette.Internal.SymPrim.FP.FPRoundingMode m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Core.Data.Class.SafeFromFP.SafeFromFP e a fp fprd m) => Grisette.Internal.Unified.Class.UnifiedSafeFromFP.UnifiedSafeFromFP mode e a fp fprd m


module Grisette.Internal.Unified.Class.UnifiedSafeFdiv

-- | Unified <a>safeFdiv</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeFdiv @mode a b
--   </pre>
safeFdiv :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeFdiv mode e a m) => a -> a -> m a

-- | A class that provides unified floating division operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeFdiv</a>.
class UnifiedSafeFdiv (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseUnifiedSafeFdiv :: UnifiedSafeFdiv mode e a m => (SafeFdiv e a m => r) -> r
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeFdiv.UnifiedSafeFdiv 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeFdiv.UnifiedSafeFdiv mode GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.AlgReal.AlgReal m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Core.Data.Class.SafeFdiv.SafeFdiv e a m) => Grisette.Internal.Unified.Class.UnifiedSafeFdiv.UnifiedSafeFdiv mode e a m


module Grisette.Internal.Unified.Class.UnifiedSafeDiv

-- | Unified <a>safeDiv</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeDiv @mode a b
--   </pre>
safeDiv :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeMod</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeMod @mode a b
--   </pre>
safeMod :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeDivMod</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeDivMod @mode a b
--   </pre>
safeDivMod :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m (a, a)

-- | Unified <a>safeQuot</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeQuot @mode a b
--   </pre>
safeQuot :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeRem</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeRem @mode a b
--   </pre>
safeRem :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeQuotRem</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeQuotRem @mode a b
--   </pre>
safeQuotRem :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m (a, a)

-- | A class that provides unified division operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeDiv</a>.
class UnifiedSafeDiv (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeDiv :: UnifiedSafeDiv mode e a m => (SafeDiv e a m => r) -> r
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException Grisette.Internal.SymPrim.SymInteger.SymInteger m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv 'Grisette.Internal.Unified.EvalModeTag.S GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv 'Grisette.Internal.Unified.EvalModeTag.S (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeSymWordN m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv mode GHC.Internal.Exception.Type.ArithException GHC.Num.Integer.Integer m
instance (Control.Monad.Error.Class.MonadError GHC.Internal.Exception.Type.ArithException m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv mode GHC.Internal.Exception.Type.ArithException (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeIntN m
instance (Control.Monad.Error.Class.MonadError (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv mode (GHC.Internal.Data.Either.Either Grisette.Internal.SymPrim.SomeBV.SomeBVException GHC.Internal.Exception.Type.ArithException) Grisette.Internal.SymPrim.SomeBV.SomeWordN m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Internal.Decl.Core.Data.Class.SafeDiv.SafeDiv e a m) => Grisette.Internal.Unified.Class.UnifiedSafeDiv.UnifiedSafeDiv mode e a m


module Grisette.Internal.Unified.UnifiedInteger

-- | Get a unified Integer type. Resolves to <a>Integer</a> in <a>C</a>
--   mode, and <a>SymInteger</a> in <a>S</a> mode.
type family GetInteger (mode :: EvalModeTag) = (int :: Type) | int -> mode

-- | Evaluation mode with unified <a>Integer</a> type.
class UnifiedIntegerImpl mode GetInteger mode => UnifiedInteger (mode :: EvalModeTag)
instance Grisette.Internal.Unified.UnifiedInteger.UnifiedIntegerImpl 'Grisette.Internal.Unified.EvalModeTag.C GHC.Num.Integer.Integer
instance Grisette.Internal.Unified.UnifiedInteger.UnifiedIntegerImpl 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymInteger.SymInteger
instance Grisette.Internal.Unified.UnifiedInteger.UnifiedInteger 'Grisette.Internal.Unified.EvalModeTag.C
instance Grisette.Internal.Unified.UnifiedInteger.UnifiedInteger 'Grisette.Internal.Unified.EvalModeTag.S


module Grisette.Internal.Unified.UnifiedAlgReal

-- | Evaluation mode with unified <a>AlgReal</a> type.
class UnifiedAlgRealImpl mode GetAlgReal mode => UnifiedAlgReal (mode :: EvalModeTag)

-- | Get a unified algebraic real type. Resolves to <a>AlgReal</a> in
--   <a>C</a> mode, and <a>SymAlgReal</a> in <a>S</a> mode.
--   
--   <a>Floating</a>, <a>LogBaseOr</a> and <a>SafeLogBase</a> for
--   <a>SymAlgReal</a> are not provided as they are not available for
--   <a>AlgReal</a>.
type family GetAlgReal (mode :: EvalModeTag) = (real :: Type) | real -> mode
instance Grisette.Internal.Unified.UnifiedAlgReal.UnifiedAlgRealImpl 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.AlgReal.AlgReal
instance Grisette.Internal.Unified.UnifiedAlgReal.UnifiedAlgRealImpl 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymAlgReal.SymAlgReal
instance Grisette.Internal.Unified.UnifiedAlgReal.UnifiedAlgReal 'Grisette.Internal.Unified.EvalModeTag.C
instance Grisette.Internal.Unified.UnifiedAlgReal.UnifiedAlgReal 'Grisette.Internal.Unified.EvalModeTag.S


module Grisette.Internal.Unified.Class.UnifiedSafeBitCast

-- | Unified <a>safeSub</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSub @mode a b
--   </pre>
safeBitCast :: forall (mode :: EvalModeTag) e a b m. (MonadError e m, UnifiedSafeBitCast mode e a b m) => a -> m b

-- | A class that provides unified safe bitcast operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeBitCast</a>.
class UnifiedSafeBitCast (mode :: EvalModeTag) e a b (m :: Type -> Type)
withBaseSafeBitCast :: UnifiedSafeBitCast mode e a b m => (SafeBitCast e a b m => r) -> r
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Unified.Class.UnifiedSafeBitCast.UnifiedSafeBitCast 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymIntN n) m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching 'Grisette.Internal.Unified.EvalModeTag.S m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Unified.Class.UnifiedSafeBitCast.UnifiedSafeBitCast 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.SymFP.SymFP eb sb) (Grisette.Internal.SymPrim.SymBV.SymWordN n) m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Unified.Class.UnifiedSafeBitCast.UnifiedSafeBitCast mode Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.IntN n) m
instance (Control.Monad.Error.Class.MonadError Grisette.Internal.SymPrim.FP.NotRepresentableFPError m, Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.SymPrim.FP.ValidFP eb sb, GHC.Internal.TypeNats.KnownNat n, 1 GHC.Internal.Data.Type.Ord.<= n, n GHC.Types.~ (eb GHC.Internal.TypeNats.+ sb)) => Grisette.Internal.Unified.Class.UnifiedSafeBitCast.UnifiedSafeBitCast mode Grisette.Internal.SymPrim.FP.NotRepresentableFPError (Grisette.Internal.SymPrim.FP.FP eb sb) (Grisette.Internal.SymPrim.BV.WordN n) m
instance (Grisette.Internal.Internal.Decl.Unified.Class.UnifiedSimpleMergeable.UnifiedBranching mode m, Grisette.Internal.Core.Data.Class.SafeBitCast.SafeBitCast e a b m) => Grisette.Internal.Unified.Class.UnifiedSafeBitCast.UnifiedSafeBitCast mode e a b m


module Grisette.Internal.Unified.UnifiedFP

-- | Implementation for <a>UnifiedFP</a>.
class (UnifiedConRep fp, UnifiedSymRep fp, ConType fp ~ FP eb sb, SymType fp ~ SymFP eb sb, UnifiedBasicPrim mode fp, Floating fp, SymIEEEFPTraits fp, IEEEFPConstants fp, IEEEFPOp fp, IEEEFPRoundingOp fp rd, UnifiedFromIntegral mode GetInteger mode fp, IEEEFPToAlgReal GetAlgReal mode fp rd, IEEEFPConvertible GetInteger mode fp rd, ConSymConversion FP eb sb SymFP eb sb fp, fpn ~ GetFP mode, fp ~ fpn eb sb, rd ~ GetFPRoundingMode mode) => UnifiedFPImpl (mode :: EvalModeTag) (fpn :: Nat -> Nat -> Type) (eb :: Nat) (sb :: Nat) fp rd | fpn eb sb -> fp rd, fp -> fpn eb sb rd, rd -> fpn, rd eb sb -> fp where {
    
    -- | Get a unified floating point type. Resolves to <a>FP</a> in <a>C</a>
    --   mode, and <a>SymFP</a> in <a>S</a> mode.
    type GetFP (mode :: EvalModeTag) = (f :: Nat -> Nat -> Type) | f -> mode;
    
    -- | Get a unified floating point rounding mode type. Resolves to
    --   <a>FPRoundingMode</a> in <a>C</a> mode, and <a>SymFPRoundingMode</a>
    --   in <a>S</a> mode.
    type GetFPRoundingMode (mode :: EvalModeTag) = (r :: Type) | r -> mode;
}

-- | Evaluation mode with unified <a>FP</a> type.
class UnifiedFPImpl mode GetFP mode eb sb GetFP mode eb sb GetFPRoundingMode mode => UnifiedFP (mode :: EvalModeTag) (eb :: Nat) (sb :: Nat)

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class (SafeUnifiedFPImpl mode GetFP mode eb sb GetFP mode eb sb GetFPRoundingMode mode m, UnifiedSafeFromFP mode NotRepresentableFPError GetInteger mode GetFP mode eb sb GetFPRoundingMode mode m) => SafeUnifiedFP (mode :: EvalModeTag) (eb :: Nat) (sb :: Nat) (m :: Type -> Type)

-- | Evaluation mode with unified floating point type.
class (forall (eb :: Nat) (sb :: Nat). ValidFP eb sb => UnifiedFP mode eb sb, forall (eb :: Nat) (sb :: Nat) (m :: Type -> Type). (ValidFP eb sb, UnifiedBranching mode m, MonadError NotRepresentableFPError m) => SafeUnifiedFP mode eb sb m) => AllUnifiedFP (mode :: EvalModeTag)


module Grisette.Internal.Unified.FPFPConversion

-- | Unified constraints for conversion from floating point numbers to
--   floating point numbers.
class UnifiedFPFPConversionImpl mode GetFP mode eb0 sb0 eb1 sb1 GetFP mode eb0 sb0 GetFP mode eb1 sb1 GetFPRoundingMode mode => UnifiedFPFPConversion (mode :: EvalModeTag) (eb0 :: Nat) (sb0 :: Nat) (eb1 :: Nat) (sb1 :: Nat)

-- | Evaluation mode with unified conversion from floating-points to
--   floating-points.
class forall (eb0 :: Nat) (sb0 :: Nat) (eb1 :: Nat) (sb1 :: Nat). (ValidFP eb0 sb0, ValidFP eb1 sb1) => UnifiedFPFPConversion mode eb0 sb0 eb1 sb1 => AllUnifiedFPFPConversion (mode :: EvalModeTag)


module Grisette.Internal.Unified.UnifiedBV

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class UnifiedBVImpl mode GetWordN mode GetIntN mode n GetWordN mode n GetIntN mode n => UnifiedBV (mode :: EvalModeTag) (n :: Nat)

-- | Implementation for <a>UnifiedBV</a>.
class (UnifiedConRep word, UnifiedSymRep int, ConType word ~ WordN n, SymType word ~ SymWordN n, ConType int ~ IntN n, SymType int ~ SymIntN n, UnifiedBasicPrim mode word, UnifiedBasicPrim mode int, BVConstraint mode word int, wordn ~ GetWordN mode, intn ~ GetIntN mode, word ~ wordn n, int ~ intn n, BitCast word int, BitCast int word, DivOr word, DivOr int, UnifiedFromIntegral mode GetInteger mode word, UnifiedFromIntegral mode GetInteger mode int, UnifiedFromIntegral mode word GetInteger mode, UnifiedFromIntegral mode word GetAlgReal mode, UnifiedFromIntegral mode int GetInteger mode, UnifiedFromIntegral mode int GetAlgReal mode, ConSymConversion WordN n SymWordN n word, ConSymConversion IntN n SymIntN n int) => UnifiedBVImpl (mode :: EvalModeTag) (wordn :: Nat -> Type) (intn :: Nat -> Type) (n :: Nat) word int | wordn -> intn, intn -> wordn, wordn n -> word, word -> wordn n, intn n -> int, int -> intn n where {
    
    -- | Get a unified unsigned size-tagged bit vector type. Resolves to
    --   <a>WordN</a> in <a>C</a> mode, and <a>SymWordN</a> in <a>S</a> mode.
    type GetWordN (mode :: EvalModeTag) = (w :: Nat -> Type) | w -> mode;
    
    -- | Get a unified signed size-tagged bit vector type. Resolves to
    --   <a>IntN</a> in <a>C</a> mode, and <a>SymIntN</a> in <a>S</a> mode.
    type GetIntN (mode :: EvalModeTag) = (i :: Nat -> Type) | i -> mode;
}

-- | Evaluation mode with unified bit vector types.
class (forall (n :: Nat) (m :: Type -> Type). (UnifiedBranching mode m, MonadError ArithException m, KnownNat n, 1 <= n) => SafeUnifiedBV mode n m, forall (m :: Type -> Type). (UnifiedBranching mode m, MonadError Either SomeBVException ArithException m) => SafeUnifiedSomeBV mode m, forall (n :: Nat). (KnownNat n, 1 <= n) => UnifiedBV mode n, SomeBVPair mode GetSomeWordN mode GetSomeIntN mode, SizedBV GetWordN mode, SizedBV GetIntN mode) => AllUnifiedBV (mode :: EvalModeTag)

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class SafeUnifiedBVImpl mode GetWordN mode GetIntN mode n GetWordN mode n GetIntN mode n m => SafeUnifiedBV (mode :: EvalModeTag) (n :: Nat) (m :: Type -> Type)

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class SafeUnifiedSomeBVImpl mode SomeBV GetWordN mode SomeBV GetIntN mode m => SafeUnifiedSomeBV (mode :: EvalModeTag) (m :: Type -> Type)

-- | Get a unified unsigned dynamic bit width bit vector type. Resolves to
--   <a>SomeWordN</a> in <a>C</a> mode, and <a>SomeSymWordN</a> in <a>S</a>
--   mode.
type family GetSomeWordN (mode :: EvalModeTag) = (sw :: Type) | sw -> mode

-- | Get a unified signed dynamic bit width bit vector type. Resolves to
--   <a>SomeIntN</a> in <a>C</a> mode, and <a>SomeSymIntN</a> in <a>S</a>
--   mode.
type family GetSomeIntN (mode :: EvalModeTag) = (sw :: Type) | sw -> mode

-- | Constraints for a pair of non-sized-tagged bit vector types.
type SomeBVPair (mode :: EvalModeTag) word int = (UnifiedPrim mode word, UnifiedPrim mode int, BVConstraint mode word int, BV word, BV int, DivOr word, DivOr int, ConSymConversion SomeWordN SomeSymWordN word, ConSymConversion SomeIntN SomeSymIntN int)


module Grisette.Internal.Unified.UnifiedFun

-- | The constraint for a unified function.
type UnifiedFunConstraint (mode :: EvalModeTag) a b ca cb sa sb = (Show GetFun mode a b, Binary GetFun mode a b, Serial GetFun mode a b, Serialize GetFun mode a b, NFData GetFun mode a b, Eq GetFun mode a b, EvalSym GetFun mode a b, ExtractSym GetFun mode a b, Mergeable GetFun mode a b, PPrint GetFun mode a b, SubstSym GetFun mode a b, Lift GetFun mode a b, Typeable GetFun mode a b, ToCon GetFun mode a b ca =-> cb, ToCon sa =~> sb GetFun mode a b, ToSym GetFun mode a b sa =~> sb, ToSym ca =-> cb GetFun mode a b, Function GetFun mode a b a b, Apply GetFun mode a b, FunType GetFun mode a b ~ a -> b)

-- | Provide unified function types.
class UnifiedFun (mode :: EvalModeTag) where {
    
    -- | Get a unified function type. Resolves to <a>=-&gt;</a> in <a>C</a>
    --   mode, and <a>=~&gt;</a> in <a>S</a> mode.
    type GetFun (mode :: EvalModeTag) = (fun :: Type -> Type -> Type) | fun -> mode;
}

-- | Generate unified function instance names.
unifiedFunInstanceName :: String -> [TheoryToUnify] -> String

-- | Generate unified function instances.
genUnifiedFunInstance :: String -> [TheoryToUnify] -> DecsQ

-- | The unified function type with 2 arguments.
type GetFun2 (mode :: EvalModeTag) a b = GetFun mode a b

-- | The unified function type with 3 arguments.
type GetFun3 (mode :: EvalModeTag) a b c = GetFun mode a GetFun mode b c

-- | The unified function type with 4 arguments.
type GetFun4 (mode :: EvalModeTag) a b c d = GetFun mode a GetFun mode b GetFun mode c d

-- | The unified function type with 5 arguments.
type GetFun5 (mode :: EvalModeTag) a b c d e = GetFun mode a GetFun mode b GetFun mode c GetFun mode d e

-- | The unified function type with 6 arguments.
type GetFun6 (mode :: EvalModeTag) a b c d e f = GetFun mode a GetFun mode b GetFun mode c GetFun mode d GetFun mode e f

-- | The unified function type with 7 arguments.
type GetFun7 (mode :: EvalModeTag) a b c d e f g = GetFun mode a GetFun mode b GetFun mode c GetFun mode d GetFun mode e GetFun mode f g

-- | The unified function type with 8 arguments.
type GetFun8 (mode :: EvalModeTag) a b c d e f g h = GetFun mode a GetFun mode b GetFun mode c GetFun mode d GetFun mode e GetFun mode f GetFun mode g h
instance Grisette.Internal.Unified.UnifiedFun.UnifiedFun 'Grisette.Internal.Unified.EvalModeTag.C
instance Grisette.Internal.Unified.UnifiedFun.UnifiedFun 'Grisette.Internal.Unified.EvalModeTag.S


module Grisette.Internal.Unified.BVBVConversion

-- | Unified constraints for conversion between bit-vectors.
class (UnifiedBVBVConversionImpl mode GetWordN mode GetWordN mode n0 n1 GetWordN mode n0 GetWordN mode n1, UnifiedBVBVConversionImpl mode GetWordN mode GetIntN mode n0 n1 GetWordN mode n0 GetIntN mode n1, UnifiedBVBVConversionImpl mode GetIntN mode GetWordN mode n0 n1 GetIntN mode n0 GetWordN mode n1, UnifiedBVBVConversionImpl mode GetIntN mode GetIntN mode n0 n1 GetIntN mode n0 GetIntN mode n1) => UnifiedBVBVConversion (mode :: EvalModeTag) (n0 :: Nat) (n1 :: Nat)

-- | Evaluation mode with unified conversion from bit-vectors to
--   bit-vectors.
class forall (n0 :: Nat) (n1 :: Nat). (KnownNat n0, KnownNat n1, 1 <= n0, 1 <= n1) => UnifiedBVBVConversion mode n0 n1 => AllUnifiedBVBVConversion (mode :: EvalModeTag)
instance (forall (n0 :: GHC.Internal.TypeNats.Nat) (n1 :: GHC.Internal.TypeNats.Nat). (GHC.Internal.TypeNats.KnownNat n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n0, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversion mode n0 n1) => Grisette.Internal.Unified.BVBVConversion.AllUnifiedBVBVConversion mode
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.BV.IntN Grisette.Internal.SymPrim.BV.IntN n0 n1 (Grisette.Internal.SymPrim.BV.IntN n0) (Grisette.Internal.SymPrim.BV.IntN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.BV.IntN Grisette.Internal.SymPrim.BV.WordN n0 n1 (Grisette.Internal.SymPrim.BV.IntN n0) (Grisette.Internal.SymPrim.BV.WordN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.BV.WordN Grisette.Internal.SymPrim.BV.IntN n0 n1 (Grisette.Internal.SymPrim.BV.WordN n0) (Grisette.Internal.SymPrim.BV.IntN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.C Grisette.Internal.SymPrim.BV.WordN Grisette.Internal.SymPrim.BV.WordN n0 n1 (Grisette.Internal.SymPrim.BV.WordN n0) (Grisette.Internal.SymPrim.BV.WordN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymBV.SymIntN Grisette.Internal.SymPrim.SymBV.SymIntN n0 n1 (Grisette.Internal.SymPrim.SymBV.SymIntN n0) (Grisette.Internal.SymPrim.SymBV.SymIntN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymBV.SymIntN Grisette.Internal.SymPrim.SymBV.SymWordN n0 n1 (Grisette.Internal.SymPrim.SymBV.SymIntN n0) (Grisette.Internal.SymPrim.SymBV.SymWordN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymBV.SymWordN Grisette.Internal.SymPrim.SymBV.SymIntN n0 n1 (Grisette.Internal.SymPrim.SymBV.SymWordN n0) (Grisette.Internal.SymPrim.SymBV.SymIntN n1)
instance (GHC.Internal.TypeNats.KnownNat n0, 1 GHC.Internal.Data.Type.Ord.<= n0, GHC.Internal.TypeNats.KnownNat n1, 1 GHC.Internal.Data.Type.Ord.<= n1) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl 'Grisette.Internal.Unified.EvalModeTag.S Grisette.Internal.SymPrim.SymBV.SymWordN Grisette.Internal.SymPrim.SymBV.SymWordN n0 n1 (Grisette.Internal.SymPrim.SymBV.SymWordN n0) (Grisette.Internal.SymPrim.SymBV.SymWordN n1)
instance (Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl mode (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode) n0 n1 (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode n0) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode n1), Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl mode (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode) n0 n1 (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode n0) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode n1), Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl mode (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode) n0 n1 (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode n0) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetWordN mode n1), Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversionImpl mode (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode) n0 n1 (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode n0) (Grisette.Internal.Internal.Decl.Unified.UnifiedBV.GetIntN mode n1)) => Grisette.Internal.Unified.BVBVConversion.UnifiedBVBVConversion mode n0 n1


module Grisette.Internal.Unified.BVFPConversion

-- | Unified constraints for conversion from bit-vectors to floating point
--   numbers.
class UnifiedBVFPConversionImpl mode GetWordN mode GetIntN mode GetFP mode n eb sb GetWordN mode n GetIntN mode n GetFP mode eb sb GetFPRoundingMode mode => UnifiedBVFPConversion (mode :: EvalModeTag) (n :: Nat) (eb :: Nat) (sb :: Nat)

-- | Unified constraints for safe conversion from bit-vectors to floating
--   point numbers.
class SafeUnifiedBVFPConversionImpl mode GetWordN mode GetIntN mode GetFP mode n eb sb GetWordN mode n GetIntN mode n GetFP mode eb sb GetFPRoundingMode mode m => SafeUnifiedBVFPConversion (mode :: EvalModeTag) (n :: Nat) (eb :: Nat) (sb :: Nat) (m :: Type -> Type)

-- | Evaluation mode with unified conversion from bit-vectors to
--   floating-points.
class (forall (n :: Nat) (eb :: Nat) (sb :: Nat). (ValidFP eb sb, KnownNat n, 1 <= n, n ~ eb + sb) => UnifiedBVFPConversion mode n eb sb, forall (n :: Nat) (eb :: Nat) (sb :: Nat) (m :: Type -> Type). (UnifiedBranching mode m, ValidFP eb sb, KnownNat n, 1 <= n, n ~ eb + sb, MonadError NotRepresentableFPError m) => SafeUnifiedBVFPConversion mode n eb sb m) => AllUnifiedBVFPConversion (mode :: EvalModeTag)


module Grisette.Internal.Unified.EvalMode

-- | Provide the constraint that the mode is a valid evaluation mode, and
--   provides the support for <a>GetBool</a> and <a>GetData</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
class (DecideEvalMode mode, UnifiedBool mode, UnifiedBasicPrim mode GetBool mode, AllUnifiedData mode, UnifiedDataBase mode) => EvalModeBase (mode :: EvalModeTag)

-- | Provide the support for <a>GetInteger</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
type EvalModeInteger = UnifiedInteger

-- | Provide the support for <a>GetIntN</a>, <a>GetWordN</a>,
--   <a>GetSomeIntN</a>, and <a>GetSomeWordN</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
class (AllUnifiedBV mode, AllUnifiedBVBVConversion mode) => EvalModeBV (mode :: EvalModeTag)

-- | Provide the support for <a>GetFP</a> and <a>GetFPRoundingMode</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
class (AllUnifiedFP mode, AllUnifiedFPFPConversion mode, AllUnifiedBVFPConversion mode) => EvalModeFP (mode :: EvalModeTag)

-- | Provide the support for <a>GetAlgReal</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
type EvalModeAlgReal = UnifiedAlgReal

-- | A constraint that specifies that the mode is valid, and provide all
--   the corresponding constraints for the operaions for the types.
--   
--   Note for users with GHC prior to 9.2.1: the GHC compiler isn't able to
--   resolve the operations for sized bitvectors and data types. In this
--   case, you may need to provide <a>UnifiedBV</a>, <a>SafeUnifiedBV</a>,
--   <a>SafeUnifiedSomeBV</a>, and <a>UnifiedData</a> constraints manually.
--   
--   For example, the following code is valid for GHC 9.2.1 and later:
--   
--   <pre>
--   fbv ::
--     forall mode n.
--     (EvalMode mode, KnownNat n, 1 &lt;= n) =&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n
--   fbv l r =
--     mrgIte @mode
--       (l .== r)
--       (l + r)
--       (symIte @mode (l .&lt; r) l r)
--   </pre>
--   
--   But with older GHCs, you need to write:
--   
--   <pre>
--   fbv ::
--     forall mode n.
--     (EvalMode mode, KnownNat n, 1 &lt;= n, UnifiedBV mode n) =&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n
--   fbv l r =
--     mrgIte @mode
--       (l .== r)
--       (l + r)
--       (symIte @mode (l .&lt; r) l r)
--   </pre>
class (EvalModeBase mode, EvalModeInteger mode, EvalModeAlgReal mode, EvalModeBV mode, EvalModeFP mode) => EvalModeAll (mode :: EvalModeTag)

-- | A constraint that specifies that the mode is valid, and provide all
--   the corresponding constraints for the operations for the types.
--   
--   This also provide the branching constraints for the monad, and the
--   safe operations: for example, <a>SafeUnifiedInteger</a> provides
--   <a>safeDiv</a> for the integer type with in <tt>ExceptT ArithException
--   m</tt>.
--   
--   For users with GHC prior to 9.2.1, see notes in <a>EvalModeAll</a>.
type MonadEvalModeAll (mode :: EvalModeTag) (m :: Type -> Type) = (EvalModeAll mode, Monad m, TryMerge m, UnifiedBranching mode m)

-- | This template haskell function generates an EvalMode constraint on
--   demand.
--   
--   For example, if in your system, you are only working on bit-vectors
--   and booleans, but not floating points, integers, or real numbers, you
--   can use this function to generate a constraint that only includes the
--   necessary constraints:
--   
--   <pre>
--   genEvalMode "MyEvalMode" [UWordN, UIntN, UBool]
--   f :: MyEvalMode mode =&gt; GetBool mode -&gt; GetWordN mode 8 -&gt; GetWordN mode 8
--   f = ...
--   </pre>
--   
--   This may help with faster compilation times.
--   
--   Another usage of this custom constraint is to working with
--   uninterpreted functions. The uninterpreted functions aren't available
--   even with <a>EvalModeAll</a>, and is only available with the
--   constraint generated by this function. Note that you need to
--   explicitly list all the uninterpreted function types you need in your
--   system.
--   
--   <pre>
--   genEvalMode "MyEvalModeUF" [UFun [UWordN, UIntN], UFun [UBool, UBool, UWordN]]
--   </pre>
--   
--   This will give us a constraint that allows us to work with booleans
--   and bit-vectors, and also the uninterpreted functions that
--   
--   <ul>
--   <li>maps an unsigned bit-vector (any bitwidth) to an unsigned integer
--   (any bitwidth), and</li>
--   <li>maps two booleans to an unsigned bit-vector (any bitwidth).</li>
--   </ul>
--   
--   You can then use them in your code like this:
--   
--   <pre>
--   f :: MyEvalModeUF mode =&gt; GetFun mode (GetWordN mode 8) (GetIntN mode 8) -&gt; GetIntN mode 8
--   f fun = f # 1
--   </pre>
--   
--   The function will also provide the constraint
--   <tt>MonadMyEvalModeUF</tt>, which includes the constraints for the
--   monad and the unified branching, similar to <a>MonadEvalModeAll</a>.
--   
--   For compilers older than GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>. This function will also generate constraints like
--   <tt>MyEvalModeUFFunUWordNUIntN</tt>, which can be used to resolve the
--   constraints for older compilers.
--   
--   The naming conversion is the concatenation of the three parts:
--   
--   <ul>
--   <li>The base name provided by the user (i.e.,
--   <tt>MyEvalModeUF</tt>),</li>
--   <li><tt>Fun</tt>,</li>
--   <li>The concatenation of all the types in the uninterpreted function
--   (i.e., <tt>UWordNUIntN</tt>).</li>
--   </ul>
--   
--   The arguments to the type class is as follows:
--   
--   <ul>
--   <li>The first argument is the mode,</li>
--   <li>The second to the end arguments are the natural number arguments
--   for all the types. Here the second argument is the bitwidth of the
--   unsigned bit-vector argument, and the third argument is the bitwidth
--   of the signed bit-vector result.</li>
--   </ul>
genEvalMode :: String -> [TheoryToUnify] -> DecsQ


module Grisette.Unified

-- | Evaluation mode for unified types. <a>C</a> means concrete evaluation,
--   <a>S</a> means symbolic evaluation.
data EvalModeTag
C :: EvalModeTag
S :: EvalModeTag

-- | Type family to check if a mode is <a>C</a>.
type family IsConMode (mode :: EvalModeTag) = (r :: Bool) | r -> mode

-- | A type family that specifies the base monad for the evaluation mode.
--   
--   Resolves to <a>Identity</a> for <a>C</a> mode, and <a>Union</a> for
--   <a>S</a> mode.
type BaseMonad (mode :: EvalModeTag) = GetData mode

-- | This template haskell function generates an EvalMode constraint on
--   demand.
--   
--   For example, if in your system, you are only working on bit-vectors
--   and booleans, but not floating points, integers, or real numbers, you
--   can use this function to generate a constraint that only includes the
--   necessary constraints:
--   
--   <pre>
--   genEvalMode "MyEvalMode" [UWordN, UIntN, UBool]
--   f :: MyEvalMode mode =&gt; GetBool mode -&gt; GetWordN mode 8 -&gt; GetWordN mode 8
--   f = ...
--   </pre>
--   
--   This may help with faster compilation times.
--   
--   Another usage of this custom constraint is to working with
--   uninterpreted functions. The uninterpreted functions aren't available
--   even with <a>EvalModeAll</a>, and is only available with the
--   constraint generated by this function. Note that you need to
--   explicitly list all the uninterpreted function types you need in your
--   system.
--   
--   <pre>
--   genEvalMode "MyEvalModeUF" [UFun [UWordN, UIntN], UFun [UBool, UBool, UWordN]]
--   </pre>
--   
--   This will give us a constraint that allows us to work with booleans
--   and bit-vectors, and also the uninterpreted functions that
--   
--   <ul>
--   <li>maps an unsigned bit-vector (any bitwidth) to an unsigned integer
--   (any bitwidth), and</li>
--   <li>maps two booleans to an unsigned bit-vector (any bitwidth).</li>
--   </ul>
--   
--   You can then use them in your code like this:
--   
--   <pre>
--   f :: MyEvalModeUF mode =&gt; GetFun mode (GetWordN mode 8) (GetIntN mode 8) -&gt; GetIntN mode 8
--   f fun = f # 1
--   </pre>
--   
--   The function will also provide the constraint
--   <tt>MonadMyEvalModeUF</tt>, which includes the constraints for the
--   monad and the unified branching, similar to <a>MonadEvalModeAll</a>.
--   
--   For compilers older than GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>. This function will also generate constraints like
--   <tt>MyEvalModeUFFunUWordNUIntN</tt>, which can be used to resolve the
--   constraints for older compilers.
--   
--   The naming conversion is the concatenation of the three parts:
--   
--   <ul>
--   <li>The base name provided by the user (i.e.,
--   <tt>MyEvalModeUF</tt>),</li>
--   <li><tt>Fun</tt>,</li>
--   <li>The concatenation of all the types in the uninterpreted function
--   (i.e., <tt>UWordNUIntN</tt>).</li>
--   </ul>
--   
--   The arguments to the type class is as follows:
--   
--   <ul>
--   <li>The first argument is the mode,</li>
--   <li>The second to the end arguments are the natural number arguments
--   for all the types. Here the second argument is the bitwidth of the
--   unsigned bit-vector argument, and the third argument is the bitwidth
--   of the signed bit-vector result.</li>
--   </ul>
genEvalMode :: String -> [TheoryToUnify] -> DecsQ

-- | This data type is used to represent the theories that is unified.
--   
--   The <a>UFun</a> constructor is used to represent a specific
--   uninterpreted function type. The type is uncurried.
data TheoryToUnify
UBool :: TheoryToUnify
UIntN :: TheoryToUnify
UWordN :: TheoryToUnify
UInteger :: TheoryToUnify
UAlgReal :: TheoryToUnify
UFP :: TheoryToUnify
UFun :: [TheoryToUnify] -> TheoryToUnify

-- | Provide the constraint that the mode is a valid evaluation mode, and
--   provides the support for <a>GetBool</a> and <a>GetData</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
class (DecideEvalMode mode, UnifiedBool mode, UnifiedBasicPrim mode GetBool mode, AllUnifiedData mode, UnifiedDataBase mode) => EvalModeBase (mode :: EvalModeTag)

-- | Provide the support for <a>GetInteger</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
type EvalModeInteger = UnifiedInteger

-- | Provide the support for <a>GetIntN</a>, <a>GetWordN</a>,
--   <a>GetSomeIntN</a>, and <a>GetSomeWordN</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
class (AllUnifiedBV mode, AllUnifiedBVBVConversion mode) => EvalModeBV (mode :: EvalModeTag)

-- | Provide the support for <a>GetFP</a> and <a>GetFPRoundingMode</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
class (AllUnifiedFP mode, AllUnifiedFPFPConversion mode, AllUnifiedBVFPConversion mode) => EvalModeFP (mode :: EvalModeTag)

-- | Provide the support for <a>GetAlgReal</a>.
--   
--   For compilers prior to GHC 9.2.1, see the notes for
--   <a>EvalModeAll</a>.
type EvalModeAlgReal = UnifiedAlgReal

-- | A constraint that specifies that the mode is valid, and provide all
--   the corresponding constraints for the operaions for the types.
--   
--   Note for users with GHC prior to 9.2.1: the GHC compiler isn't able to
--   resolve the operations for sized bitvectors and data types. In this
--   case, you may need to provide <a>UnifiedBV</a>, <a>SafeUnifiedBV</a>,
--   <a>SafeUnifiedSomeBV</a>, and <a>UnifiedData</a> constraints manually.
--   
--   For example, the following code is valid for GHC 9.2.1 and later:
--   
--   <pre>
--   fbv ::
--     forall mode n.
--     (EvalMode mode, KnownNat n, 1 &lt;= n) =&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n
--   fbv l r =
--     mrgIte @mode
--       (l .== r)
--       (l + r)
--       (symIte @mode (l .&lt; r) l r)
--   </pre>
--   
--   But with older GHCs, you need to write:
--   
--   <pre>
--   fbv ::
--     forall mode n.
--     (EvalMode mode, KnownNat n, 1 &lt;= n, UnifiedBV mode n) =&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n -&gt;
--     GetIntN mode n
--   fbv l r =
--     mrgIte @mode
--       (l .== r)
--       (l + r)
--       (symIte @mode (l .&lt; r) l r)
--   </pre>
class (EvalModeBase mode, EvalModeInteger mode, EvalModeAlgReal mode, EvalModeBV mode, EvalModeFP mode) => EvalModeAll (mode :: EvalModeTag)

-- | A constraint that specifies that the mode is valid, and provide all
--   the corresponding constraints for the operations for the types.
--   
--   This also provide the branching constraints for the monad, and the
--   safe operations: for example, <a>SafeUnifiedInteger</a> provides
--   <a>safeDiv</a> for the integer type with in <tt>ExceptT ArithException
--   m</tt>.
--   
--   For users with GHC prior to 9.2.1, see notes in <a>EvalModeAll</a>.
type MonadEvalModeAll (mode :: EvalModeTag) (m :: Type -> Type) = (EvalModeAll mode, Monad m, TryMerge m, UnifiedBranching mode m)

-- | A class that provides the mode tag at runtime.
class DecideEvalMode (mode :: EvalModeTag)
decideEvalMode :: DecideEvalMode mode => EvalModeTag

-- | Case analysis on the mode.
withMode :: forall (mode :: EvalModeTag) r. DecideEvalMode mode => (mode ~ 'C => r) -> (mode ~ 'S => r) -> r

-- | A class saying that we can convert a value with one mode to another
--   mode.
--   
--   Allowed conversions:
--   
--   <ul>
--   <li><a>C</a> <a>-</a> <a>C</a></li>
--   <li><a>S</a> <a>-</a> <a>S</a></li>
--   <li><a>C</a> <a>-</a> <a>S</a></li>
--   </ul>
--   
--   Conversion from left to right uses <a>ToSym</a> class, and conversion
--   from right to left uses <a>ToCon</a> class.
class (DecideEvalMode c, DecideEvalMode s) => EvalModeConvertible (c :: EvalModeTag) (s :: EvalModeTag)
withModeConvertible :: EvalModeConvertible c s => (c ~ 'C => r) -> (s ~ 'S => r) -> r
withModeConvertible' :: EvalModeConvertible c s => ((c ~ 'C, s ~ 'C) => r) -> ((c ~ 'C, s ~ 'S) => r) -> ((c ~ 'S, s ~ 'S) => r) -> r

-- | A class that provides a unified branching operation.
--   
--   We use this type class to help resolve the constraints for
--   <a>SymBranching</a>.
class (DecideEvalMode mode, TryMerge m) => UnifiedBranching (mode :: EvalModeTag) (m :: Type -> Type)
withBaseBranching :: UnifiedBranching mode m => (If (IsConMode mode) (TryMerge m) (SymBranching m) => r) -> r

-- | A class that provides a unified simple merging.
--   
--   We use this type class to help resolve the constraints for
--   <a>SimpleMergeable</a>.
class (DecideEvalMode mode, Mergeable a) => UnifiedSimpleMergeable (mode :: EvalModeTag) a
withBaseSimpleMergeable :: UnifiedSimpleMergeable mode a => (If (IsConMode mode) () (SimpleMergeable a) => r) -> r

-- | A class that provides lifting of unified simple merging.
--   
--   We use this type class to help resolve the constraints for
--   <a>SimpleMergeable1</a>.
class DecideEvalMode mode => UnifiedSimpleMergeable1 (mode :: EvalModeTag) (f :: Type -> Type)
withBaseSimpleMergeable1 :: UnifiedSimpleMergeable1 mode f => (If (IsConMode mode) () (SimpleMergeable1 f) => r) -> r

-- | A class that provides lifting of unified simple merging.
--   
--   We use this type class to help resolve the constraints for
--   <a>SimpleMergeable2</a>.
class DecideEvalMode mode => UnifiedSimpleMergeable2 (mode :: EvalModeTag) (f :: Type -> Type -> Type)
withBaseSimpleMergeable2 :: UnifiedSimpleMergeable2 mode f => (If (IsConMode mode) () (SimpleMergeable2 f) => r) -> r

-- | Unified <a>mrgIf</a>.
--   
--   This function isn't able to infer the mode of the boolean variable, so
--   you need to provide the mode explicitly. For example:
--   
--   <pre>
--   mrgIf @mode (a .== b) ...
--   mrgIf (a .== b :: SymBool) ...
--   mrgIf (a .== b :: GetBool mode) ...
--   </pre>
mrgIf :: forall (mode :: EvalModeTag) a m. (DecideEvalMode mode, Mergeable a, UnifiedBranching mode m) => GetBool mode -> m a -> m a -> m a

-- | Unified lifting of a base monad.
liftUnion :: forall (mode :: EvalModeTag) a m u. (Applicative m, UnifiedBranching mode m, Mergeable a, UnionView u, UnionViewMode mode u) => u a -> m a

-- | Unified <a>mrgIte</a>.
mrgIte :: forall (mode :: EvalModeTag) a. UnifiedSimpleMergeable mode a => GetBool mode -> a -> a -> a

-- | Unified <a>mrgIte1</a>.
mrgIte1 :: forall (mode :: EvalModeTag) f a. (UnifiedSimpleMergeable1 mode f, UnifiedSimpleMergeable mode a) => GetBool mode -> f a -> f a -> f a

-- | Unified <a>liftMrgIte</a>.
liftMrgIte :: forall (mode :: EvalModeTag) f a. UnifiedSimpleMergeable1 mode f => (GetBool mode -> a -> a -> a) -> GetBool mode -> f a -> f a -> f a

-- | Unified <a>mrgIte2</a>.
mrgIte2 :: forall (mode :: EvalModeTag) f a b. (UnifiedSimpleMergeable2 mode f, UnifiedSimpleMergeable mode a, UnifiedSimpleMergeable mode b) => GetBool mode -> f a b -> f a b -> f a b

-- | Unified <a>liftMrgIte2</a>.
liftMrgIte2 :: forall (mode :: EvalModeTag) f a b. UnifiedSimpleMergeable2 mode f => (GetBool mode -> a -> a -> a) -> (GetBool mode -> b -> b -> b) -> GetBool mode -> f a b -> f a b -> f a b

-- | Unified merge of simply mergeable values in the base monad.
simpleMerge :: forall (mode :: EvalModeTag) a u. (UnifiedSimpleMergeable mode a, UnionView u, UnionViewMode mode u) => u a -> a
(.#) :: forall f a r (mode :: EvalModeTag) u. (Function f a r, UnifiedSimpleMergeable mode r, UnionView u, UnionViewMode mode u) => f -> u a -> r
infixl 9 .#
onUnion :: forall (mode :: EvalModeTag) r u a. (UnifiedSimpleMergeable mode r, UnifiedBranching mode u, Mergeable a, UnionView u, UnionViewMode mode u) => (a -> r) -> u a -> r
onUnion2 :: forall (mode :: EvalModeTag) r u a b. (UnifiedSimpleMergeable mode r, UnifiedBranching mode u, Mergeable a, Mergeable b, UnionView u, UnionViewMode mode u) => (a -> b -> r) -> u a -> u b -> r
onUnion3 :: forall (mode :: EvalModeTag) r u a b c. (UnifiedSimpleMergeable mode r, UnifiedBranching mode u, Mergeable a, Mergeable b, Mergeable c, UnionView u, UnionViewMode mode u) => (a -> b -> c -> r) -> u a -> u b -> u c -> r
onUnion4 :: forall (mode :: EvalModeTag) r u a b c d. (UnifiedSimpleMergeable mode r, UnifiedBranching mode u, Mergeable a, Mergeable b, Mergeable c, Mergeable d, UnionView u, UnionViewMode mode u) => (a -> b -> c -> d -> r) -> u a -> u b -> u c -> u d -> r

-- | A class that provides unified equality comparison.
--   
--   We use this type class to help resolve the constraints for
--   <a>ITEOp</a>.
class UnifiedITEOp (mode :: EvalModeTag) v
withBaseITEOp :: UnifiedITEOp mode v => (If (IsConMode mode) () (ITEOp v) => r) -> r

-- | Unified <a>symIte</a> operation.
--   
--   This function isn't able to infer the mode of the boolean variable, so
--   you need to provide the mode explicitly. For example:
--   
--   <pre>
--   symIte @mode (a .== b) ...
--   symIte (a .== b :: SymBool) ...
--   symIte (a .== b :: GetBool mode) ...
--   </pre>
symIte :: forall (mode :: EvalModeTag) v. (DecideEvalMode mode, UnifiedITEOp mode v) => GetBool mode -> v -> v -> v

-- | Unified <a>symIteMerge</a> operation.
--   
--   This function isn't able to infer the mode of the base monad from the
--   result, so you need to provide the mode explicitly. For example:
--   
--   <pre>
--   symIteMerge @mode ...
--   symIteMerge (... :: GetData mode v) ...
--   </pre>
symIteMerge :: forall (mode :: EvalModeTag) u v. (DecideEvalMode mode, UnifiedITEOp mode v, Mergeable v, UnionViewMode mode u, UnionView u) => u v -> v

-- | A class that provides unified equality comparison.
--   
--   We use this type class to help resolve the constraints for <a>Eq</a>
--   and <a>SymEq</a>.
class UnifiedSymEq (mode :: EvalModeTag) a
withBaseSymEq :: UnifiedSymEq mode a => (If (IsConMode mode) (Eq a) (SymEq a) => r) -> r

-- | A class that provides unified lifting of equality comparison.
--   
--   We use this type class to help resolve the constraints for <a>Eq1</a>
--   and <a>SymEq1</a>.
class forall a. UnifiedSymEq mode a => UnifiedSymEq mode f a => UnifiedSymEq1 (mode :: EvalModeTag) (f :: Type -> Type)
withBaseSymEq1 :: UnifiedSymEq1 mode f => (If (IsConMode mode) (Eq1 f) (SymEq1 f) => r) -> r

-- | A class that provides unified lifting of equality comparison.
--   
--   We use this type class to help resolve the constraints for <a>Eq2</a>
--   and <a>SymEq2</a>.
class forall a. UnifiedSymEq mode a => UnifiedSymEq1 mode f a => UnifiedSymEq2 (mode :: EvalModeTag) (f :: Type -> Type -> Type)
withBaseSymEq2 :: UnifiedSymEq2 mode f => (If (IsConMode mode) (Eq2 f) (SymEq2 f) => r) -> r

-- | Unified <a>(.==)</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   a .== b :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
(.==) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymEq mode a) => a -> a -> GetBool mode
infix 4 .==

-- | Unified <a>(./=)</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   a ./= b :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
(./=) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymEq mode a) => a -> a -> GetBool mode
infix 4 ./=

-- | Unified <a>symDistinct</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   symDistinct l :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
symDistinct :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymEq mode a) => [a] -> GetBool mode

-- | Unified <a>liftSymEq</a>.
liftSymEq :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymEq1 mode f) => (a -> b -> GetBool mode) -> f a -> f b -> GetBool mode

-- | Unified <a>symEq1</a>.
symEq1 :: forall (mode :: EvalModeTag) f a. (DecideEvalMode mode, UnifiedSymEq mode a, UnifiedSymEq1 mode f) => f a -> f a -> GetBool mode

-- | Unified <a>liftSymEq2</a>.
liftSymEq2 :: forall (mode :: EvalModeTag) f a b c d. (DecideEvalMode mode, UnifiedSymEq2 mode f) => (a -> b -> GetBool mode) -> (c -> d -> GetBool mode) -> f a c -> f b d -> GetBool mode

-- | Unified <a>symEq2</a>.
symEq2 :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymEq mode a, UnifiedSymEq mode b, UnifiedSymEq2 mode f) => f a b -> f a b -> GetBool mode

-- | A class that provides unified comparison.
--   
--   We use this type class to help resolve the constraints for <a>Ord</a>
--   and <a>SymOrd</a>.
class UnifiedSymOrd (mode :: EvalModeTag) a
withBaseSymOrd :: UnifiedSymOrd mode a => (If (IsConMode mode) (Ord a) (SymOrd a) => r) -> r

-- | A class that provides unified lifting of comparison.
--   
--   We use this type class to help resolve the constraints for <a>Ord1</a>
--   and <a>SymOrd1</a>.
class UnifiedSymOrd1 (mode :: EvalModeTag) (f :: Type -> Type)
withBaseSymOrd1 :: UnifiedSymOrd1 mode f => (If (IsConMode mode) (Ord1 f) (SymOrd1 f) => r) -> r

-- | A class that provides unified lifting of comparison.
--   
--   We use this type class to help resolve the constraints for <a>Ord2</a>
--   and <a>SymOrd2</a>.
class UnifiedSymOrd2 (mode :: EvalModeTag) (f :: Type -> Type -> Type)
withBaseSymOrd2 :: UnifiedSymOrd2 mode f => (If (IsConMode mode) (Ord2 f) (SymOrd2 f) => r) -> r

-- | Unified <a>(.&lt;=)</a>.
--   
--   Note that you may sometimes need to write type annotations for the
--   result when the mode isn't clear:
--   
--   <pre>
--   a .&lt;= b :: GetBool mode
--   </pre>
--   
--   One example when it isn't clear is when this is used in unified
--   <a>mrgIf</a>.
(.<=) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .<=

-- | Unified <a>(.&lt;)</a>.
(.<) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .<

-- | Unified <a>(.&gt;=)</a>.
(.>=) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .>=

-- | Unified <a>(.&gt;)</a>.
(.>) :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetBool mode
infix 4 .>

-- | Unified <a>symCompare</a>.
symCompare :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedSymOrd mode a) => a -> a -> GetData mode Ordering

-- | Unified <a>liftSymCompare</a>.
liftSymCompare :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymOrd1 mode f) => (a -> b -> GetData mode Ordering) -> f a -> f b -> GetData mode Ordering

-- | Unified <a>symCompare1</a>.
symCompare1 :: forall (mode :: EvalModeTag) f a. (DecideEvalMode mode, UnifiedSymOrd mode a, UnifiedSymOrd1 mode f) => f a -> f a -> GetData mode Ordering

-- | Unified <a>liftSymCompare2</a>.
liftSymCompare2 :: forall (mode :: EvalModeTag) f a b c d. (DecideEvalMode mode, UnifiedSymOrd2 mode f) => (a -> b -> GetData mode Ordering) -> (c -> d -> GetData mode Ordering) -> f a c -> f b d -> GetData mode Ordering

-- | Unified <a>symCompare2</a>.
symCompare2 :: forall (mode :: EvalModeTag) f a b. (DecideEvalMode mode, UnifiedSymOrd mode a, UnifiedSymOrd mode b, UnifiedSymOrd2 mode f) => f a b -> f a b -> GetData mode Ordering

-- | Unified <a>symMax</a>.
symMax :: forall (mode :: EvalModeTag) a. (UnifiedSymOrd mode a, UnifiedITEOp mode a, DecideEvalMode mode) => a -> a -> a

-- | Unified <a>symMin</a>.
symMin :: forall (mode :: EvalModeTag) a. (UnifiedSymOrd mode a, UnifiedITEOp mode a, DecideEvalMode mode) => a -> a -> a

-- | Unified <a>mrgMax</a>.
mrgMax :: forall (mode :: EvalModeTag) a m. (UnifiedSymOrd mode a, UnifiedBranching mode m, DecideEvalMode mode, Applicative m, Mergeable a) => a -> a -> m a

-- | Unified <a>mrgMin</a>.
mrgMin :: forall (mode :: EvalModeTag) a m. (UnifiedSymOrd mode a, UnifiedBranching mode m, DecideEvalMode mode, Applicative m, Mergeable a) => a -> a -> m a

-- | A class that provides unified equality comparison.
--   
--   We use this type class to help resolve the constraints for
--   <a>FiniteBits</a>, <a>FromBits</a> and <a>SymFiniteBits</a>.
class UnifiedFiniteBits (mode :: EvalModeTag) a
withBaseFiniteBits :: UnifiedFiniteBits mode a => (If (IsConMode mode) (FiniteBits a, FromBits a) (SymFiniteBits a) => r) -> r

-- | Unified <a>symTestBit</a>.
symTestBit :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> Int -> GetBool mode

-- | Unified <a>symSetBitTo</a>.
symSetBitTo :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> Int -> GetBool mode -> a

-- | Unified <a>symFromBits</a>.
symFromBits :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => [GetBool mode] -> a

-- | Unified <a>symBitBlast</a>.
symBitBlast :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> [GetBool mode]

-- | Unified <a>symLsb</a>.
symLsb :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> GetBool mode

-- | Unified <a>symMsb</a>.
symMsb :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a) => a -> GetBool mode

-- | Unified <a>symPopCount</a>.
symPopCount :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a, Num a, UnifiedITEOp mode a) => a -> a

-- | Unified <a>symCountLeadingZeros</a>.
symCountLeadingZeros :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a, Num a, UnifiedITEOp mode a) => a -> a

-- | Unified <a>symCountTrailingZeros</a>.
symCountTrailingZeros :: forall (mode :: EvalModeTag) a. (DecideEvalMode mode, UnifiedFiniteBits mode a, Num a, UnifiedITEOp mode a) => a -> a

-- | A class that provides unified conversion from integral types.
--   
--   We use this type class to help resolve the constraints for
--   <a>SymFromIntegral</a>.
class UnifiedFromIntegral (mode :: EvalModeTag) a b
withBaseFromIntegral :: UnifiedFromIntegral mode a b => (If (IsConMode mode) (Integral a, Num b) (SymFromIntegral a b) => r) -> r

-- | Unified <a>symFromIntegral</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   symFromIntegral @mode a
--   </pre>
symFromIntegral :: forall (mode :: EvalModeTag) a b. (DecideEvalMode mode, UnifiedFromIntegral mode a b) => a -> b

-- | A class that provides unified safe bitcast operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeBitCast</a>.
class UnifiedSafeBitCast (mode :: EvalModeTag) e a b (m :: Type -> Type)
withBaseSafeBitCast :: UnifiedSafeBitCast mode e a b m => (SafeBitCast e a b m => r) -> r

-- | Unified <a>safeSub</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSub @mode a b
--   </pre>
safeBitCast :: forall (mode :: EvalModeTag) e a b m. (MonadError e m, UnifiedSafeBitCast mode e a b m) => a -> m b

-- | A class that provides unified safe conversion from floating points.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeFromFP</a>.
class UnifiedSafeFromFP (mode :: EvalModeTag) e a fp fprd (m :: Type -> Type)
withBaseSafeFromFP :: UnifiedSafeFromFP mode e a fp fprd m => (SafeFromFP e a fp fprd m => r) -> r

-- | Unified <a>safeFromFP</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeFromFP @mode mode fp
--   </pre>
safeFromFP :: forall (mode :: EvalModeTag) e a fp fprd m. (UnifiedSafeFromFP mode e a fp fprd m, MonadError e m) => fprd -> fp -> m a

-- | A class that provides unified division operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeDiv</a>.
class UnifiedSafeDiv (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeDiv :: UnifiedSafeDiv mode e a m => (SafeDiv e a m => r) -> r

-- | Unified <a>safeDiv</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeDiv @mode a b
--   </pre>
safeDiv :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeMod</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeMod @mode a b
--   </pre>
safeMod :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeDivMod</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeDivMod @mode a b
--   </pre>
safeDivMod :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m (a, a)

-- | Unified <a>safeQuot</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeQuot @mode a b
--   </pre>
safeQuot :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeRem</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeRem @mode a b
--   </pre>
safeRem :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m a

-- | Unified <a>safeQuotRem</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeQuotRem @mode a b
--   </pre>
safeQuotRem :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeDiv mode e a m) => a -> a -> m (a, a)

-- | A class that provides unified linear arithmetic operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeLinearArith</a>.
class UnifiedSafeLinearArith (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeLinearArith :: UnifiedSafeLinearArith mode e a m => (SafeLinearArith e a m => r) -> r

-- | Unified <a>safeAdd</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeAdd @mode a b
--   </pre>
safeAdd :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeLinearArith mode e a m) => a -> a -> m a

-- | Unified <a>safeNeg</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeNeg @mode a
--   </pre>
safeNeg :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeLinearArith mode e a m) => a -> m a

-- | Unified <a>safeSub</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSub @mode a b
--   </pre>
safeSub :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeLinearArith mode e a m) => a -> a -> m a

-- | A class that provides unified safe symbolic rotation operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeSymRotate</a>.
class UnifiedSafeSymRotate (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeSymRotate :: UnifiedSafeSymRotate mode e a m => (SafeSymRotate e a m => r) -> r

-- | Unified <a>safeSymRotateL</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymRotateL @mode a b
--   </pre>
safeSymRotateL :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymRotate mode e a m) => a -> a -> m a

-- | Unified <a>safeSymRotateR</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymRotateR @mode a b
--   </pre>
safeSymRotateR :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymRotate mode e a m) => a -> a -> m a

-- | A class that provides unified safe symbolic rotation operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeSymShift</a>.
class UnifiedSafeSymShift (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseSafeSymShift :: UnifiedSafeSymShift mode e a m => (SafeSymShift e a m => r) -> r

-- | Unified <a>safeSymShiftL</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymShiftL @mode a b
--   </pre>
safeSymShiftL :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | Unified <a>safeSymShiftR</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymShiftR @mode a b
--   </pre>
safeSymShiftR :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | Unified <a>safeSymStrictShiftL</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymStrictShiftL @mode a b
--   </pre>
safeSymStrictShiftL :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | Unified <a>safeSymStrictShiftR</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeSymStrictShiftR @mode a b
--   </pre>
safeSymStrictShiftR :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeSymShift mode e a m) => a -> a -> m a

-- | A class that provides unified floating division operations.
--   
--   We use this type class to help resolve the constraints for
--   <a>SafeFdiv</a>.
class UnifiedSafeFdiv (mode :: EvalModeTag) e a (m :: Type -> Type)
withBaseUnifiedSafeFdiv :: UnifiedSafeFdiv mode e a m => (SafeFdiv e a m => r) -> r

-- | Unified <a>safeFdiv</a> operation.
--   
--   This function isn't able to infer the mode, so you need to provide the
--   mode explicitly. For example:
--   
--   <pre>
--   safeFdiv @mode a b
--   </pre>
safeFdiv :: forall (mode :: EvalModeTag) e a m. (MonadError e m, UnifiedSafeFdiv mode e a m) => a -> a -> m a

-- | A type that is used as a constraint for all the (unified) primitive
--   types in Grisette.
type UnifiedPrim (mode :: EvalModeTag) a = (Prim a, UnifiedITEOp mode a, UnifiedSymEq mode a, UnifiedSymOrd mode a)

-- | A type that is used as a constraint for all the basic (unified)
--   primitive types in Grisette.
--   
--   <a>GetSomeWordN</a> is not considered as a basic (unified) primitive
--   type.
type UnifiedBasicPrim (mode :: EvalModeTag) a = (UnifiedPrim mode a, UnifiedSimpleMergeable mode a, UnifiedConRep a, UnifiedSymRep a, UnifiedSolvable mode a ConType a, ConSymConversion ConType a SymType a a)

-- | Get a unified Boolean type. Resolves to <a>Bool</a> in <a>C</a> mode,
--   and <a>SymBool</a> in <a>S</a> mode.
type family GetBool (mode :: EvalModeTag) = (bool :: Type) | bool -> mode

-- | Get a unified signed size-tagged bit vector type. Resolves to
--   <a>IntN</a> in <a>C</a> mode, and <a>SymIntN</a> in <a>S</a> mode.
type family GetIntN (mode :: EvalModeTag) = (i :: Nat -> Type) | i -> mode

-- | Get a unified unsigned size-tagged bit vector type. Resolves to
--   <a>WordN</a> in <a>C</a> mode, and <a>SymWordN</a> in <a>S</a> mode.
type family GetWordN (mode :: EvalModeTag) = (w :: Nat -> Type) | w -> mode

-- | Get a unified unsigned dynamic bit width bit vector type. Resolves to
--   <a>SomeWordN</a> in <a>C</a> mode, and <a>SomeSymWordN</a> in <a>S</a>
--   mode.
type family GetSomeWordN (mode :: EvalModeTag) = (sw :: Type) | sw -> mode

-- | Get a unified signed dynamic bit width bit vector type. Resolves to
--   <a>SomeIntN</a> in <a>C</a> mode, and <a>SomeSymIntN</a> in <a>S</a>
--   mode.
type family GetSomeIntN (mode :: EvalModeTag) = (sw :: Type) | sw -> mode

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class UnifiedBVImpl mode GetWordN mode GetIntN mode n GetWordN mode n GetIntN mode n => UnifiedBV (mode :: EvalModeTag) (n :: Nat)

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class SafeUnifiedBVImpl mode GetWordN mode GetIntN mode n GetWordN mode n GetIntN mode n m => SafeUnifiedBV (mode :: EvalModeTag) (n :: Nat) (m :: Type -> Type)

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class SafeUnifiedSomeBVImpl mode SomeBV GetWordN mode SomeBV GetIntN mode m => SafeUnifiedSomeBV (mode :: EvalModeTag) (m :: Type -> Type)

-- | Get a unified Integer type. Resolves to <a>Integer</a> in <a>C</a>
--   mode, and <a>SymInteger</a> in <a>S</a> mode.
type family GetInteger (mode :: EvalModeTag) = (int :: Type) | int -> mode

-- | Evaluation mode with unified <a>Integer</a> type.
class UnifiedIntegerImpl mode GetInteger mode => UnifiedInteger (mode :: EvalModeTag)

-- | Get a unified floating point type. Resolves to <a>FP</a> in <a>C</a>
--   mode, and <a>SymFP</a> in <a>S</a> mode.
type family GetFP (mode :: EvalModeTag) = (f :: Nat -> Nat -> Type) | f -> mode

-- | Get a unified floating point rounding mode type. Resolves to
--   <a>FPRoundingMode</a> in <a>C</a> mode, and <a>SymFPRoundingMode</a>
--   in <a>S</a> mode.
type family GetFPRoundingMode (mode :: EvalModeTag) = (r :: Type) | r -> mode

-- | Evaluation mode with unified <a>FP</a> type.
class UnifiedFPImpl mode GetFP mode eb sb GetFP mode eb sb GetFPRoundingMode mode => UnifiedFP (mode :: EvalModeTag) (eb :: Nat) (sb :: Nat)

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>EvalMode</a>.
class (SafeUnifiedFPImpl mode GetFP mode eb sb GetFP mode eb sb GetFPRoundingMode mode m, UnifiedSafeFromFP mode NotRepresentableFPError GetInteger mode GetFP mode eb sb GetFPRoundingMode mode m) => SafeUnifiedFP (mode :: EvalModeTag) (eb :: Nat) (sb :: Nat) (m :: Type -> Type)

-- | Get a unified algebraic real type. Resolves to <a>AlgReal</a> in
--   <a>C</a> mode, and <a>SymAlgReal</a> in <a>S</a> mode.
--   
--   <a>Floating</a>, <a>LogBaseOr</a> and <a>SafeLogBase</a> for
--   <a>SymAlgReal</a> are not provided as they are not available for
--   <a>AlgReal</a>.
type family GetAlgReal (mode :: EvalModeTag) = (real :: Type) | real -> mode

-- | Evaluation mode with unified <a>AlgReal</a> type.
class UnifiedAlgRealImpl mode GetAlgReal mode => UnifiedAlgReal (mode :: EvalModeTag)

-- | Get a unified data type. Resolves to <a>Identity</a> in <a>C</a> mode,
--   and <a>Union</a> in <a>S</a> mode.
type family GetData (mode :: EvalModeTag) = (r :: Type -> Type) | r -> mode

-- | This class is needed as constraint in user code prior to GHC 9.2.1.
--   See the notes in <a>IsMode</a>.
class UnifiedDataImpl mode v GetData mode v => UnifiedData (mode :: EvalModeTag) v

-- | Extracts a value from the unified data type.
extractData :: (UnifiedDataImpl mode v u, Mergeable v, Monad m, UnifiedBranching mode m) => u -> m v

-- | Wraps a value into the unified data type.
wrapData :: UnifiedDataImpl mode v u => v -> u

-- | Get a unified function type. Resolves to <a>=-&gt;</a> in <a>C</a>
--   mode, and <a>=~&gt;</a> in <a>S</a> mode.
type family GetFun (mode :: EvalModeTag) = (fun :: Type -> Type -> Type) | fun -> mode

-- | The unified function type with 2 arguments.
type GetFun2 (mode :: EvalModeTag) a b = GetFun mode a b

-- | The unified function type with 3 arguments.
type GetFun3 (mode :: EvalModeTag) a b c = GetFun mode a GetFun mode b c

-- | The unified function type with 4 arguments.
type GetFun4 (mode :: EvalModeTag) a b c d = GetFun mode a GetFun mode b GetFun mode c d

-- | The unified function type with 5 arguments.
type GetFun5 (mode :: EvalModeTag) a b c d e = GetFun mode a GetFun mode b GetFun mode c GetFun mode d e

-- | The unified function type with 6 arguments.
type GetFun6 (mode :: EvalModeTag) a b c d e f = GetFun mode a GetFun mode b GetFun mode c GetFun mode d GetFun mode e f

-- | The unified function type with 7 arguments.
type GetFun7 (mode :: EvalModeTag) a b c d e f g = GetFun mode a GetFun mode b GetFun mode c GetFun mode d GetFun mode e GetFun mode f g

-- | The unified function type with 8 arguments.
type GetFun8 (mode :: EvalModeTag) a b c d e f g h = GetFun mode a GetFun mode b GetFun mode c GetFun mode d GetFun mode e GetFun mode f GetFun mode g h

-- | Provide unified function types.
class UnifiedFun (mode :: EvalModeTag)

-- | The constraint for a unified function.
type UnifiedFunConstraint (mode :: EvalModeTag) a b ca cb sa sb = (Show GetFun mode a b, Binary GetFun mode a b, Serial GetFun mode a b, Serialize GetFun mode a b, NFData GetFun mode a b, Eq GetFun mode a b, EvalSym GetFun mode a b, ExtractSym GetFun mode a b, Mergeable GetFun mode a b, PPrint GetFun mode a b, SubstSym GetFun mode a b, Lift GetFun mode a b, Typeable GetFun mode a b, ToCon GetFun mode a b ca =-> cb, ToCon sa =~> sb GetFun mode a b, ToSym GetFun mode a b sa =~> sb, ToSym ca =-> cb GetFun mode a b, Function GetFun mode a b a b, Apply GetFun mode a b, FunType GetFun mode a b ~ a -> b)

-- | Generate unified function instance names.
unifiedFunInstanceName :: String -> [TheoryToUnify] -> String

-- | Generate unified function instances.
genUnifiedFunInstance :: String -> [TheoryToUnify] -> DecsQ

-- | Unified constraints for conversion between bit-vectors.
class (UnifiedBVBVConversionImpl mode GetWordN mode GetWordN mode n0 n1 GetWordN mode n0 GetWordN mode n1, UnifiedBVBVConversionImpl mode GetWordN mode GetIntN mode n0 n1 GetWordN mode n0 GetIntN mode n1, UnifiedBVBVConversionImpl mode GetIntN mode GetWordN mode n0 n1 GetIntN mode n0 GetWordN mode n1, UnifiedBVBVConversionImpl mode GetIntN mode GetIntN mode n0 n1 GetIntN mode n0 GetIntN mode n1) => UnifiedBVBVConversion (mode :: EvalModeTag) (n0 :: Nat) (n1 :: Nat)

-- | Unified constraints for conversion from bit-vectors to floating point
--   numbers.
class UnifiedBVFPConversionImpl mode GetWordN mode GetIntN mode GetFP mode n eb sb GetWordN mode n GetIntN mode n GetFP mode eb sb GetFPRoundingMode mode => UnifiedBVFPConversion (mode :: EvalModeTag) (n :: Nat) (eb :: Nat) (sb :: Nat)

-- | Unified constraints for safe conversion from bit-vectors to floating
--   point numbers.
class SafeUnifiedBVFPConversionImpl mode GetWordN mode GetIntN mode GetFP mode n eb sb GetWordN mode n GetIntN mode n GetFP mode eb sb GetFPRoundingMode mode m => SafeUnifiedBVFPConversion (mode :: EvalModeTag) (n :: Nat) (eb :: Nat) (sb :: Nat) (m :: Type -> Type)

-- | Unified constraints for conversion from floating point numbers to
--   floating point numbers.
class UnifiedFPFPConversionImpl mode GetFP mode eb0 sb0 eb1 sb1 GetFP mode eb0 sb0 GetFP mode eb1 sb1 GetFPRoundingMode mode => UnifiedFPFPConversion (mode :: EvalModeTag) (eb0 :: Nat) (sb0 :: Nat) (eb1 :: Nat) (sb1 :: Nat)


module Grisette.Unified.Lib.Data.Foldable

-- | <a>elem</a> with symbolic equality.
symElem :: forall (mode :: EvalModeTag) t a. (Foldable t, EvalModeBase mode, UnifiedSymEq mode a) => a -> t a -> GetBool mode

-- | <a>maximum</a> with result merged with <a>ITEOp</a>.
symMaximum :: forall (mode :: EvalModeTag) a t. (Foldable t, Mergeable a, UnifiedSymOrd mode a, UnifiedITEOp mode a, EvalModeBase mode) => t a -> a

-- | <a>maximum</a> with unified comparison.
mrgMaximum :: forall (mode :: EvalModeTag) a t m. (Foldable t, EvalModeBase mode, UnifiedBranching mode m, MonadTryMerge m, Mergeable a, UnifiedSymOrd mode a) => t a -> m a

-- | <a>maximum</a> with result merged with <a>ITEOp</a>.
symMinimum :: forall (mode :: EvalModeTag) a t. (Foldable t, Mergeable a, UnifiedSymOrd mode a, UnifiedITEOp mode a, EvalModeBase mode) => t a -> a

-- | <a>minimum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMinimum :: forall (mode :: EvalModeTag) a t m. (Foldable t, EvalModeBase mode, UnifiedBranching mode m, MonadTryMerge m, Mergeable a, UnifiedSymOrd mode a) => t a -> m a

-- | <a>foldrM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldrM :: (MonadTryMerge m, Mergeable b, Foldable t) => (a -> b -> m b) -> b -> t a -> m b

-- | <a>foldlM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldlM :: (MonadTryMerge m, Mergeable b, Foldable t) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>traverse_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgTraverse_ :: (Applicative m, TryMerge m, Foldable t) => (a -> m b) -> t a -> m ()

-- | <a>for_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFor_ :: (Applicative m, TryMerge m, Foldable t) => t a -> (a -> m b) -> m ()

-- | <a>sequence_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequenceA_ :: (Foldable t, TryMerge m, Applicative m) => t (m a) -> m ()

-- | <a>asum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgAsum :: (Alternative f, TryMerge f, Mergeable a, Foldable t) => t (f a) -> f a

-- | <a>mapM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM_ :: (MonadTryMerge m, Foldable t) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM_ :: (MonadTryMerge m, Foldable t) => t a -> (a -> m b) -> m ()

-- | <a>sequence_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence_ :: (Foldable t, MonadTryMerge m) => t (m a) -> m ()

-- | <a>msum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMsum :: (MonadTryMerge m, Mergeable a, MonadPlus m, Foldable t) => t (m a) -> m a

-- | <a>and</a> on unified boolean.
symAnd :: forall (mode :: EvalModeTag) t. (EvalModeBase mode, Foldable t) => t (GetBool mode) -> GetBool mode

-- | <a>or</a> on unified boolean.
symOr :: forall (mode :: EvalModeTag) t. (EvalModeBase mode, Foldable t) => t (GetBool mode) -> GetBool mode

-- | <a>any</a> on unified boolean.
symAny :: forall (mode :: EvalModeTag) t a. (EvalModeBase mode, Foldable t) => (a -> GetBool mode) -> t a -> GetBool mode

-- | <a>all</a> on unified boolean.
symAll :: forall (mode :: EvalModeTag) t a. (EvalModeBase mode, Foldable t) => (a -> GetBool mode) -> t a -> GetBool mode

-- | <a>maximumBy</a> with result merged with <a>ITEOp</a>.
symMaximumBy :: forall (mode :: EvalModeTag) t a. (Foldable t, Mergeable a, UnifiedITEOp mode a, EvalModeBase mode) => (a -> a -> GetData mode Ordering) -> t a -> a

-- | <a>maximumBy</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMaximumBy :: forall (mode :: EvalModeTag) t a m. (Foldable t, Mergeable a, EvalModeBase mode, MonadTryMerge m, UnifiedBranching mode m) => (a -> a -> GetData mode Ordering) -> t a -> m a

-- | <a>minimumBy</a> with result merged with <a>ITEOp</a>.
symMinimumBy :: forall (mode :: EvalModeTag) t a. (Foldable t, Mergeable a, UnifiedITEOp mode a, EvalModeBase mode) => (a -> a -> GetData mode Ordering) -> t a -> a

-- | <a>minimumBy</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMinimumBy :: forall (mode :: EvalModeTag) t a m. (Foldable t, Mergeable a, EvalModeBase mode, MonadTryMerge m, UnifiedBranching mode m) => (a -> a -> GetData mode Ordering) -> t a -> m a

-- | <a>elem</a> with symbolic equality.
symNotElem :: forall t (mode :: EvalModeTag) a. (Foldable t, UnifiedSymEq mode a, EvalModeBase mode) => a -> t a -> GetBool mode

-- | <a>elem</a> with symbolic equality and <a>MergingStrategy</a>
--   knowledge propagation.
mrgFind :: forall t (mode :: EvalModeTag) m a. (Foldable t, EvalModeBase mode, MonadTryMerge m, UnifiedBranching mode m, Mergeable a) => (a -> GetBool mode) -> t a -> m (Maybe a)


module Grisette.Unified.Lib.Control.Monad

-- | <a>fmap</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFmap :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b

-- | <a>&lt;$</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => b -> f a -> f b
infixl 4 .<$

-- | <a>return</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReturnWithStrategy :: MonadTryMerge u => MergingStrategy a -> a -> u a

-- | <a>&gt;&gt;=</a> with <a>MergingStrategy</a> knowledge propagation.
mrgBindWithStrategy :: MonadTryMerge u => MergingStrategy a -> MergingStrategy b -> u a -> (a -> u b) -> u b

-- | <a>return</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReturn :: (MonadTryMerge u, Mergeable a) => a -> u a

-- | <a>&gt;&gt;=</a> with <a>MergingStrategy</a> knowledge propagation.
(.>>=) :: (MonadTryMerge u, Mergeable a, Mergeable b) => u a -> (a -> u b) -> u b
infixl 1 .>>=

-- | <a>&gt;&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
--   
--   This is usually more efficient than calling the original
--   <a>&gt;&gt;</a> and merge the results.
(.>>) :: (MonadTryMerge m, Mergeable a, Mergeable b) => m a -> m b -> m b
infixl 1 .>>

-- | <a>fail</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFail :: (MonadTryMerge m, Mergeable a, MonadFail m) => String -> m a

-- | <a>mzero</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMzero :: (MonadTryMerge m, Mergeable a, MonadPlus m) => m a

-- | <a>mplus</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMplus :: (MonadTryMerge m, Mergeable a, MonadPlus m) => m a -> m a -> m a

-- | <a>mapM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM :: forall a b t f. (Mergeable b, Mergeable1 t, MonadTryMerge f, Traversable t) => (a -> f b) -> t a -> f (t b)

-- | <a>mapM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM_ :: (MonadTryMerge m, Foldable t) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM :: (Mergeable b, Mergeable1 t, Traversable t, MonadTryMerge m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM_ :: (MonadTryMerge m, Foldable t) => t a -> (a -> m b) -> m ()

-- | <a>sequence</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence :: (Mergeable a, Mergeable1 t, MonadTryMerge f, Traversable t) => t (f a) -> f (t a)

-- | <a>sequence_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence_ :: (Foldable t, MonadTryMerge m) => t (m a) -> m ()

-- | <a>=&lt;&lt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.=<<) :: (MonadTryMerge m, Mergeable a, Mergeable b) => (a -> m b) -> m a -> m b
infixr 1 .=<<

-- | <a>&gt;=&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.>=>) :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c) => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 .>=>

-- | <a>&lt;=&lt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<=<) :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c) => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 .<=<

-- | <a>forever</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForever :: (Applicative m, TryMerge m, Mergeable b, Mergeable a) => m a -> m b

-- | <a>void</a> with <a>MergingStrategy</a> knowledge propagation.
mrgVoid :: (TryMerge f, Functor f) => f a -> f ()

-- | <a>join</a> with <a>MergingStrategy</a> knowledge propagation.
mrgJoin :: (MonadTryMerge m, Mergeable a) => m (m a) -> m a

-- | <a>msum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMsum :: (MonadTryMerge m, Mergeable a, MonadPlus m, Foldable t) => t (m a) -> m a

-- | <a>mfilter</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMfilter :: (MonadTryMerge m, MonadPlus m, Mergeable a) => (a -> Bool) -> m a -> m a

-- | <a>mfilter</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symMfilter :: forall (mode :: EvalModeTag) m a. (MonadTryMerge m, MonadPlus m, UnifiedBranching mode m, Mergeable a) => (a -> GetBool mode) -> m a -> m a

-- | <a>filterM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFilterM :: (TryMerge m, Applicative m, Mergeable a, Foldable t) => (a -> m Bool) -> t a -> m [a]

-- | <a>filterM</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symFilterM :: forall (mode :: EvalModeTag) m t a. (TryMerge m, UnifiedBranching mode m, MonadTryMerge m, EvalModeBase mode, Mergeable a, Foldable t) => (a -> m (GetBool mode)) -> t a -> m [a]

-- | <a>mapAndUnzipM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapAndUnzipM :: (Applicative m, TryMerge m, Mergeable b, Mergeable c) => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | <a>zipWithM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgZipWithM :: (Applicative m, TryMerge m, Mergeable c) => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgZipWithM_ :: (Applicative m, TryMerge m, Mergeable c) => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | <a>foldM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldM :: (MonadTryMerge m, Mergeable b, Foldable t) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>foldM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldM_ :: (MonadTryMerge m, Foldable t, Mergeable b) => (b -> a -> m b) -> b -> t a -> m ()

-- | <a>replicateM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReplicateM :: (Applicative m, TryMerge m, Mergeable a) => Int -> m a -> m [a]

-- | <a>replicateM</a> with <a>MergingStrategy</a> knowledge propagation
--   and symbolic number of elements.
symReplicateM :: forall (mode :: EvalModeTag) m a int. (EvalModeBase mode, TryMerge m, Applicative m, Mergeable a, Num int, UnifiedBranching mode m, UnifiedSymOrd mode Int, UnifiedSymOrd mode int) => Int -> int -> m a -> m [a]

-- | <a>replicateM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReplicateM_ :: (Applicative m, TryMerge m, Mergeable a) => Int -> m a -> m ()

-- | <a>replicateM_</a> with <a>MergingStrategy</a> knowledge propagation
--   and symbolic number of elements.
symReplicateM_ :: forall (mode :: EvalModeTag) m a int. (EvalModeBase mode, TryMerge m, Applicative m, Mergeable a, Num int, UnifiedBranching mode m, UnifiedSymOrd mode Int, UnifiedSymOrd mode int) => Int -> int -> m a -> m ()

-- | <a>guard</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGuard :: (Alternative m, TryMerge m) => Bool -> m ()

-- | <a>guard</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symGuard :: (SymBranching m, TryMerge m, Alternative m) => SymBool -> m ()

-- | <a>when</a> with <a>MergingStrategy</a> knowledge propagation.
mrgWhen :: (Applicative m, TryMerge m) => Bool -> m () -> m ()

-- | <a>when</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symWhen :: (Applicative m, TryMerge m, SymBranching m) => SymBool -> m () -> m ()

-- | <a>unless</a> with <a>MergingStrategy</a> knowledge propagation.
mrgUnless :: (Applicative m, TryMerge m) => Bool -> m () -> m ()

-- | <a>unless</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symUnless :: (Applicative m, TryMerge m, SymBranching m) => SymBool -> m () -> m ()

-- | <a>liftM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM :: (MonadTryMerge m, Mergeable a, Mergeable b) => (a -> b) -> m a -> m b

-- | <a>liftM2</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM2 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c) => (a -> b -> c) -> m a -> m b -> m c

-- | <a>liftM3</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM3 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c, Mergeable d) => (a -> b -> c -> d) -> m a -> m b -> m c -> m d

-- | <a>liftM4</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM4 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c, Mergeable d, Mergeable e) => (a -> b -> c -> d -> e) -> m a -> m b -> m c -> m d -> m e

-- | <a>liftM5</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM5 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c, Mergeable d, Mergeable e, Mergeable f) => (a -> b -> c -> d -> e -> f) -> m a -> m b -> m c -> m d -> m e -> m f

-- | <a>&lt;*&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
mrgAp :: (MonadTryMerge m, Mergeable a, Mergeable b) => m (a -> b) -> m a -> m b

-- | <a>&lt;$!&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
--   Merging is always strict so we can directly use <a>.&lt;$&gt;</a>.
(.<$!>) :: (MonadTryMerge m, Mergeable a, Mergeable b) => (a -> b) -> m a -> m b
infixl 4 .<$!>


module Grisette.Lib.Data.Foldable

-- | <a>elem</a> with symbolic equality.
symElem :: (Foldable t, SymEq a) => a -> t a -> SymBool

-- | <a>maximum</a> with result merged with <a>ITEOp</a>.
symMaximum :: forall a t. (Foldable t, Mergeable a, SymOrd a, ITEOp a) => t a -> a

-- | <a>maximum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMaximum :: forall a t m. (Foldable t, MonadUnion m, Mergeable a, SymOrd a) => t a -> m a

-- | <a>minimum</a> with result merged with <a>ITEOp</a>.
symMinimum :: forall a t. (Foldable t, Mergeable a, SymOrd a, ITEOp a) => t a -> a

-- | <a>minimum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMinimum :: forall a t m. (Foldable t, MonadUnion m, Mergeable a, SymOrd a) => t a -> m a

-- | <a>foldrM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldrM :: (MonadTryMerge m, Mergeable b, Foldable t) => (a -> b -> m b) -> b -> t a -> m b

-- | <a>foldlM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldlM :: (MonadTryMerge m, Mergeable b, Foldable t) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>traverse_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgTraverse_ :: (Applicative m, TryMerge m, Foldable t) => (a -> m b) -> t a -> m ()

-- | <a>for_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFor_ :: (Applicative m, TryMerge m, Foldable t) => t a -> (a -> m b) -> m ()

-- | <a>sequence_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequenceA_ :: (Foldable t, TryMerge m, Applicative m) => t (m a) -> m ()

-- | <a>asum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgAsum :: (Alternative f, TryMerge f, Mergeable a, Foldable t) => t (f a) -> f a

-- | <a>mapM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM_ :: (MonadTryMerge m, Foldable t) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM_ :: (MonadTryMerge m, Foldable t) => t a -> (a -> m b) -> m ()

-- | <a>sequence_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence_ :: (Foldable t, MonadTryMerge m) => t (m a) -> m ()

-- | <a>msum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMsum :: (MonadTryMerge m, Mergeable a, MonadPlus m, Foldable t) => t (m a) -> m a

-- | <a>and</a> on symbolic boolean.
symAnd :: Foldable t => t SymBool -> SymBool

-- | <a>or</a> on symbolic boolean.
symOr :: Foldable t => t SymBool -> SymBool

-- | <a>any</a> on symbolic boolean.
symAny :: Foldable t => (a -> SymBool) -> t a -> SymBool

-- | <a>all</a> on symbolic boolean.
symAll :: Foldable t => (a -> SymBool) -> t a -> SymBool

-- | <a>maximumBy</a> with result merged with <a>ITEOp</a>.
symMaximumBy :: (Foldable t, Mergeable a, ITEOp a) => (a -> a -> Union Ordering) -> t a -> a

-- | <a>maximumBy</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMaximumBy :: (Foldable t, Mergeable a, MonadUnion m) => (a -> a -> Union Ordering) -> t a -> m a

-- | <a>minimumBy</a> with result merged with <a>ITEOp</a>.
symMinimumBy :: (Foldable t, Mergeable a, ITEOp a) => (a -> a -> Union Ordering) -> t a -> a

-- | <a>minimumBy</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMinimumBy :: (Foldable t, Mergeable a, MonadUnion m) => (a -> a -> Union Ordering) -> t a -> m a

-- | <a>elem</a> with symbolic equality.
symNotElem :: (Foldable t, SymEq a) => a -> t a -> SymBool

-- | <a>elem</a> with symbolic equality and <a>MergingStrategy</a>
--   knowledge propagation.
mrgFind :: (Foldable t, MonadUnion m, Mergeable a) => (a -> SymBool) -> t a -> m (Maybe a)


module Grisette.Lib.Control.Monad

-- | <a>fmap</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFmap :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => (a -> b) -> f a -> f b

-- | <a>&lt;$</a> with <a>MergingStrategy</a> knowledge propagation.
(.<$) :: (TryMerge f, Mergeable a, Mergeable b, Functor f) => b -> f a -> f b
infixl 4 .<$

-- | <a>return</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReturnWithStrategy :: MonadTryMerge u => MergingStrategy a -> a -> u a

-- | <a>&gt;&gt;=</a> with <a>MergingStrategy</a> knowledge propagation.
mrgBindWithStrategy :: MonadTryMerge u => MergingStrategy a -> MergingStrategy b -> u a -> (a -> u b) -> u b

-- | <a>return</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReturn :: (MonadTryMerge u, Mergeable a) => a -> u a

-- | <a>&gt;&gt;=</a> with <a>MergingStrategy</a> knowledge propagation.
(.>>=) :: (MonadTryMerge u, Mergeable a, Mergeable b) => u a -> (a -> u b) -> u b
infixl 1 .>>=

-- | <a>&gt;&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
--   
--   This is usually more efficient than calling the original
--   <a>&gt;&gt;</a> and merge the results.
(.>>) :: (MonadTryMerge m, Mergeable a, Mergeable b) => m a -> m b -> m b
infixl 1 .>>

-- | <a>fail</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFail :: (MonadTryMerge m, Mergeable a, MonadFail m) => String -> m a

-- | <a>mzero</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMzero :: (MonadTryMerge m, Mergeable a, MonadPlus m) => m a

-- | <a>mplus</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMplus :: (MonadTryMerge m, Mergeable a, MonadPlus m) => m a -> m a -> m a

-- | <a>mapM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM :: forall a b t f. (Mergeable b, Mergeable1 t, MonadTryMerge f, Traversable t) => (a -> f b) -> t a -> f (t b)

-- | <a>mapM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapM_ :: (MonadTryMerge m, Foldable t) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM :: (Mergeable b, Mergeable1 t, Traversable t, MonadTryMerge m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForM_ :: (MonadTryMerge m, Foldable t) => t a -> (a -> m b) -> m ()

-- | <a>sequence</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence :: (Mergeable a, Mergeable1 t, MonadTryMerge f, Traversable t) => t (f a) -> f (t a)

-- | <a>sequence_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgSequence_ :: (Foldable t, MonadTryMerge m) => t (m a) -> m ()

-- | <a>=&lt;&lt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.=<<) :: (MonadTryMerge m, Mergeable a, Mergeable b) => (a -> m b) -> m a -> m b
infixr 1 .=<<

-- | <a>&gt;=&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.>=>) :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c) => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 .>=>

-- | <a>&lt;=&lt;</a> with <a>MergingStrategy</a> knowledge propagation.
(.<=<) :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c) => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 .<=<

-- | <a>forever</a> with <a>MergingStrategy</a> knowledge propagation.
mrgForever :: (Applicative m, TryMerge m, Mergeable b, Mergeable a) => m a -> m b

-- | <a>void</a> with <a>MergingStrategy</a> knowledge propagation.
mrgVoid :: (TryMerge f, Functor f) => f a -> f ()

-- | <a>join</a> with <a>MergingStrategy</a> knowledge propagation.
mrgJoin :: (MonadTryMerge m, Mergeable a) => m (m a) -> m a

-- | <a>msum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMsum :: (MonadTryMerge m, Mergeable a, MonadPlus m, Foldable t) => t (m a) -> m a

-- | <a>mfilter</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMfilter :: (MonadTryMerge m, MonadPlus m, Mergeable a) => (a -> Bool) -> m a -> m a

-- | <a>mfilter</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symMfilter :: (MonadTryMerge m, MonadPlus m, MonadUnion m, Mergeable a) => (a -> SymBool) -> m a -> m a

-- | <a>filterM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFilterM :: (TryMerge m, Applicative m, Mergeable a, Foldable t) => (a -> m Bool) -> t a -> m [a]

-- | <a>filterM</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symFilterM :: (TryMerge m, MonadUnion m, Mergeable a, Foldable t) => (a -> m SymBool) -> t a -> m [a]

-- | <a>mapAndUnzipM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapAndUnzipM :: (Applicative m, TryMerge m, Mergeable b, Mergeable c) => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | <a>zipWithM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgZipWithM :: (Applicative m, TryMerge m, Mergeable c) => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgZipWithM_ :: (Applicative m, TryMerge m, Mergeable c) => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | <a>foldM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldM :: (MonadTryMerge m, Mergeable b, Foldable t) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>foldM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgFoldM_ :: (MonadTryMerge m, Foldable t, Mergeable b) => (b -> a -> m b) -> b -> t a -> m ()

-- | <a>replicateM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReplicateM :: (Applicative m, TryMerge m, Mergeable a) => Int -> m a -> m [a]

-- | <a>replicateM</a> with <a>MergingStrategy</a> knowledge propagation
--   and symbolic number of elements.
symReplicateM :: (MonadUnion m, TryMerge m, Mergeable a, Num int, SymOrd int) => Int -> int -> m a -> m [a]

-- | <a>replicateM_</a> with <a>MergingStrategy</a> knowledge propagation.
mrgReplicateM_ :: (Applicative m, TryMerge m, Mergeable a) => Int -> m a -> m ()

-- | <a>replicateM_</a> with <a>MergingStrategy</a> knowledge propagation
--   and symbolic number of elements.
symReplicateM_ :: (MonadUnion m, TryMerge m, Mergeable a, Num int, SymOrd int) => Int -> int -> m a -> m ()

-- | <a>guard</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGuard :: (Alternative m, TryMerge m) => Bool -> m ()

-- | <a>guard</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symGuard :: (SymBranching m, TryMerge m, Alternative m) => SymBool -> m ()

-- | <a>when</a> with <a>MergingStrategy</a> knowledge propagation.
mrgWhen :: (Applicative m, TryMerge m) => Bool -> m () -> m ()

-- | <a>when</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symWhen :: (Applicative m, TryMerge m, SymBranching m) => SymBool -> m () -> m ()

-- | <a>unless</a> with <a>MergingStrategy</a> knowledge propagation.
mrgUnless :: (Applicative m, TryMerge m) => Bool -> m () -> m ()

-- | <a>unless</a> with <a>MergingStrategy</a> knowledge propagation and
--   symbolic conditions.
symUnless :: (Applicative m, TryMerge m, SymBranching m) => SymBool -> m () -> m ()

-- | <a>liftM</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM :: (MonadTryMerge m, Mergeable a, Mergeable b) => (a -> b) -> m a -> m b

-- | <a>liftM2</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM2 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c) => (a -> b -> c) -> m a -> m b -> m c

-- | <a>liftM3</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM3 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c, Mergeable d) => (a -> b -> c -> d) -> m a -> m b -> m c -> m d

-- | <a>liftM4</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM4 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c, Mergeable d, Mergeable e) => (a -> b -> c -> d -> e) -> m a -> m b -> m c -> m d -> m e

-- | <a>liftM5</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftM5 :: (MonadTryMerge m, Mergeable a, Mergeable b, Mergeable c, Mergeable d, Mergeable e, Mergeable f) => (a -> b -> c -> d -> e -> f) -> m a -> m b -> m c -> m d -> m e -> m f

-- | <a>&lt;*&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
mrgAp :: (MonadTryMerge m, Mergeable a, Mergeable b) => m (a -> b) -> m a -> m b

-- | <a>&lt;$!&gt;</a> with <a>MergingStrategy</a> knowledge propagation.
--   Merging is always strict so we can directly use <a>.&lt;$&gt;</a>.
(.<$!>) :: (MonadTryMerge m, Mergeable a, Mergeable b) => (a -> b) -> m a -> m b
infixl 4 .<$!>


module Grisette.Lib.Data.List

-- | <a>and</a> on symbolic boolean.
symAnd :: Foldable t => t SymBool -> SymBool

-- | <a>or</a> on symbolic boolean.
symOr :: Foldable t => t SymBool -> SymBool

-- | <a>any</a> on symbolic boolean.
symAny :: Foldable t => (a -> SymBool) -> t a -> SymBool

-- | <a>all</a> on symbolic boolean.
symAll :: Foldable t => (a -> SymBool) -> t a -> SymBool

-- | <a>maximum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMaximum :: forall a t m. (Foldable t, MonadUnion m, Mergeable a, SymOrd a) => t a -> m a

-- | <a>maximum</a> with result merged with <a>ITEOp</a>.
symMaximum :: forall a t. (Foldable t, Mergeable a, SymOrd a, ITEOp a) => t a -> a

-- | <a>minimum</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMinimum :: forall a t m. (Foldable t, MonadUnion m, Mergeable a, SymOrd a) => t a -> m a

-- | <a>minimum</a> with result merged with <a>ITEOp</a>.
symMinimum :: forall a t. (Foldable t, Mergeable a, SymOrd a, ITEOp a) => t a -> a

-- | Symbolic version of <a>take</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgTake :: (Applicative u, SymBranching u, Mergeable a, Num int, SymOrd int) => int -> [a] -> u [a]

-- | Symbolic version of <a>drop</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgDrop :: (Applicative u, SymBranching u, Mergeable a, Num int, SymOrd int) => int -> [a] -> u [a]

-- | Symbolic version of <a>splitAt</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgSplitAt :: forall a int u. (MonadUnion u, Mergeable a, Num int, SymOrd int) => int -> [a] -> u ([a], [a])

-- | Symbolic version of <a>takeWhile</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgTakeWhile :: (Applicative u, SymBranching u, Mergeable a) => (a -> SymBool) -> [a] -> u [a]

-- | Symbolic version of <a>dropWhile</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgDropWhile :: (Applicative u, SymBranching u, Mergeable a) => (a -> SymBool) -> [a] -> u [a]

-- | Symbolic version of <a>dropWhileEnd</a>, the result would be merged
--   and propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgDropWhileEnd :: (MonadUnion u, Mergeable a) => (a -> SymBool) -> [a] -> u [a]

-- | Symbolic version of <a>span</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgSpan :: (Applicative u, SymBranching u, Mergeable a) => (a -> SymBool) -> [a] -> u ([a], [a])

-- | Symbolic version of <a>break</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgBreak :: (Applicative u, SymBranching u, Mergeable a) => (a -> SymBool) -> [a] -> u ([a], [a])

-- | Symbolic version of <a>stripPrefix</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Generate O(1) cases and O(len(prefix)) sized branch constraints.
mrgStripPrefix :: (Applicative u, SymBranching u, Mergeable a, SymEq a) => [a] -> [a] -> u (Maybe [a])

-- | Symbolic version of <a>group</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   This function can be very inefficient on large symbolic lists and
--   generate O(2^n) cases. Use with caution.
mrgGroup :: (MonadUnion u, Mergeable a, SymEq a) => [a] -> u [[a]]

-- | Symbolic version of <a>isPrefixOf</a>.
--   
--   Generate O(len(prefix)) sized constraints.
symIsPrefixOf :: SymEq a => [a] -> [a] -> SymBool

-- | Symbolic version of <a>isSuffixOf</a>.
--   
--   Generate O(len(suffix)) sized constraints.
symIsSuffixOf :: SymEq a => [a] -> [a] -> SymBool

-- | Symbolic version of <a>isInfixOf</a>.
--   
--   Generate O(len(haystack) * len(needle)) sized constraints.
symIsInfixOf :: SymEq a => [a] -> [a] -> SymBool

-- | Symbolic version of <a>isSubsequenceOf</a>.
--   
--   Generate O(len(haystack) * len(needle)) sized constraints.
symIsSubsequenceOf :: SymEq a => [a] -> [a] -> SymBool

-- | <a>elem</a> with symbolic equality.
symElem :: (Foldable t, SymEq a) => a -> t a -> SymBool

-- | <a>elem</a> with symbolic equality.
symNotElem :: (Foldable t, SymEq a) => a -> t a -> SymBool

-- | Symbolic version of <a>lookup</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases and O(n) sized branch constraints.
mrgLookup :: forall a b u. (Applicative u, SymBranching u, Mergeable b, SymEq a) => a -> [(a, b)] -> u (Maybe b)

-- | <a>elem</a> with symbolic equality and <a>MergingStrategy</a>
--   knowledge propagation.
mrgFind :: (Foldable t, MonadUnion m, Mergeable a) => (a -> SymBool) -> t a -> m (Maybe a)

-- | Symbolic version of <a>filter</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   This function can be very inefficient on large symbolic lists and
--   generate O(2^n) cases. Use with caution.
mrgFilter :: (Applicative u, SymBranching u, Mergeable a) => (a -> SymBool) -> [a] -> u [a]

-- | Symbolic version of <a>partition</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   This function can be very inefficient on large symbolic lists and
--   generate O(2^n) cases. Use with caution.
mrgPartition :: (Applicative u, SymBranching u, Mergeable a) => (a -> SymBool) -> [a] -> u ([a], [a])

-- | Symbolic version of <a>!?</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(1) cases and O(n) sized branch constraints.
(.!?) :: forall a uf int. (MonadUnion uf, Mergeable a, Num int, SymEq int) => [a] -> int -> uf (Maybe a)

-- | Symbolic version of <a>elemIndex</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases (or O(1) if int is merged), and O(n^2) sized
--   constraints.
mrgElemIndex :: (MonadUnion u, Mergeable int, SymEq a, Num int) => a -> [a] -> u (Maybe int)

-- | Symbolic version of <a>elemIndices</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases, and O(n^3) sized constraints.
mrgElemIndices :: (MonadUnion u, Mergeable int, SymEq a, Num int) => a -> [a] -> u [int]

-- | Symbolic version of <a>findIndex</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases (or O(1) if int is merged), and O(n^2) sized
--   constraints, assuming the predicate only generates O(1) constraints.
mrgFindIndex :: (Applicative u, SymBranching u, Mergeable int, SymEq a, Num int) => (a -> SymBool) -> [a] -> u (Maybe int)

-- | Symbolic version of <a>findIndices</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases, and O(n^3) sized constraints, assuming the
--   predicate only generates O(1) constraints.
mrgFindIndices :: forall u a int. (Applicative u, SymBranching u, Mergeable int, SymEq a, Num int) => (a -> SymBool) -> [a] -> u [int]

-- | Symbolic version of <a>nub</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases, and O(n^3) sized constraints.
mrgNub :: (Applicative u, SymBranching u, Mergeable a, SymEq a) => [a] -> u [a]

-- | Symbolic version of <a>delete</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases, and O(n^2) sized constraints.
mrgDelete :: (Applicative u, SymBranching u, Mergeable a, SymEq a) => a -> [a] -> u [a]

-- | Symbolic version of <a>\\</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(len(lhs)) cases, and O(len(lhs)^2 * len(rhs)) sized
--   constraints.
(.\\) :: (MonadUnion u, Mergeable a, SymEq a) => [a] -> [a] -> u [a]

-- | Symbolic version of <a>union</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(len(rhs)) cases, and O(len(rhs)^5 * len(lhs)) sized
--   constraints.
--   
--   Should be improvable.
mrgUnion :: (MonadUnion u, Mergeable a, SymEq a) => [a] -> [a] -> u [a]

-- | Symbolic version of <a>intersect</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(len(rhs)) cases, and O(len(lhs) * len(rhs))
--   constraints.
mrgIntersect :: (MonadUnion u, Mergeable a, SymEq a) => [a] -> [a] -> u [a]

-- | Symbolic version of <a>insert</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate 1 case, and O(n^2) sized constraints.
mrgInsert :: (MonadUnion m, Mergeable a, SymOrd a) => a -> [a] -> m [a]

-- | Symbolic version of <a>nubBy</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases, and O(n^3) sized constraints, assuming the
--   predicate only generates O(1) constraints.
mrgNubBy :: forall a u. (Applicative u, SymBranching u, Mergeable a) => (a -> a -> SymBool) -> [a] -> u [a]

-- | Symbolic version of <a>deleteBy</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(n) cases, and O(n^2) sized constraints, assuming the
--   predicate only generates O(1) constraints.
mrgDeleteBy :: (Applicative u, SymBranching u, Mergeable a) => (a -> a -> SymBool) -> a -> [a] -> u [a]

-- | Symbolic version of <a>deleteFirstsBy</a>, the result would be merged
--   and propagate the mergeable knowledge.
--   
--   Can generate O(len(lhs)) cases, and O(len(lhs)^2 * len(rhs)) sized
--   constraints, assuming the predicate only generates O(1) constraints.
mrgDeleteFirstsBy :: (MonadUnion u, Mergeable a) => (a -> a -> SymBool) -> [a] -> [a] -> u [a]

-- | Symbolic version of <a>unionBy</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(len(rhs)) cases, and O(len(rhs)^5 * len(lhs)) sized
--   constraints, assuming the predicate only generates O(1) constraints.
--   
--   Should be improvable.
mrgUnionBy :: (MonadUnion u, Mergeable a) => (a -> a -> SymBool) -> [a] -> [a] -> u [a]

-- | Symbolic version of <a>intersectBy</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate O(len(rhs)) cases, and O(len(lhs) * len(rhs))
--   constraints, assuming the predicate only generates O(1) constraints.
mrgIntersectBy :: (MonadUnion u, Mergeable a) => (a -> a -> SymBool) -> [a] -> [a] -> u [a]

-- | This function can be very inefficient on large symbolic lists and
--   generate O(2^n) cases. Use with caution.
mrgGroupBy :: (MonadUnion u, Mergeable a) => (a -> a -> SymBool) -> [a] -> u [[a]]

-- | Symbolic version of <a>insertBy</a>, the result would be merged and
--   propagate the mergeable knowledge.
--   
--   Can generate 1 case, and O(n^2) sized constraints, assuming the
--   ordering function only generates O(1) constraints.
mrgInsertBy :: (MonadUnion m, Mergeable a) => (a -> a -> Union Ordering) -> a -> [a] -> m [a]

-- | <a>maximumBy</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMaximumBy :: (Foldable t, Mergeable a, MonadUnion m) => (a -> a -> Union Ordering) -> t a -> m a

-- | <a>maximumBy</a> with result merged with <a>ITEOp</a>.
symMaximumBy :: (Foldable t, Mergeable a, ITEOp a) => (a -> a -> Union Ordering) -> t a -> a

-- | <a>minimumBy</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMinimumBy :: (Foldable t, Mergeable a, MonadUnion m) => (a -> a -> Union Ordering) -> t a -> m a

-- | <a>minimumBy</a> with result merged with <a>ITEOp</a>.
symMinimumBy :: (Foldable t, Mergeable a, ITEOp a) => (a -> a -> Union Ordering) -> t a -> a


module Grisette.Lib.Control.Monad.Trans.State.Strict

-- | <a>state</a> with <a>MergingStrategy</a> knowledge propagation.
mrgState :: forall (m :: Type -> Type) s a. (Monad m, TryMerge m, Mergeable s, Mergeable a) => (s -> (a, s)) -> StateT s m a

-- | <a>runStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgRunStateT :: (Monad m, TryMerge m, Mergeable s, Mergeable a) => StateT s m a -> s -> m (a, s)

-- | <a>evalStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgEvalStateT :: (Monad m, TryMerge m, Mergeable a) => StateT s m a -> s -> m a

-- | <a>execStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgExecStateT :: (Monad m, TryMerge m, Mergeable s) => StateT s m a -> s -> m s

-- | <a>mapStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapStateT :: (TryMerge n, Mergeable b, Mergeable s) => (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <a>withStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgWithStateT :: forall (m :: Type -> Type) s a. (TryMerge m, Mergeable s, Mergeable a) => (s -> s) -> StateT s m a -> StateT s m a

-- | <a>get</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGet :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => StateT s m s

-- | <a>put</a> with <a>MergingStrategy</a> knowledge propagation.
mrgPut :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => s -> StateT s m ()

-- | <a>modify</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModify :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => (s -> s) -> StateT s m ()

-- | <a>modify'</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModify' :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => (s -> s) -> StateT s m ()

-- | <a>gets</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGets :: forall (m :: Type -> Type) s a. (Monad m, TryMerge m, Mergeable s, Mergeable a) => (s -> a) -> StateT s m a


module Grisette.Lib.Control.Monad.Trans.State.Lazy

-- | <a>state</a> with <a>MergingStrategy</a> knowledge propagation.
mrgState :: forall (m :: Type -> Type) s a. (Monad m, TryMerge m, Mergeable s, Mergeable a) => (s -> (a, s)) -> StateT s m a

-- | <a>runStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgRunStateT :: (Monad m, TryMerge m, Mergeable s, Mergeable a) => StateT s m a -> s -> m (a, s)

-- | <a>evalStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgEvalStateT :: (Monad m, TryMerge m, Mergeable a) => StateT s m a -> s -> m a

-- | <a>execStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgExecStateT :: (Monad m, TryMerge m, Mergeable s) => StateT s m a -> s -> m s

-- | <a>mapStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapStateT :: (TryMerge n, Mergeable b, Mergeable s) => (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <a>withStateT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgWithStateT :: forall (m :: Type -> Type) s a. (TryMerge m, Mergeable s, Mergeable a) => (s -> s) -> StateT s m a -> StateT s m a

-- | <a>get</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGet :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => StateT s m s

-- | <a>put</a> with <a>MergingStrategy</a> knowledge propagation.
mrgPut :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => s -> StateT s m ()

-- | <a>modify</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModify :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => (s -> s) -> StateT s m ()

-- | <a>modify'</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModify' :: forall (m :: Type -> Type) s. (Monad m, TryMerge m, Mergeable s) => (s -> s) -> StateT s m ()

-- | <a>gets</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGets :: forall (m :: Type -> Type) s a. (Monad m, TryMerge m, Mergeable s, Mergeable a) => (s -> a) -> StateT s m a


module Grisette.Lib.Control.Monad.Trans.State


module Grisette.Lib.Control.Monad.Trans.Cont

-- | <a>runContT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgRunContT :: (TryMerge m, Mergeable r) => ContT r m a -> (a -> m r) -> m r

-- | <a>evalContT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgEvalContT :: (TryMerge m, Mergeable r, Monad m) => ContT r m r -> m r

-- | <a>resetT</a> with <a>MergingStrategy</a> knowledge propagation.
mrgResetT :: forall (m :: Type -> Type) r r'. (TryMerge m, Mergeable r, Monad m) => ContT r m r -> ContT r' m r


module Grisette.Lib.Control.Monad.State.Class

-- | <a>get</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGet :: (MonadState s m, TryMerge m, Mergeable s) => m s

-- | <a>put</a> with <a>MergingStrategy</a> knowledge propagation.
mrgPut :: (MonadState s m, TryMerge m) => s -> m ()

-- | <a>state</a> with <a>MergingStrategy</a> knowledge propagation.
mrgState :: (MonadState s m, TryMerge m, Mergeable s, Mergeable a) => (s -> (a, s)) -> m a

-- | <a>modify</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModify :: (MonadState s m, TryMerge m, Mergeable s) => (s -> s) -> m ()

-- | <a>modify'</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModify' :: (MonadState s m, TryMerge m, Mergeable s) => (s -> s) -> m ()

-- | <a>gets</a> with <a>MergingStrategy</a> knowledge propagation.
mrgGets :: (MonadState s m, TryMerge m, Mergeable s, Mergeable a) => (s -> a) -> m a


module Grisette.Lib.Control.Monad.Except

-- | <a>throwError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgThrowError :: (MonadError e m, TryMerge m, Mergeable a) => e -> m a

-- | <a>catchError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgCatchError :: (MonadError e m, TryMerge m, Mergeable a) => m a -> (e -> m a) -> m a

-- | <a>liftEither</a> with <a>MergingStrategy</a> knowledge propagation.
mrgLiftEither :: (MonadError e m, TryMerge m, Mergeable a, Mergeable e) => Either e a -> m a

-- | <a>tryError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgTryError :: (MonadError e m, TryMerge m, Mergeable a, Mergeable e) => m a -> m (Either e a)

-- | <a>withError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgWithError :: (MonadError e m, TryMerge m, Mergeable a, Mergeable e) => (e -> e) -> m a -> m a

-- | <a>handleError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgHandleError :: (MonadError e m, TryMerge m, Mergeable a, Mergeable e) => (e -> m a) -> m a -> m a

-- | <a>mapError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgMapError :: (MonadError e m, TryMerge m, MonadError e' n, TryMerge n, Mergeable a, Mergeable b, Mergeable e, Mergeable e') => (m (Either e a) -> n (Either e' b)) -> m a -> n b

-- | <a>modifyError</a> with <a>MergingStrategy</a> knowledge propagation.
mrgModifyError :: (MonadError e' m, TryMerge m, Mergeable a, Mergeable e, Mergeable e) => (e -> e') -> ExceptT e m a -> m a


module Grisette.Lib.Base


module Grisette.Internal.Core.Control.Monad.CBMCExcept

-- | A wrapper type for <a>Either</a>. Uses different merging strategies.
newtype CBMCEither a b
CBMCEither :: Either a b -> CBMCEither a b
[runCBMCEither] :: CBMCEither a b -> Either a b

-- | Similar to <a>ExceptT</a>, but with different error handling
--   mechanism.
newtype CBMCExceptT e (m :: Type -> Type) a
CBMCExceptT :: m (CBMCEither e a) -> CBMCExceptT e (m :: Type -> Type) a
[runCBMCExceptT] :: CBMCExceptT e (m :: Type -> Type) a -> m (CBMCEither e a)

-- | Wrap an <a>Either</a> value in <a>CBMCExceptT</a>
cbmcExcept :: forall (m :: Type -> Type) e a. Monad m => Either e a -> CBMCExceptT e m a

-- | Map the error and values in a <a>CBMCExceptT</a>
mapCBMCExceptT :: (m (Either e a) -> n (Either e' b)) -> CBMCExceptT e m a -> CBMCExceptT e' n b

-- | Map the error in a <a>CBMCExceptT</a>
withCBMCExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> CBMCExceptT e m a -> CBMCExceptT e' m a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a
instance (GHC.Internal.Base.Functor m, GHC.Internal.Base.Monad m, GHC.Internal.Base.Monoid e) => GHC.Internal.Base.Alternative (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance GHC.Internal.Base.Applicative (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance (GHC.Internal.Base.Functor m, GHC.Internal.Base.Monad m) => GHC.Internal.Base.Applicative (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance GHC.Classes.Eq idx => GHC.Classes.Eq (Grisette.Internal.Core.Control.Monad.CBMCExcept.EitherIdx idx)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym a, Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym b) => Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) => Grisette.Internal.Internal.Decl.Core.Data.Class.EvalSym.EvalSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym a, Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym b) => Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) => Grisette.Internal.Internal.Decl.Core.Data.Class.ExtractSym.ExtractSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance GHC.Internal.Data.Foldable.Foldable f => GHC.Internal.Data.Foldable.Foldable (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e f)
instance GHC.Internal.Base.Functor (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple b b) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)) => Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT a m b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple a a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple b b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Core.Data.Class.GenSym.GenSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym () (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Internal.Core.Data.Class.GenSym.GenSym spec (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT a m b)
instance GHC.Internal.Base.Functor m => GHC.Internal.Generics.Generic1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance GHC.Internal.Generics.Generic (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance GHC.Internal.Generics.Generic (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance GHC.Internal.Base.Monad (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance GHC.Internal.Base.Monad m => Control.Monad.Error.Class.MonadError e (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance GHC.Internal.Control.Monad.Fail.MonadFail m => GHC.Internal.Control.Monad.Fail.MonadFail (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Monad.Fix.MonadFix (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (GHC.Internal.Base.Monad m, GHC.Internal.Base.Monoid e) => GHC.Internal.Base.MonadPlus (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance Control.Monad.Trans.Class.MonadTrans (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e)
instance Control.Monad.Zip.MonadZip m => Control.Monad.Zip.MonadZip (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance GHC.Classes.Ord idx => GHC.Classes.Ord (Grisette.Internal.Core.Control.Monad.CBMCExcept.EitherIdx idx)
instance GHC.Internal.Read.Read a => Data.Functor.Classes.Read1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance (GHC.Internal.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (GHC.Internal.Read.Read a, GHC.Internal.Read.Read b) => GHC.Internal.Read.Read (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (GHC.Internal.Read.Read e, Data.Functor.Classes.Read1 m, GHC.Internal.Read.Read a) => GHC.Internal.Read.Read (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance GHC.Internal.Show.Show a => Data.Functor.Classes.Show1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a)
instance (GHC.Internal.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b) => GHC.Internal.Show.Show (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance (GHC.Internal.Show.Show e, Data.Functor.Classes.Show1 m, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance GHC.Internal.Show.Show idx => GHC.Internal.Show.Show (Grisette.Internal.Core.Control.Monad.CBMCExcept.EitherIdx idx)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SimpleMergeable1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SimpleMergeable (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Internal.Internal.Decl.Core.Data.Class.SimpleMergeable.SymBranching (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq e, Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq a) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymEq.SymEq (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd b) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither a b)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd (m (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e a)) => Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon a1 a2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e1 a1) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e2 a2)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon a1 a2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e1 a1) (GHC.Internal.Data.Either.Either e2 a2)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon1 m1 m2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon a b) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e1 m1 a) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e2 m2 b)
instance Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (m1 (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e1 a)) (GHC.Internal.Data.Either.Either e2 b) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e1 m1 a) (GHC.Internal.Data.Either.Either e2 b)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon a1 a2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToCon.ToCon (GHC.Internal.Data.Either.Either e1 a1) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e2 a2)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym a1 a2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e1 a1) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e2 a2)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym a1 a2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e1 a1) (GHC.Internal.Data.Either.Either e2 a2)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym a b, Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym1 m1 m2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e1 m1 a) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e2 m2 b)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym e1 e2, Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym a1 a2) => Grisette.Internal.Internal.Decl.Core.Data.Class.ToSym.ToSym (GHC.Internal.Data.Either.Either e1 a1) (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e2 a2)
instance GHC.Internal.Data.Traversable.Traversable f => GHC.Internal.Data.Traversable.Traversable (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e f)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e m)
instance (GHC.Internal.Base.Monad u, Grisette.Internal.Internal.Decl.Core.Data.Class.TryMerge.TryMerge u, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable v) => Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.UnionWithExcept (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCExceptT e u v) u e v
instance Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.UnionWithExcept (Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union (Grisette.Internal.Core.Control.Monad.CBMCExcept.CBMCEither e v)) Grisette.Internal.Internal.Decl.Core.Control.Monad.Union.Union e v


module Grisette.Experimental.GenSymConstrained

-- | Class of types in which symbolic values can be generated with some
--   specification.
--   
--   See <a>GenSym</a> for more details. The difference of this class is
--   that it allows constraints to be generated along with the generation
--   of symbolic values.
class Mergeable a => GenSymConstrained spec a

-- | Generates a symbolic value with the given specification.
--   
--   Constraint violations will throw an error in the monadic environment.
--   
--   <pre>
--   &gt;&gt;&gt; runFreshT (freshConstrained () (SymOrdUpperBound (1 :: SymInteger) ())) "a" :: ExceptT () Union (Union SymInteger)
--   ExceptT &lt;If (&lt;= 1 a@0) (Left ()) (Right {a@0})&gt;
--   </pre>
freshConstrained :: (GenSymConstrained spec a, MonadFresh m, MonadError e m, MonadUnion m) => e -> spec -> m (Union a)
($dmfreshConstrained) :: (GenSymConstrained spec a, GenSymSimpleConstrained spec a, MonadFresh m, MonadError e m, MonadUnion m) => e -> spec -> m (Union a)

-- | Class of types in which symbolic values can be generated with some
--   specification.
--   
--   See <a>GenSymSimple</a> for more details. The difference of this class
--   is that it allows constraints to be generated along with the
--   generation of symbolic values.
class Mergeable a => GenSymSimpleConstrained spec a

-- | Generates a symbolic value with the given specification.
--   
--   Constraint violations will throw an error in the monadic environment.
--   
--   <pre>
--   &gt;&gt;&gt; runFreshT (simpleFreshConstrained () (SymOrdUpperBound (1 :: SymInteger) ())) "a" :: ExceptT () Union SymInteger
--   ExceptT &lt;If (&lt;= 1 a@0) (Left ()) (Right a@0)&gt;
--   </pre>
simpleFreshConstrained :: (GenSymSimpleConstrained spec a, MonadFresh m, MonadError e m, MonadUnion m) => e -> spec -> m a

-- | Generates a symbolic value with the given specification, also place
--   the necessary constraints.
genSymConstrained :: (GenSymConstrained spec a, Mergeable e) => e -> spec -> Identifier -> ExceptT e Union (Union a)

-- | Generates a symbolic value with the given specification, also place
--   the necessary constraints.
genSymSimpleConstrained :: (GenSymSimpleConstrained spec a, Mergeable e) => e -> spec -> Identifier -> ExceptT e Union a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymConstrained</a>, while you can use this
--   <a>freshConstrained</a> implementation to implement
--   <a>GenSymConstrained</a> for your own types.
--   
--   This <a>freshConstrained</a> implementation is for the types that does
--   not need any specification. It will generate product types by
--   generating each fields with <tt>()</tt> as specification, and generate
--   all possible values for a sum type.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedFreshConstrainedNoSpec :: (Generic a, GenSymConstrainedNoSpec (Rep a), Mergeable a, MonadFresh m, MonadError e m, MonadUnion m) => e -> () -> m (Union a)

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimpleConstrained</a>, while you can use this
--   <a>simpleFreshConstrained</a> implementation to implement
--   <a>GenSymSimpleConstrained</a> fo your own types.
--   
--   This <a>simpleFreshConstrained</a> implementation is for the types
--   that does not need any specification. It will generate product types
--   by generating each fields with () as specification. It will not work
--   on sum types.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedSimpleFreshConstrainedNoSpec :: (Generic a, GenSymSimpleConstrainedNoSpec (Rep a), MonadFresh m, MonadError e m, MonadUnion m, Mergeable a) => e -> () -> m a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimpleConstrained</a>, while you can use this
--   <a>simpleFreshConstrained</a> implementation to implement
--   <a>GenSymSimpleConstrained</a> fo your own types.
--   
--   This <a>simpleFreshConstrained</a> implementation is for the types
--   that can be generated with a reference value of the same type.
--   
--   For sum types, it will generate the result with the same data
--   constructor. For product types, it will generate the result by
--   generating each field with the corresponding reference value.
--   
--   <b>Note:</b> <b>Can</b> be used on recursive types.
derivedSimpleFreshConstrainedSameShape :: (Generic a, GenSymConstrainedSameShape (Rep a), Mergeable a, MonadFresh m, MonadError e m, MonadUnion m) => e -> a -> m a

-- | Exclusive bound, generates the values with the specification, then
--   filters out the ones that are greater than or equal to the bound
data SymOrdUpperBound a spec
SymOrdUpperBound :: a -> spec -> SymOrdUpperBound a spec

-- | Inclusive bound, generates the values with the specification, then
--   filters out the ones that are less than the bound
data SymOrdLowerBound a spec
SymOrdLowerBound :: a -> spec -> SymOrdLowerBound a spec

-- | Left-inclusive, right-exclusive bound, generates the values with the
--   specification, then filters out the ones that are out-of-bound
data SymOrdBound a spec
SymOrdBound :: a -> a -> spec -> SymOrdBound a spec
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec a, Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec b) => Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec (a GHC.Internal.Generics.:*: b)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec a, Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec b, forall x. Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (a x), forall x. Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable (b x)) => Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec (a GHC.Internal.Generics.:+: b)
instance Grisette.Experimental.GenSymConstrained.GenSymConstrained () c => Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec (GHC.Internal.Generics.K1 i c)
instance Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec a => Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec (GHC.Internal.Generics.M1 i c a)
instance Grisette.Experimental.GenSymConstrained.GenSymConstrainedNoSpec GHC.Internal.Generics.U1
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape a, Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape b) => Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape (a GHC.Internal.Generics.:*: b)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape a, Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape b) => Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape (a GHC.Internal.Generics.:+: b)
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained c c => Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape (GHC.Internal.Generics.K1 i c)
instance Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape a => Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape (GHC.Internal.Generics.M1 i c a)
instance Grisette.Experimental.GenSymConstrained.GenSymConstrainedSameShape GHC.Internal.Generics.U1
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (GHC.Internal.Data.Either.Either aspec bspec) (GHC.Internal.Data.Either.Either a b)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (m (GHC.Internal.Data.Either.Either e a)) (m (GHC.Internal.Data.Either.Either e a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Control.Monad.Trans.Except.ExceptT e m a) (Control.Monad.Trans.Except.ExceptT e m a)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained GHC.Num.Integer.Integer [a]
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained a a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained [a] [a]
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained spec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Grisette.Internal.Core.Data.Class.GenSym.ListSpec spec) [a]
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (GHC.Internal.Maybe.Maybe aspec) (GHC.Internal.Maybe.Maybe a)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (m (GHC.Internal.Maybe.Maybe a)) (m (GHC.Internal.Maybe.Maybe a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Control.Monad.Trans.Maybe.MaybeT m a) (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained spec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Grisette.Internal.Core.Data.Class.GenSym.SimpleListSpec spec) [a]
instance Grisette.Experimental.GenSymConstrained.GenSymConstrained (Grisette.Experimental.GenSymConstrained.SymOrdBound GHC.Num.Integer.Integer ()) GHC.Num.Integer.Integer
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Grisette.Experimental.GenSymConstrained.SymOrdBound a spec) a
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Grisette.Experimental.GenSymConstrained.SymOrdLowerBound a spec) a
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (Grisette.Experimental.GenSymConstrained.SymOrdUpperBound a spec) a
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec) (a, b)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Experimental.GenSymConstrained.GenSymConstrained cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec, cspec) (a, b, c)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Experimental.GenSymConstrained.GenSymConstrained cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Experimental.GenSymConstrained.GenSymConstrained dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec, cspec, dspec) (a, b, c, d)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Experimental.GenSymConstrained.GenSymConstrained cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Experimental.GenSymConstrained.GenSymConstrained dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Experimental.GenSymConstrained.GenSymConstrained espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec, cspec, dspec, espec) (a, b, c, d, e)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Experimental.GenSymConstrained.GenSymConstrained cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Experimental.GenSymConstrained.GenSymConstrained dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Experimental.GenSymConstrained.GenSymConstrained espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Experimental.GenSymConstrained.GenSymConstrained fspec f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec, cspec, dspec, espec, fspec) (a, b, c, d, e, f)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Experimental.GenSymConstrained.GenSymConstrained cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Experimental.GenSymConstrained.GenSymConstrained dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Experimental.GenSymConstrained.GenSymConstrained espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Experimental.GenSymConstrained.GenSymConstrained fspec f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f, Grisette.Experimental.GenSymConstrained.GenSymConstrained gspec g, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable g) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec, cspec, dspec, espec, fspec, gspec) (a, b, c, d, e, f, g)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained bspec b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b, Grisette.Experimental.GenSymConstrained.GenSymConstrained cspec c, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable c, Grisette.Experimental.GenSymConstrained.GenSymConstrained dspec d, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable d, Grisette.Experimental.GenSymConstrained.GenSymConstrained espec e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Experimental.GenSymConstrained.GenSymConstrained fspec f, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable f, Grisette.Experimental.GenSymConstrained.GenSymConstrained gspec g, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable g, Grisette.Experimental.GenSymConstrained.GenSymConstrained hspec h, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable h) => Grisette.Experimental.GenSymConstrained.GenSymConstrained (aspec, bspec, cspec, dspec, espec, fspec, gspec, hspec) (a, b, c, d, e, f, g, h)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained () a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Experimental.GenSymConstrained.GenSymConstrained () b, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Experimental.GenSymConstrained.GenSymConstrained () (GHC.Internal.Data.Either.Either a b)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained aspec (GHC.Internal.Maybe.Maybe a)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained spec (m (GHC.Internal.Data.Either.Either a b)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Experimental.GenSymConstrained.GenSymConstrained spec (Control.Monad.Trans.Except.ExceptT a m b)
instance (Grisette.Experimental.GenSymConstrained.GenSymConstrained spec (m (GHC.Internal.Maybe.Maybe a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained spec (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSym spec a) => Grisette.Experimental.GenSymConstrained.GenSymConstrained spec a
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec b) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec (a GHC.Internal.Generics.:*: b)
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained () c => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec (GHC.Internal.Generics.K1 i c)
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec a => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec (GHC.Internal.Generics.M1 i c a)
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrainedNoSpec GHC.Internal.Generics.U1
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained a a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained b b) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (GHC.Internal.Data.Either.Either a b) (GHC.Internal.Data.Either.Either a b)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (m (GHC.Internal.Data.Either.Either e a)) (m (GHC.Internal.Data.Either.Either e a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable e, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (Control.Monad.Trans.Except.ExceptT e m a) (Control.Monad.Trans.Except.ExceptT e m a)
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained a a => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained [a] [a]
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (GHC.Internal.Maybe.Maybe aspec) (GHC.Internal.Maybe.Maybe a)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (m (GHC.Internal.Maybe.Maybe a)) (m (GHC.Internal.Maybe.Maybe a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (Control.Monad.Trans.Maybe.MaybeT m a) (Control.Monad.Trans.Maybe.MaybeT m a)
instance Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained spec a => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (Grisette.Internal.Core.Data.Class.GenSym.SimpleListSpec spec) [a]
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (Grisette.Experimental.GenSymConstrained.SymOrdBound a spec) a
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (Grisette.Experimental.GenSymConstrained.SymOrdLowerBound a spec) a
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.SymOrd.SymOrd a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (Grisette.Experimental.GenSymConstrained.SymOrdUpperBound a spec) a
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec) (a, b)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained cspec c) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec, cspec) (a, b, c)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained cspec c, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained dspec d) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec, cspec, dspec) (a, b, c, d)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained cspec c, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained dspec d, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained espec e) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec, cspec, dspec, espec) (a, b, c, d, e)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained cspec c, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained dspec d, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained espec e, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained fspec f) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec, cspec, dspec, espec, fspec) (a, b, c, d, e, f)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained cspec c, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained dspec d, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained espec e, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained fspec f, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained gspec g) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec, cspec, dspec, espec, fspec, gspec) (a, b, c, d, e, f, g)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained aspec a, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained bspec b, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained cspec c, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained dspec d, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained espec e, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained fspec f, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained gspec g, Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained hspec h) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained (aspec, bspec, cspec, dspec, espec, fspec, gspec, hspec) (a, b, c, d, e, f, g, h)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained spec (m (GHC.Internal.Data.Either.Either a b)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable b) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained spec (Control.Monad.Trans.Except.ExceptT a m b)
instance (Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained spec (m (GHC.Internal.Maybe.Maybe a)), Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable1 m, Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained spec (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Grisette.Internal.Internal.Decl.Core.Data.Class.Mergeable.Mergeable a, Grisette.Internal.Core.Data.Class.GenSym.GenSymSimple spec a) => Grisette.Experimental.GenSymConstrained.GenSymSimpleConstrained spec a


module Grisette.Experimental

-- | Class of types in which symbolic values can be generated with some
--   specification.
--   
--   See <a>GenSym</a> for more details. The difference of this class is
--   that it allows constraints to be generated along with the generation
--   of symbolic values.
class Mergeable a => GenSymConstrained spec a

-- | Generates a symbolic value with the given specification.
--   
--   Constraint violations will throw an error in the monadic environment.
--   
--   <pre>
--   &gt;&gt;&gt; runFreshT (freshConstrained () (SymOrdUpperBound (1 :: SymInteger) ())) "a" :: ExceptT () Union (Union SymInteger)
--   ExceptT &lt;If (&lt;= 1 a@0) (Left ()) (Right {a@0})&gt;
--   </pre>
freshConstrained :: (GenSymConstrained spec a, MonadFresh m, MonadError e m, MonadUnion m) => e -> spec -> m (Union a)
($dmfreshConstrained) :: (GenSymConstrained spec a, GenSymSimpleConstrained spec a, MonadFresh m, MonadError e m, MonadUnion m) => e -> spec -> m (Union a)

-- | Class of types in which symbolic values can be generated with some
--   specification.
--   
--   See <a>GenSymSimple</a> for more details. The difference of this class
--   is that it allows constraints to be generated along with the
--   generation of symbolic values.
class Mergeable a => GenSymSimpleConstrained spec a

-- | Generates a symbolic value with the given specification.
--   
--   Constraint violations will throw an error in the monadic environment.
--   
--   <pre>
--   &gt;&gt;&gt; runFreshT (simpleFreshConstrained () (SymOrdUpperBound (1 :: SymInteger) ())) "a" :: ExceptT () Union SymInteger
--   ExceptT &lt;If (&lt;= 1 a@0) (Left ()) (Right a@0)&gt;
--   </pre>
simpleFreshConstrained :: (GenSymSimpleConstrained spec a, MonadFresh m, MonadError e m, MonadUnion m) => e -> spec -> m a

-- | Generates a symbolic value with the given specification, also place
--   the necessary constraints.
genSymConstrained :: (GenSymConstrained spec a, Mergeable e) => e -> spec -> Identifier -> ExceptT e Union (Union a)

-- | Generates a symbolic value with the given specification, also place
--   the necessary constraints.
genSymSimpleConstrained :: (GenSymSimpleConstrained spec a, Mergeable e) => e -> spec -> Identifier -> ExceptT e Union a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimpleConstrained</a>, while you can use this
--   <a>simpleFreshConstrained</a> implementation to implement
--   <a>GenSymSimpleConstrained</a> fo your own types.
--   
--   This <a>simpleFreshConstrained</a> implementation is for the types
--   that does not need any specification. It will generate product types
--   by generating each fields with () as specification. It will not work
--   on sum types.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedSimpleFreshConstrainedNoSpec :: (Generic a, GenSymSimpleConstrainedNoSpec (Rep a), MonadFresh m, MonadError e m, MonadUnion m, Mergeable a) => e -> () -> m a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimpleConstrained</a>, while you can use this
--   <a>simpleFreshConstrained</a> implementation to implement
--   <a>GenSymSimpleConstrained</a> fo your own types.
--   
--   This <a>simpleFreshConstrained</a> implementation is for the types
--   that can be generated with a reference value of the same type.
--   
--   For sum types, it will generate the result with the same data
--   constructor. For product types, it will generate the result by
--   generating each field with the corresponding reference value.
--   
--   <b>Note:</b> <b>Can</b> be used on recursive types.
derivedSimpleFreshConstrainedSameShape :: (Generic a, GenSymConstrainedSameShape (Rep a), Mergeable a, MonadFresh m, MonadError e m, MonadUnion m) => e -> a -> m a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymConstrained</a>, while you can use this
--   <a>freshConstrained</a> implementation to implement
--   <a>GenSymConstrained</a> for your own types.
--   
--   This <a>freshConstrained</a> implementation is for the types that does
--   not need any specification. It will generate product types by
--   generating each fields with <tt>()</tt> as specification, and generate
--   all possible values for a sum type.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedFreshConstrainedNoSpec :: (Generic a, GenSymConstrainedNoSpec (Rep a), Mergeable a, MonadFresh m, MonadError e m, MonadUnion m) => e -> () -> m (Union a)

-- | Exclusive bound, generates the values with the specification, then
--   filters out the ones that are greater than or equal to the bound
data SymOrdUpperBound a spec
SymOrdUpperBound :: a -> spec -> SymOrdUpperBound a spec

-- | Inclusive bound, generates the values with the specification, then
--   filters out the ones that are less than the bound
data SymOrdLowerBound a spec
SymOrdLowerBound :: a -> spec -> SymOrdLowerBound a spec

-- | Left-inclusive, right-exclusive bound, generates the values with the
--   specification, then filters out the ones that are out-of-bound
data SymOrdBound a spec
SymOrdBound :: a -> a -> spec -> SymOrdBound a spec


module Grisette.Core

-- | S-expression data type. Used for symbol metadata.
data SExpr
Atom :: Text -> SExpr
List :: [SExpr] -> SExpr
NumberAtom :: Integer -> SExpr
BoolAtom :: Bool -> SExpr

-- | Show an S-expression with specific parentheses.
showsSExprWithParens :: Char -> Char -> SExpr -> ShowS

-- | Get the file location of the splice.
fileLocation :: SpliceQ SExpr

-- | Identifier type used for <a>GenSym</a>
--   
--   The constructor is hidden intentionally. You can construct an
--   identifier by:
--   
--   <ul>
--   <li>a raw identifier</li>
--   </ul>
--   
--   The following two expressions will refer to the same identifier (the
--   solver won't distinguish them and would assign the same value to
--   them). The user may need to use unique names to avoid unintentional
--   identifier collision.
--   
--   <pre>
--   &gt;&gt;&gt; identifier "a"
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "a" :: Identifier -- available when OverloadedStrings is enabled
--   a
--   </pre>
--   
--   <ul>
--   <li>bundle the identifier with some user provided metadata</li>
--   </ul>
--   
--   Identifiers created with different name or different additional
--   information will not be the same.
--   
--   <pre>
--   &gt;&gt;&gt; withMetadata "a" (NumberAtom 1)
--   a:1
--   </pre>
--   
--   <ul>
--   <li>bundle the calling file location with the identifier to ensure
--   global uniqueness</li>
--   </ul>
--   
--   Identifiers created at different locations will not be the same. The
--   identifiers created at the same location will be the same.
--   
--   <pre>
--   &gt;&gt;&gt; $$(withLocation "a") -- a sample result could be "a:[grisette-file-location &lt;interactive&gt; 18 (4 18)]"
--   a:[grisette-file-location &lt;interactive&gt;...]
--   </pre>
data Identifier
Identifier :: Text -> SExpr -> Identifier
[baseIdent] :: Identifier -> Text
[metadata] :: Identifier -> SExpr

-- | Symbol types for a symbolic variable.
--   
--   The symbols can be indexed with an integer.
data Symbol
[SimpleSymbol] :: Identifier -> Symbol
[IndexedSymbol] :: Identifier -> Int -> Symbol

-- | Simple identifier. The same identifier refers to the same symbolic
--   variable in the whole program.
--   
--   The user may need to use unique identifiers to avoid unintentional
--   identifier collision.
identifier :: Text -> Identifier

-- | A type class for embedding a type into a metadata represented as an
--   S-expression.
class AsMetadata a
asMetadata :: AsMetadata a => a -> SExpr
fromMetadata :: AsMetadata a => SExpr -> Maybe a

-- | A pattern for extracting a value from a metadata represented as an
--   S-expression.
pattern Metadata :: AsMetadata a => a -> SExpr

-- | Identifier with extra metadata.
--   
--   The same identifier with the same metadata refers to the same symbolic
--   variable in the whole program.
--   
--   The user may need to use unique identifiers or additional metadata to
--   avoid unintentional identifier collision.
withMetadata :: AsMetadata a => Text -> a -> Identifier

-- | Modify the metadata of an identifier.
mapMetadata :: AsMetadata a => (SExpr -> a) -> Identifier -> Identifier

-- | Identifier with the file location.
withLocation :: Text -> SpliceQ Identifier

-- | Get a globally unique identifier within the <a>IO</a> monad.
uniqueIdentifier :: Text -> IO Identifier

-- | Create a simple symbol.
simple :: Identifier -> Symbol

-- | Create an indexed symbol.
indexed :: Identifier -> Int -> Symbol

-- | Get the identifier of a symbol.
symbolIdentifier :: Symbol -> Identifier

-- | Modify the identifier of a symbol.
mapIdentifier :: (Identifier -> Identifier) -> Symbol -> Symbol

-- | The class defines the creation and pattern matching of solvable type
--   values.
class IsString t => Solvable c t | t -> c

-- | Wrap a concrete value in a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; con True :: SymBool
--   true
--   </pre>
con :: Solvable c t => c -> t

-- | Extract the concrete value from a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; conView (con True :: SymBool)
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conView (ssym "a" :: SymBool)
--   Nothing
--   </pre>
conView :: Solvable c t => t -> Maybe c

-- | Generate symbolic constants.
--   
--   Two symbolic constants with the same symbol are the same symbolic
--   constant, and will always be assigned with the same value by the
--   solver.
--   
--   In the examples, we use <a>AsKey</a> to check if two symbolic
--   constants are the same term, concretely.
--   
--   <pre>
--   &gt;&gt;&gt; sym "a" :: SymBool
--   a
--   
--   &gt;&gt;&gt; AsKey (sym "a" :: SymBool) == AsKey (sym "a" :: SymBool)
--   True
--   
--   &gt;&gt;&gt; AsKey (sym "a" :: SymBool) == AsKey (sym "b")
--   False
--   
--   &gt;&gt;&gt; (sym "a" :: SymBool) .&amp;&amp; sym "a"
--   a
--   
--   &gt;&gt;&gt; AsKey (sym "a" :: SymBool) == AsKey (isym "a" 1)
--   False
--   </pre>
sym :: Solvable c t => Symbol -> t

-- | Generate simply-named symbolic constants.
--   
--   Two symbolic constants with the same identifier are the same symbolic
--   constant, and will always be assigned with the same value by the
--   solver.
--   
--   In the examples, we use <a>AsKey</a> to check if two symbolic
--   constants are the same term, concretely.
--   
--   <pre>
--   &gt;&gt;&gt; ssym "a" :: SymBool
--   a
--   
--   &gt;&gt;&gt; AsKey (ssym "a" :: SymBool) == AsKey (ssym "a" :: SymBool)
--   True
--   
--   &gt;&gt;&gt; AsKey (ssym "a" :: SymBool) == AsKey (ssym "b")
--   False
--   
--   &gt;&gt;&gt; (ssym "a" :: SymBool) .&amp;&amp; ssym "a"
--   a
--   </pre>
ssym :: Solvable c t => Identifier -> t

-- | Generate indexed symbolic constants.
--   
--   Two symbolic constants with the same identifier but different indices
--   are not the same symbolic constants.
--   
--   <pre>
--   &gt;&gt;&gt; isym "a" 1 :: SymBool
--   a@1
--   </pre>
isym :: Solvable c t => Identifier -> Int -> t

-- | Extract the concrete value from a solvable value with <a>conView</a>.
--   
--   <pre>
--   &gt;&gt;&gt; case con True :: SymBool of Con v -&gt; v
--   True
--   </pre>
pattern Con :: Solvable c t => c -> t

-- | Generate simply-named symbolic variables. The file location will be
--   attached to the identifier.
--   
--   <pre>
--   &gt;&gt;&gt; $$(slocsym "a") :: SymBool
--   a:[grisette-file-location &lt;interactive&gt;...]
--   </pre>
--   
--   Calling <a>slocsym</a> with the same name at different location will
--   always generate different symbolic constants. Calling <a>slocsym</a>
--   at the same location for multiple times will generate the same
--   symbolic constants.
--   
--   In the examples, we use <a>AsKey</a> to check if two symbolic
--   constants are the same term, concretely.
--   
--   <pre>
--   &gt;&gt;&gt; AsKey ($$(slocsym "a") :: SymBool) == AsKey ($$(slocsym "a") :: SymBool)
--   False
--   
--   &gt;&gt;&gt; let f _ = $$(slocsym "a") :: SymBool
--   
--   &gt;&gt;&gt; AsKey (f ()) == AsKey (f ())
--   True
--   </pre>
slocsym :: Solvable c s => Text -> SpliceQ s

-- | Generate indexed symbolic variables. The file location will be
--   attached to the identifier.
--   
--   <pre>
--   &gt;&gt;&gt; $$(ilocsym "a" 1) :: SymBool
--   a:[grisette-file-location &lt;interactive&gt;...]@1
--   </pre>
--   
--   Calling <a>ilocsym</a> with the same name and index at different
--   location will always generate different symbolic constants. Calling
--   <a>slocsym</a> at the same location for multiple times will generate
--   the same symbolic constants.
ilocsym :: Solvable c s => Text -> Int -> SpliceQ s

-- | Symbolic logical operators for symbolic booleans.
--   
--   <pre>
--   &gt;&gt;&gt; let t = true :: SymBool
--   
--   &gt;&gt;&gt; let f = false :: SymBool
--   
--   &gt;&gt;&gt; let a = "a" :: SymBool
--   
--   &gt;&gt;&gt; let b = "b" :: SymBool
--   
--   &gt;&gt;&gt; t .|| f
--   true
--   
--   &gt;&gt;&gt; a .|| t
--   true
--   
--   &gt;&gt;&gt; a .|| f
--   a
--   
--   &gt;&gt;&gt; a .|| b
--   (|| a b)
--   
--   &gt;&gt;&gt; t .&amp;&amp; f
--   false
--   
--   &gt;&gt;&gt; a .&amp;&amp; t
--   a
--   
--   &gt;&gt;&gt; a .&amp;&amp; f
--   false
--   
--   &gt;&gt;&gt; a .&amp;&amp; b
--   (&amp;&amp; a b)
--   
--   &gt;&gt;&gt; symNot t
--   false
--   
--   &gt;&gt;&gt; symNot f
--   true
--   
--   &gt;&gt;&gt; symNot a
--   (! a)
--   
--   &gt;&gt;&gt; t `symXor` f
--   true
--   
--   &gt;&gt;&gt; t `symXor` t
--   false
--   
--   &gt;&gt;&gt; a `symXor` t
--   (! a)
--   
--   &gt;&gt;&gt; a `symXor` f
--   a
--   
--   &gt;&gt;&gt; a `symXor` b
--   (|| (&amp;&amp; (! a) b) (&amp;&amp; a (! b)))
--   </pre>
class LogicalOp b

-- | Constant true
true :: LogicalOp b => b

-- | Constant false
false :: LogicalOp b => b

-- | Symbolic disjunction
(.||) :: LogicalOp b => b -> b -> b

-- | Symbolic conjunction
(.&&) :: LogicalOp b => b -> b -> b

-- | Symbolic negation
symNot :: LogicalOp b => b -> b

-- | Symbolic exclusive disjunction
symXor :: LogicalOp b => b -> b -> b

-- | Symbolic implication
symImplies :: LogicalOp b => b -> b -> b
infixr 2 .||
infixr 3 .&&

-- | ITE operator for solvable (see <a>Grisette.Core#g:solvable</a>)s,
--   including symbolic boolean, integer, etc.
--   
--   <pre>
--   &gt;&gt;&gt; let a = "a" :: SymBool
--   
--   &gt;&gt;&gt; let b = "b" :: SymBool
--   
--   &gt;&gt;&gt; let c = "c" :: SymBool
--   
--   &gt;&gt;&gt; symIte a b c
--   (ite a b c)
--   </pre>
class ITEOp v

-- | Symbolic if-then-else.
symIte :: ITEOp v => SymBool -> v -> v -> v

-- | Symbolic equality. Note that we can't use Haskell's <a>Eq</a> class
--   since symbolic comparison won't necessarily return a concrete
--   <a>Bool</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; let a = 1 :: SymInteger
--   
--   &gt;&gt;&gt; let b = 2 :: SymInteger
--   
--   &gt;&gt;&gt; a .== b
--   false
--   
--   &gt;&gt;&gt; a ./= b
--   true
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = "a" :: SymInteger
--   
--   &gt;&gt;&gt; let b = "b" :: SymInteger
--   
--   &gt;&gt;&gt; a .== b
--   (= a b)
--   
--   &gt;&gt;&gt; a ./= b
--   (! (= a b))
--   </pre>
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving SymEq via (Default X)
--   </pre>
class SymEq a
(.==) :: SymEq a => a -> a -> SymBool
(./=) :: SymEq a => a -> a -> SymBool

-- | Check if all elements in a list are distinct, under the symbolic
--   equality semantics.
symDistinct :: SymEq a => [a] -> SymBool
infix 4 .==
infix 4 ./=

-- | Lifting of the <a>SymEq</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftSymEq (.==)</tt> should be equivalent to <tt>(.==)</tt>, under
--   the symbolic semantics.
--   
--   This class therefore represents the generalization of <a>SymEq</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class forall a. SymEq a => SymEq f a => SymEq1 (f :: Type -> Type)

-- | Lift a symbolic equality test through the type constructor.
--   
--   The function will usually be applied to an symbolic equality function,
--   but the more general type ensures that the implementation uses it to
--   compare elements of the first container with elements of the second.
liftSymEq :: SymEq1 f => (a -> b -> SymBool) -> f a -> f b -> SymBool

-- | Lift the standard <tt>(<a>.==</a>)</tt> function through the type
--   constructor.
symEq1 :: (SymEq a, SymEq1 f) => f a -> f a -> SymBool

-- | Lifting of the <a>SymEq</a> class to binary type constructors.
class forall a. SymEq a => SymEq1 f a => SymEq2 (f :: Type -> Type -> Type)

-- | Lift symbolic equality tests through the type constructor.
--   
--   The function will usually be applied to an symbolic equality function,
--   but the more general type ensures that the implementation uses it to
--   compare elements of the first container with elements of the second.
liftSymEq2 :: SymEq2 f => (a -> b -> SymBool) -> (c -> d -> SymBool) -> f a c -> f b d -> SymBool

-- | Lift the standard <tt>(<a>.==</a>)</tt> function through the type
--   constructor.
symEq2 :: (SymEq a, SymEq b, SymEq2 f) => f a b -> f a b -> SymBool

-- | Check if all elements in a list are distinct.
--   
--   Note that empty or singleton lists are always distinct.
--   
--   <pre>
--   &gt;&gt;&gt; distinct []
--   True
--   
--   &gt;&gt;&gt; distinct [1]
--   True
--   
--   &gt;&gt;&gt; distinct [1, 2, 3]
--   True
--   
--   &gt;&gt;&gt; distinct [1, 2, 2]
--   False
--   </pre>
distinct :: Eq a => [a] -> Bool

-- | Symbolic total order. Note that we can't use Haskell's <a>Ord</a>
--   class since symbolic comparison won't necessarily return a concrete
--   <a>Bool</a> or <a>Ordering</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; let a = 1 :: SymInteger
--   
--   &gt;&gt;&gt; let b = 2 :: SymInteger
--   
--   &gt;&gt;&gt; a .&lt; b
--   true
--   
--   &gt;&gt;&gt; a .&gt; b
--   false
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = "a" :: SymInteger
--   
--   &gt;&gt;&gt; let b = "b" :: SymInteger
--   
--   &gt;&gt;&gt; a .&lt; b
--   (&lt; a b)
--   
--   &gt;&gt;&gt; a .&lt;= b
--   (&lt;= a b)
--   
--   &gt;&gt;&gt; a .&gt; b
--   (&lt; b a)
--   
--   &gt;&gt;&gt; a .&gt;= b
--   (&lt;= b a)
--   </pre>
--   
--   For <a>symCompare</a>, <a>Ordering</a> is not a solvable type, and the
--   result would be wrapped in a union-like monad. See <a>Union</a> and
--   <a>PlainUnion</a> for more information.
--   
--   <pre>
--   &gt;&gt;&gt; a `symCompare` b :: Union Ordering
--   {If (&lt; a b) LT (If (= a b) EQ GT)}
--   </pre>
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving SymOrd via (Default X)
--   </pre>
class SymEq a => SymOrd a
(.<) :: SymOrd a => a -> a -> SymBool
(.<=) :: SymOrd a => a -> a -> SymBool
(.>) :: SymOrd a => a -> a -> SymBool
(.>=) :: SymOrd a => a -> a -> SymBool
symCompare :: SymOrd a => a -> a -> Union Ordering
infix 4 .<
infix 4 .<=
infix 4 .>
infix 4 .>=

-- | Lifting of the <a>SymOrd</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftSymCompare symCompare</tt> should be equivalent to
--   <tt>symCompare</tt>, under the symbolic semantics.
--   
--   This class therefore represents the generalization of <a>SymOrd</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class (SymEq1 f, forall a. SymOrd a => SymOrd f a) => SymOrd1 (f :: Type -> Type)

-- | Lift a <a>symCompare</a> function through the type constructor.
--   
--   The function will usually be applied to an symbolic comparison
--   function, but the more general type ensures that the implementation
--   uses it to compare elements of the first container with elements of
--   the second.
liftSymCompare :: SymOrd1 f => (a -> b -> Union Ordering) -> f a -> f b -> Union Ordering

-- | Lift the standard <a>symCompare</a> function to binary type
--   constructors.
symCompare1 :: (SymOrd1 f, SymOrd a) => f a -> f a -> Union Ordering

-- | Lifting of the <a>SymOrd</a> class to binary type constructors.
class (SymEq2 f, forall a. SymOrd a => SymOrd1 f a) => SymOrd2 (f :: Type -> Type -> Type)

-- | Lift a <a>symCompare</a> function through the type constructor.
--   
--   The function will usually be applied to an symbolic comparison
--   function, but the more general type ensures that the implementation
--   uses it to compare elements of the first container with elements of
--   the second.
liftSymCompare2 :: SymOrd2 f => (a -> b -> Union Ordering) -> (c -> d -> Union Ordering) -> f a c -> f b d -> Union Ordering

-- | Lift the standard <a>symCompare</a> function through the type
--   constructors.
symCompare2 :: (SymOrd2 f, SymOrd a, SymOrd b) => f a b -> f a b -> Union Ordering

-- | Symbolic maximum.
symMax :: (SymOrd a, ITEOp a) => a -> a -> a

-- | Symbolic minimum.
symMin :: (SymOrd a, ITEOp a) => a -> a -> a

-- | Symbolic maximum, with a union-like monad.
mrgMax :: (SymOrd a, Mergeable a, SymBranching m, Applicative m) => a -> a -> m a

-- | Symbolic minimum, with a union-like monad.
mrgMin :: (SymOrd a, Mergeable a, SymBranching m, Applicative m) => a -> a -> m a

-- | Bit vector operations. Including concatenation (<a>bvConcat</a>),
--   extension (<a>bvZext</a>, <a>bvSext</a>, <a>bvExt</a>), and selection
--   (<a>bvSelect</a>).
class BV bv

-- | Concatenation of two bit vectors.
--   
--   <pre>
--   &gt;&gt;&gt; bvConcat (SomeSymWordN (0b101 :: SymWordN 3)) (SomeSymWordN (0b010 :: SymWordN 3))
--   0b101010
--   </pre>
bvConcat :: BV bv => bv -> bv -> bv

-- | Zero extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; bvZext 6 (SomeSymWordN (0b101 :: SymWordN 3))
--   0b000101
--   </pre>
bvZext :: BV bv => Int -> bv -> bv

-- | Sign extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; bvSext 6 (SomeSymWordN (0b101 :: SymWordN 3))
--   0b111101
--   </pre>
bvSext :: BV bv => Int -> bv -> bv

-- | Extension of a bit vector. Signedness is determined by the input bit
--   vector type.
--   
--   <pre>
--   &gt;&gt;&gt; bvExt 6 (SomeSymIntN (0b101 :: SymIntN 3))
--   0b111101
--   
--   &gt;&gt;&gt; bvExt 6 (SomeSymIntN (0b001 :: SymIntN 3))
--   0b000001
--   
--   &gt;&gt;&gt; bvExt 6 (SomeSymWordN (0b101 :: SymWordN 3))
--   0b000101
--   
--   &gt;&gt;&gt; bvExt 6 (SomeSymWordN (0b001 :: SymWordN 3))
--   0b000001
--   </pre>
bvExt :: BV bv => Int -> bv -> bv

-- | Slicing out a smaller bit vector from a larger one, selecting a slice
--   with width <tt>w</tt> starting from index <tt>ix</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; bvSelect 1 3 (SomeSymIntN (0b001010 :: SymIntN 6))
--   0b101
--   </pre>
bvSelect :: BV bv => Int -> Int -> bv -> bv

-- | Create a bit vector from an integer. The bit-width is the first
--   argument, which should not be zero.
--   
--   <pre>
--   &gt;&gt;&gt; bv 12 21 :: SomeSymIntN
--   0x015
--   </pre>
bv :: (BV bv, Integral a) => Int -> a -> bv

-- | Slicing out a smaller bit vector from a larger one, extract a slice
--   from bit <tt>i</tt> down to <tt>j</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; bvExtract 4 2 (SomeSymIntN (0b010100 :: SymIntN 6))
--   0b101
--   </pre>
bvExtract :: BV bv => Int -> Int -> bv -> bv

-- | Sized bit vector operations. Including concatenation
--   (<a>sizedBVConcat</a>), extension (<a>sizedBVZext</a>,
--   <a>sizedBVSext</a>, <a>sizedBVExt</a>), and selection
--   (<a>sizedBVSelect</a>).
class SizedBV (bv :: Nat -> Type)

-- | Concatenation of two bit vectors.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVConcat (0b101 :: SymIntN 3) (0b010 :: SymIntN 3)
--   0b101010
--   </pre>
sizedBVConcat :: forall (l :: Nat) (r :: Nat). (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, 1 <= r) => bv l -> bv r -> bv (l + r)

-- | Zero extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVZext (Proxy @6) (0b101 :: SymIntN 3)
--   0b000101
--   </pre>
sizedBVZext :: forall (l :: Nat) (r :: Nat) proxy. (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, KnownNat r, l <= r) => proxy r -> bv l -> bv r

-- | Signed extension of a bit vector.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVSext (Proxy @6) (0b101 :: SymIntN 3)
--   0b111101
--   </pre>
sizedBVSext :: forall (l :: Nat) (r :: Nat) proxy. (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, KnownNat r, l <= r) => proxy r -> bv l -> bv r

-- | Extension of a bit vector. Signedness is determined by the input bit
--   vector type.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: SymIntN 3)
--   0b111101
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b001 :: SymIntN 3)
--   0b000001
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b101 :: SymWordN 3)
--   0b000101
--   
--   &gt;&gt;&gt; sizedBVExt (Proxy @6) (0b001 :: SymWordN 3)
--   0b000001
--   </pre>
sizedBVExt :: forall (l :: Nat) (r :: Nat) proxy. (SizedBV bv, KnownNat l, KnownNat r, 1 <= l, KnownNat r, l <= r) => proxy r -> bv l -> bv r

-- | Slicing out a smaller bit vector from a larger one, selecting a slice
--   with width <tt>w</tt> starting from index <tt>ix</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVSelect (Proxy @2) (Proxy @3) (con 0b010100 :: SymIntN 6)
--   0b101
--   </pre>
sizedBVSelect :: forall (n :: Nat) (ix :: Nat) (w :: Nat) p q. (SizedBV bv, KnownNat n, KnownNat ix, KnownNat w, 1 <= n, 1 <= w, (ix + w) <= n) => p ix -> q w -> bv n -> bv w
sizedBVFromIntegral :: forall a (n :: Nat). (SizedBV bv, Integral a, KnownNat n, 1 <= n) => a -> bv n
($dmsizedBVFromIntegral) :: forall (n :: Nat) a. (SizedBV bv, Num (bv n), Integral a, KnownNat n, 1 <= n) => a -> bv n

-- | Slicing out a smaller bit vector from a larger one, extract a slice
--   from bit <tt>i</tt> down to <tt>j</tt>.
--   
--   The least significant bit is indexed as 0.
--   
--   <pre>
--   &gt;&gt;&gt; sizedBVExtract (Proxy @4) (Proxy @2) (con 0b010100 :: SymIntN 6)
--   0b101
--   </pre>
sizedBVExtract :: forall p (i :: Nat) q (j :: Nat) (n :: Nat) bv. (SizedBV bv, KnownNat n, KnownNat i, KnownNat j, 1 <= n, (i + 1) <= n, j <= i) => p i -> q j -> bv n -> bv ((i - j) + 1)

-- | A class for shifting operations.
--   
--   The <a>symShift</a> function shifts the value to the left if the shift
--   amount is positive, and to the right if the shift amount is negative.
--   If shifting beyond the bit width of the value, the result is the same
--   as shifting with the bit width.
--   
--   The <a>symShiftNegated</a> function shifts the value to the right if
--   the shift amount is positive, and to the left if the shift amount is
--   negative. This function is introduced to handle the asymmetry of the
--   range of values.
class Bits a => SymShift a
symShift :: SymShift a => a -> a -> a
symShiftNegated :: SymShift a => a -> a -> a

-- | Safe version for <a>shiftL</a> or <a>shiftR</a>.
--   
--   The <a>safeSymShiftL</a> and <a>safeSymShiftR</a> are defined for all
--   non-negative shift amounts.
--   
--   <ul>
--   <li>Shifting by negative shift amounts is an error.</li>
--   <li>The result is defined to be 0 when shifting left by more than or
--   equal to the bit size of the number.</li>
--   <li>The result is defined to be 0 when shifting right by more than or
--   equal to the bit size of the number and the number is unsigned or
--   signed non-negative.</li>
--   <li>The result is defined to be -1 when shifting right by more than or
--   equal to the bit size of the number and the number is signed
--   negative.</li>
--   </ul>
--   
--   The <a>safeSymStrictShiftL</a> and <a>safeSymStrictShiftR</a> are
--   defined for all non-negative shift amounts that is less than the bit
--   size. Shifting by more than or equal to the bit size is an error,
--   otherwise they are the same as the non-strict versions.
class (MonadError e m, TryMerge m, Mergeable a) => SafeSymShift e a (m :: Type -> Type)
safeSymShiftL :: SafeSymShift e a m => a -> a -> m a
safeSymShiftR :: SafeSymShift e a m => a -> a -> m a
safeSymStrictShiftL :: SafeSymShift e a m => a -> a -> m a
safeSymStrictShiftR :: SafeSymShift e a m => a -> a -> m a

-- | The <a>symRotate</a> is similar to <a>rotate</a>, but accepts the type
--   itself instead of <a>Int</a> for the rotate amount. The function works
--   on all inputs, including the rotate amounts that are beyond the bit
--   width of the value.
--   
--   The <a>symRotateNegated</a> function rotates to the opposite direction
--   of <a>symRotate</a>. This function is introduced to handle the
--   asymmetry of the range of values.
class Bits a => SymRotate a
symRotate :: SymRotate a => a -> a -> a
symRotateNegated :: SymRotate a => a -> a -> a

-- | Safe rotation operations. The operators will reject negative shift
--   amounts.
class (MonadError e m, TryMerge m, Mergeable a) => SafeSymRotate e a (m :: Type -> Type)
safeSymRotateL :: SafeSymRotate e a m => a -> a -> m a
safeSymRotateR :: SafeSymRotate e a m => a -> a -> m a

-- | Convert values between signed and unsigned.
class SignConversion ubv sbv | ubv -> sbv, sbv -> ubv

-- | Convert unsigned value to the corresponding signed value.
toSigned :: SignConversion ubv sbv => ubv -> sbv

-- | Convert signed value to the corresponding unsigned value.
toUnsigned :: SignConversion ubv sbv => sbv -> ubv

-- | Extract the least significant bit of a concrete value.
lsb :: Bits a => a -> Bool

-- | Extract the most significant bit of a concrete value.
msb :: FiniteBits a => a -> Bool

-- | Set a bit in a concrete value to a specific value.
setBitTo :: Bits a => a -> Int -> Bool -> a

-- | Bit-blast a concrete value into a list of concrete bits. The first
--   element in the resulting list corresponds to the least significant
--   bit.
bitBlast :: FiniteBits a => a -> [Bool]

-- | Type class for assembling concrete bits to a bit-vector.
class FiniteBits a => FromBits a

-- | Assembling concrete bits to a bit-vector. The first boolean value in
--   the list corresponding to the least signification value.
fromBits :: FromBits a => [Bool] -> a

-- | A class for symbolic finite bit operations.
class (FiniteBits a, ITEOp a) => SymFiniteBits a

-- | Test a symbolic bit in a symbolic bit-vector.
symTestBit :: SymFiniteBits a => a -> Int -> SymBool

-- | Set a bit in a symbolic value to a specific value.
symSetBitTo :: SymFiniteBits a => a -> Int -> SymBool -> a

-- | Assembling symbolic bits to a symbolic bit-vector. The first symbolic
--   boolean value in the list corresponding to the least signification
--   value.
symFromBits :: SymFiniteBits a => [SymBool] -> a

-- | Bit-blast a symbolic value into a list of symbolic bits. The first
--   element in the resulting list corresponds to the least significant
--   bit.
symBitBlast :: SymFiniteBits a => a -> [SymBool]

-- | Extract the least significant bit of a symbolic value.
symLsb :: SymFiniteBits a => a -> SymBool

-- | Extract the most significant bit of a symbolic value.
symMsb :: SymFiniteBits a => a -> SymBool

-- | Count the number of set bits in a symbolic value.
symPopCount :: (Num a, ITEOp a, SymFiniteBits a) => a -> a

-- | Count the number of leading zeros in a symbolic value.
symCountLeadingZeros :: (Num a, ITEOp a, SymFiniteBits a) => a -> a

-- | Count the number of trailing zeros in a symbolic value.
symCountTrailingZeros :: (Num a, ITEOp a, SymFiniteBits a) => a -> a

-- | Safe division handling with default values returned on exception.
class DivOr a

-- | Safe <a>div</a> with default value returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; divOr "d" "a" "b" :: SymInteger
--   (ite (= b 0) d (div a b))
--   </pre>
divOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>mod</a> with default value returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; modOr "d" "a" "b" :: SymInteger
--   (ite (= b 0) d (mod a b))
--   </pre>
modOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>divMod</a> with default value returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; divModOr ("d", "m") "a" "b" :: (SymInteger, SymInteger)
--   ((ite (= b 0) d (div a b)),(ite (= b 0) m (mod a b)))
--   </pre>
divModOr :: DivOr a => (a, a) -> a -> a -> (a, a)

-- | Safe <a>quot</a> with default value returned on exception.
quotOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>rem</a> with default value returned on exception.
remOr :: DivOr a => a -> a -> a -> a

-- | Safe <a>quotRem</a> with default value returned on exception.
quotRemOr :: DivOr a => (a, a) -> a -> a -> (a, a)

-- | Safe <a>div</a> with 0 returned on exception.
divOrZero :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>mod</a> with dividend returned on exception.
modOrDividend :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>quot</a> with 0 returned on exception.
quotOrZero :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>rem</a> with dividend returned on exception.
remOrDividend :: (DivOr a, Num a) => a -> a -> a

-- | Safe <a>divMod</a> with 0 returned on exception.
divModOrZeroDividend :: (DivOr a, Num a) => a -> a -> (a, a)

-- | Safe <a>quotRem</a> with 0 returned on exception.
quotRemOrZeroDividend :: (DivOr a, Num a) => a -> a -> (a, a)

-- | Safe division with monadic error handling in multi-path execution.
--   These procedures throw an exception when the divisor is zero. The
--   result should be able to handle errors with <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a, DivOr a) => SafeDiv e a (m :: Type -> Type)

-- | Safe <a>div</a> with monadic error handling in multi-path execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv "a" "b" :: ExceptT ArithException Union SymInteger
--   ExceptT {If (= b 0) (Left divide by zero) (Right (div a b))}
--   </pre>
safeDiv :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>mod</a> with monadic error handling in multi-path execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeMod "a" "b" :: ExceptT ArithException Union SymInteger
--   ExceptT {If (= b 0) (Left divide by zero) (Right (mod a b))}
--   </pre>
safeMod :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>divMod</a> with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeDivMod "a" "b" :: ExceptT ArithException Union (SymInteger, SymInteger)
--   ExceptT {If (= b 0) (Left divide by zero) (Right ((div a b),(mod a b)))}
--   </pre>
safeDivMod :: SafeDiv e a m => a -> a -> m (a, a)

-- | Safe <a>quot</a> with monadic error handling in multi-path execution.
safeQuot :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>rem</a> with monadic error handling in multi-path execution.
safeRem :: SafeDiv e a m => a -> a -> m a

-- | Safe <a>quotRem</a> with monadic error handling in multi-path
--   execution.
safeQuotRem :: SafeDiv e a m => a -> a -> m (a, a)

-- | Safe division with monadic error handling in multi-path execution.
--   These procedures throw an exception when overflow or underflow
--   happens. The result should be able to handle errors with
--   <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a) => SafeLinearArith e a (m :: Type -> Type)

-- | Safe <a>+</a> with monadic error handling in multi-path execution.
--   Overflows or underflows are treated as errors.
--   
--   <pre>
--   &gt;&gt;&gt; safeAdd (ssym "a") (ssym "b") :: ExceptT ArithException Union SymInteger
--   ExceptT {Right (+ a b)}
--   
--   &gt;&gt;&gt; safeAdd (ssym "a") (ssym "b") :: ExceptT ArithException Union (SymIntN 4)
--   ExceptT {If (ite (&lt; 0x0 a) (&amp;&amp; (&lt; 0x0 b) (&lt; (+ a b) 0x0)) (&amp;&amp; (&lt; a 0x0) (&amp;&amp; (&lt; b 0x0) (&lt;= 0x0 (+ a b))))) (If (&lt; 0x0 a) (Left arithmetic overflow) (Left arithmetic underflow)) (Right (+ a b))}
--   </pre>
safeAdd :: SafeLinearArith e a m => a -> a -> m a

-- | Safe <a>negate</a> with monadic error handling in multi-path
--   execution. Overflows or underflows are treated as errors.
--   
--   <pre>
--   &gt;&gt;&gt; safeNeg (ssym "a") :: ExceptT ArithException Union SymInteger
--   ExceptT {Right (- a)}
--   
--   &gt;&gt;&gt; safeNeg (ssym "a") :: ExceptT ArithException Union (SymIntN 4)
--   ExceptT {If (= a 0x8) (Left arithmetic overflow) (Right (- a))}
--   </pre>
safeNeg :: SafeLinearArith e a m => a -> m a

-- | Safe <a>-</a> with monadic error handling in multi-path execution.
--   Overflows or underflows are treated as errors.
--   
--   <pre>
--   &gt;&gt;&gt; safeSub (ssym "a") (ssym "b") :: ExceptT ArithException Union SymInteger
--   ExceptT {Right (+ a (- b))}
--   
--   &gt;&gt;&gt; safeSub (ssym "a") (ssym "b") :: ExceptT ArithException Union (SymIntN 4)
--   ExceptT {If (ite (&lt;= 0x0 a) (&amp;&amp; (&lt; b 0x0) (&lt; (+ a (- b)) 0x0)) (&amp;&amp; (&lt; a 0x0) (&amp;&amp; (&lt; 0x0 b) (&lt; 0x0 (+ a (- b)))))) (If (&lt;= 0x0 a) (Left arithmetic overflow) (Left arithmetic underflow)) (Right (+ a (- b)))}
--   </pre>
safeSub :: SafeLinearArith e a m => a -> a -> m a

-- | Safe fractional with default values returned on exception.
class FdivOr a

-- | Safe <a>/</a> with default values returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; fdivOr "d" "a" "b" :: SymAlgReal
--   (ite (= b 0.0) d (fdiv a b))
--   </pre>
fdivOr :: FdivOr a => a -> a -> a -> a

-- | Safe <a>recip</a> with default values returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; recipOr "d" "a" :: SymAlgReal
--   (ite (= a 0.0) d (recip a))
--   </pre>
recipOr :: FdivOr a => a -> a -> a

-- | Safe <a>/</a> with 0 returned on exception.
fdivOrZero :: (FdivOr a, Num a) => a -> a -> a

-- | Safe <a>recip</a> with 0 returned on exception.
recipOrZero :: (FdivOr a, Num a) => a -> a

-- | Safe fractional division with monadic error handling in multi-path
--   execution. These procedures throw an exception when the denominator is
--   zero. The result should be able to handle errors with
--   <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a) => SafeFdiv e a (m :: Type -> Type)

-- | Safe fractional division with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeFdiv "a" "b" :: ExceptT ArithException Union SymAlgReal
--   ExceptT {If (= b 0.0) (Left Ratio has zero denominator) (Right (fdiv a b))}
--   </pre>
safeFdiv :: SafeFdiv e a m => a -> a -> m a

-- | Safe fractional reciprocal with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeRecip "a" :: ExceptT ArithException Union SymAlgReal
--   ExceptT {If (= a 0.0) (Left Ratio has zero denominator) (Right (recip a))}
--   </pre>
safeRecip :: SafeFdiv e a m => a -> m a
($dmsafeRecip) :: (SafeFdiv e a m, Fractional a) => a -> m a

-- | Safe <a>logBase</a> with default values returned on exception.
class LogBaseOr a

-- | Safe <a>logBase</a> with default values returned on exception.
--   
--   <pre>
--   &gt;&gt;&gt; logBaseOr "d" "base" "val" :: SymAlgReal
--   (ite (= base 1.0) d (fdiv (log val) (log base)))
--   </pre>
logBaseOr :: LogBaseOr a => a -> a -> a -> a

-- | Safe <a>logBase</a> with 0 returned on exception.
logBaseOrZero :: (LogBaseOr a, Num a) => a -> a -> a

-- | Safe <a>logBase</a> with monadic error handling in multi-path
--   execution. These procedures throw an exception when the base is 1. The
--   result should be able to handle errors with <a>MonadError</a>.
class (MonadError e m, TryMerge m, Mergeable a) => SafeLogBase e a (m :: Type -> Type)

-- | Safe <a>logBase</a> with monadic error handling in multi-path
--   execution.
--   
--   <pre>
--   &gt;&gt;&gt; safeLogBase (ssym "base") (ssym "val") :: ExceptT ArithException Union SymAlgReal
--   ExceptT {If (= base 1.0) (Left Ratio has zero denominator) (Right (fdiv (log val) (log base)))}
--   </pre>
safeLogBase :: SafeLogBase e a m => a -> a -> m a

-- | Abstraction for function-like types.
class Function f arg ret | f -> arg ret

-- | Function application operator.
--   
--   The operator is not right associated (like <a>($)</a>). It is left
--   associated, and you can provide many arguments with this operator once
--   at a time.
--   
--   <pre>
--   &gt;&gt;&gt; (+1) # 2
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (+) # 2 # 3
--   5
--   </pre>
(#) :: Function f arg ret => f -> arg -> ret
infixl 9 #

-- | Applying an uninterpreted function.
--   
--   <pre>
--   &gt;&gt;&gt; let f = "f" :: SymInteger =~&gt; SymInteger =~&gt; SymInteger
--   
--   &gt;&gt;&gt; apply f "a" "b"
--   (apply (apply f a) b)
--   </pre>
--   
--   Note that for implementation reasons, you can also use <a>apply</a>
--   function on a non-function symbolic value. In this case, the function
--   is treated as an <a>id</a> function.
class Apply uf where {
    type FunType uf;
}
apply :: Apply uf => uf -> FunType uf

-- | Check if a floating-point number is not-a-number.
fpIsNaN :: RealFloat a => a -> Bool

-- | Check if a floating-point number is positive zero.
fpIsPositiveZero :: RealFloat a => a -> Bool

-- | Check if a floating-point number is negative zero.
fpIsNegativeZero :: RealFloat a => a -> Bool

-- | Check if a floating-point number is positive infinite.
fpIsPositiveInfinite :: RealFloat a => a -> Bool

-- | Check if a floating-point number is negative infinite.
fpIsNegativeInfinite :: RealFloat a => a -> Bool

-- | Check if a floating-point number is positive. +0, +inf are considered
--   positive. nan, -0, -inf are not positive.
fpIsPositive :: RealFloat a => a -> Bool

-- | Check if a floating-point number is negative. -0, -inf are considered
--   negative. nan, +0, +inf are not negative.
fpIsNegative :: RealFloat a => a -> Bool

-- | Check if a floating-point number is infinite.
fpIsInfinite :: RealFloat a => a -> Bool

-- | Check if a floating-point number is zero.
fpIsZero :: RealFloat a => a -> Bool

-- | Check if a floating-point number is normal, i.e., not 0, not inf, not
--   nan, and not denormalized.
fpIsNormal :: RealFloat a => a -> Bool

-- | Check if a floating-point number is subnormal, i.e., denormalized. 0,
--   inf, or nan are not subnormal.
fpIsSubnormal :: RealFloat a => a -> Bool

-- | Check if a floating-point number is a point, i.e., not inf, not nan.
fpIsPoint :: RealFloat a => a -> Bool

-- | A class for symbolic traits of IEEE floating-point numbers.
class SymIEEEFPTraits a

-- | Check if a symbolic floating-point number is not-a-number.
symFpIsNaN :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is positive. +0, +inf are
--   considered positive. nan, -0, -inf are not positive.
symFpIsPositive :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is negative. -0, -inf are
--   considered negative. nan, +0, +inf are not negative.
symFpIsNegative :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is positive infinite.
symFpIsPositiveInfinite :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is negative infinite.
symFpIsNegativeInfinite :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is infinite.
symFpIsInfinite :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is positive zero.
symFpIsPositiveZero :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is negative zero.
symFpIsNegativeZero :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is zero.
symFpIsZero :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is normal, i.e., not 0, not
--   inf, not nan, and not denormalized.
symFpIsNormal :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is subnormal, i.e.,
--   denormalized. 0, inf, or nan are not subnormal.
symFpIsSubnormal :: SymIEEEFPTraits a => a -> SymBool

-- | Check if a symbolic floating-point number is a point, i.e., not inf,
--   not nan.
symFpIsPoint :: SymIEEEFPTraits a => a -> SymBool

-- | Constants for IEEE floating-point numbers.
class IEEEFPConstants a

-- | Positive infinity.
fpPositiveInfinite :: IEEEFPConstants a => a

-- | Negative infinity.
fpNegativeInfinite :: IEEEFPConstants a => a

-- | Not-a-number.
fpNaN :: IEEEFPConstants a => a

-- | Negative zero.
fpNegativeZero :: IEEEFPConstants a => a

-- | Positive zero.
fpPositiveZero :: IEEEFPConstants a => a

-- | Smallest positive normalized number.
fpMinNormalized :: IEEEFPConstants a => a

-- | Smallest positive subnormal number.
fpMinSubnormal :: IEEEFPConstants a => a

-- | Largest positive normalized number.
fpMaxNormalized :: IEEEFPConstants a => a

-- | Largest positive subnormal number.
fpMaxSubnormal :: IEEEFPConstants a => a

-- | Rounding modes for floating-point operations.
class IEEEFPRoundingMode mode

-- | Round to nearest, ties to even.
rne :: IEEEFPRoundingMode mode => mode

-- | Round to nearest, ties to away from zero.
rna :: IEEEFPRoundingMode mode => mode

-- | Round towards positive infinity.
rtp :: IEEEFPRoundingMode mode => mode

-- | Round towards negative infinity.
rtn :: IEEEFPRoundingMode mode => mode

-- | Round towards zero.
rtz :: IEEEFPRoundingMode mode => mode

-- | Operations on IEEE floating-point numbers, without rounding mode.
class IEEEFPOp a

-- | IEEE754-2019 abs operation.
fpAbs :: IEEEFPOp a => a -> a

-- | IEEE754-2019 negate operation.
fpNeg :: IEEEFPOp a => a -> a

-- | IEEE754-2019 remainder operation.
fpRem :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 minimum operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns NaN if one operand is NaN.</li>
--   </ul>
fpMinimum :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 minimumNumber operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns the other operand if one operand is NaN.</li>
--   </ul>
fpMinimumNumber :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 maximum operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns NaN if one operand is NaN.</li>
--   </ul>
fpMaximum :: IEEEFPOp a => a -> a -> a

-- | IEEE754-2019 maximumNumber operation.
--   
--   <ul>
--   <li>The comparison for zeros follows -0 &lt; 0</li>
--   <li>Returns the other operand if one operand is NaN.</li>
--   </ul>
fpMaximumNumber :: IEEEFPOp a => a -> a -> a

-- | Operations on IEEE floating-point numbers, with rounding mode.
class IEEEFPRoundingMode mode => IEEEFPRoundingOp a mode | a -> mode
fpAdd :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpSub :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpMul :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpDiv :: IEEEFPRoundingOp a mode => mode -> a -> a -> a
fpFMA :: IEEEFPRoundingOp a mode => mode -> a -> a -> a -> a
fpSqrt :: IEEEFPRoundingOp a mode => mode -> a -> a
fpRoundToIntegral :: IEEEFPRoundingOp a mode => mode -> a -> a

-- | Conversion from and to FPs.
class IEEEFPConvertible a fp mode | fp -> mode
fromFPOr :: IEEEFPConvertible a fp mode => a -> mode -> fp -> a
toFP :: IEEEFPConvertible a fp mode => mode -> a -> fp

-- | Converting FP to real numbers.
class (IEEEFPConvertible a fp mode, IEEEFPRoundingMode mode) => IEEEFPToAlgReal a fp mode | fp -> mode

-- | Similar to <a>fromFPOr</a> for <a>AlgReal</a>, but dropped the ignored
--   rounding mode.
fpToAlgReal :: IEEEFPToAlgReal a fp mode => a -> fp -> a

-- | Convert a symbolic value to concrete value if possible.
class ToCon a b

-- | Convert a symbolic value to concrete value if possible. If the
--   symbolic value cannot be converted to concrete, the result will be
--   <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toCon (ssym "a" :: SymInteger) :: Maybe Integer
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCon (con 1 :: SymInteger) :: Maybe Integer
--   Just 1
--   </pre>
--   
--   <a>toCon</a> works on complex types too.
--   
--   <pre>
--   &gt;&gt;&gt; toCon ([con 1, con 2] :: [SymInteger]) :: Maybe [Integer]
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCon ([con 1, ssym "a"] :: [SymInteger]) :: Maybe [Integer]
--   Nothing
--   </pre>
toCon :: ToCon a b => a -> Maybe b

-- | Lifting of <a>ToCon</a> to unary type constructors.
class forall a b. ToCon a b => ToCon f1 a f2 b => ToCon1 (f1 :: Type -> Type) (f2 :: Type -> Type)

-- | Lift a conversion to concrete function to unary type constructors.
liftToCon :: ToCon1 f1 f2 => (a -> Maybe b) -> f1 a -> Maybe (f2 b)

-- | Lift the standard <a>toCon</a> to unary type constructors.
toCon1 :: (ToCon1 f1 f2, ToCon a b) => f1 a -> Maybe (f2 b)

-- | Lifting of <a>ToCon</a> to binary type constructors.
class forall a b. ToCon a b => ToCon1 f1 a f2 b => ToCon2 (f1 :: Type -> Type -> Type) (f2 :: Type -> Type -> Type)

-- | Lift conversion to concrete functions to binary type constructors.
liftToCon2 :: ToCon2 f1 f2 => (a -> Maybe b) -> (c -> Maybe d) -> f1 a c -> Maybe (f2 b d)

-- | Lift the standard <a>toCon</a> to binary type constructors.
toCon2 :: (ToCon2 f1 f2, ToCon a b, ToCon c d) => f1 a c -> Maybe (f2 b d)

-- | Convert a concrete value to symbolic value.
class ToSym a b

-- | Convert a concrete value to symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; toSym False :: SymBool
--   false
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toSym [False, True] :: [SymBool]
--   [false,true]
--   </pre>
toSym :: ToSym a b => a -> b

-- | Lifting of <a>ToSym</a> to unary type constructors.
class forall a b. ToSym a b => ToSym f1 a f2 b => ToSym1 (f1 :: Type -> Type) (f2 :: Type -> Type)

-- | Lift a conversion to symbolic function to unary type constructors.
liftToSym :: ToSym1 f1 f2 => (a -> b) -> f1 a -> f2 b

-- | Lift the standard <a>toSym</a> to unary type constructors.
toSym1 :: (ToSym1 f1 f2, ToSym a b) => f1 a -> f2 b

-- | Lifting of <a>ToSym</a> to binary type constructors.
class forall a b. ToSym a b => ToSym1 f1 a f2 b => ToSym2 (f1 :: Type -> Type -> Type) (f2 :: Type -> Type -> Type)

-- | Lift conversion to symbolic functions to binary type constructors.
liftToSym2 :: ToSym2 f1 f2 => (a -> b) -> (c -> d) -> f1 a c -> f2 b d

-- | Lift the standard <a>toSym</a> to binary type constructors.
toSym2 :: (ToSym2 f1 f2, ToSym a b, ToSym c d) => f1 a c -> f2 b d

-- | Type class for bit-casting between types.
--   
--   <b>Special Considerations for Floating-Point Types:</b>
--   
--   Typically, bit-casting a value from type <tt>a</tt> to type <tt>b</tt>
--   and then back to type <tt>a</tt> should result in the original value.
--   However, this is not always true for floating-point values. In
--   SMT-LIB2, there is only one NaN value with multiple bit
--   representations.
--   
--   Given this, we do not provide <a>BitCast</a> for the <a>FP</a> type,
--   instead, we use the <a>bitCastOrCanonical</a> function to use a
--   canonical representation for the NaN values.
--   
--   If your application requires distinguishing between different NaN
--   values, it is recommended to define your own floating-point type using
--   bit-vectors. This allows you to check for NaN values and perform
--   operations by bitcasting back to the provided floating-point types
--   when they are not NaN values.
class BitCast from to
bitCast :: BitCast from to => from -> to

-- | The canonical value when the bitcast cannot be precisely performed.
--   
--   For example, with SMT-LIB2, there is only one NaN for floating point
--   numbers, with multiple bit representations. Our underlying <a>FP</a>
--   type also follows this convention. This means that we cannot precisely
--   bitcast a <a>FP</a> to other types. So instead, we bitcast the NaN
--   value to a canonical representation, defined with this type class.
class BitCastCanonical from to
bitCastCanonicalValue :: BitCastCanonical from to => proxy from -> to

-- | Bitcasting a value. If the value cannot be precisely bitcast, use the
--   default value.
class BitCastOr from to
bitCastOr :: BitCastOr from to => to -> from -> to

-- | Constraint for bitcasting a value and when the value cannot be
--   precisely bitcast, use the canonical value.
type BitCastOrCanonical a b = (BitCastCanonical a b, BitCastOr a b)

-- | Bitcasting a value and when the value cannot be precisely bitcast, use
--   the canonical value.
bitCastOrCanonical :: BitCastOrCanonical from to => from -> to

-- | Bitcasting a value. If the value cannot be precisely bitcast, throw an
--   error.
class (MonadError e m, TryMerge m, Mergeable b, BitCastOr a b) => SafeBitCast e a b (m :: Type -> Type)
safeBitCast :: SafeBitCast e a b m => a -> m b

-- | Conversion from a symbolic integral type.
class SymFromIntegral from to
symFromIntegral :: SymFromIntegral from to => from -> to

-- | Use a term as a key with identity equality.
--   
--   For example, <tt><a>AsKey</a> <a>SymBool</a></tt> uses the term
--   identity for <a>SymBool</a>.
newtype AsKey a
AsKey :: a -> AsKey a
[getAsKey] :: AsKey a -> a

-- | Use a union as a key with identity equality.
--   
--   For example, <tt><a>AsKey1</a> <a>Union</a></tt> uses the term
--   identity for <a>Union</a>.
newtype AsKey1 (f :: Type -> Type) a
AsKey1 :: f a -> AsKey1 (f :: Type -> Type) a
[getAsKey1] :: AsKey1 (f :: Type -> Type) a -> f a

-- | Type class for identity equality for terms.
class KeyEq a
keyEq :: KeyEq a => a -> a -> Bool
infix 4 `keyEq`
class KeyEq1 (f :: Type -> Type)
liftKeyEq :: KeyEq1 f => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Type class for hashing terms based on their identity.
class KeyEq a => KeyHashable a
keyHashWithSalt :: KeyHashable a => Int -> a -> Int
infixl 0 `keyHashWithSalt`
class KeyEq1 f => KeyHashable1 (f :: Type -> Type)
liftKeyHashWithSalt :: KeyHashable1 f => (Int -> a -> Int) -> Int -> f a -> Int

-- | Type class for comparing terms based on their identity.
class KeyEq a => KeyOrd a
keyCompare :: KeyOrd a => a -> a -> Ordering
infix 4 `keyCompare`
class KeyEq1 f => KeyOrd1 (f :: Type -> Type)
liftKeyCompare :: KeyOrd1 f => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | <a>Union</a> is the <a>UnionBase</a> container (hidden) enhanced with
--   <a>MergingStrategy</a> <a>knowledge propagation</a>.
--   
--   The <a>UnionBase</a> models the underlying semantics evaluation
--   semantics for unsolvable types with the nested if-then-else tree
--   semantics, and can be viewed as the following structure:
--   
--   <pre>
--   data UnionBase a
--     = UnionSingle a
--     | UnionIf bool (Union a) (Union a)
--   </pre>
--   
--   The <a>UnionSingle</a> constructor is for a single value with the path
--   condition <tt>true</tt>, and the <a>UnionIf</a> constructor is the if
--   operator in an if-then-else tree. For clarity, when printing a
--   <a>Union</a> value, we will omit the <a>UnionSingle</a> constructor.
--   The following two representations has the same semantics.
--   
--   <pre>
--   If      c1    (If c11 v11 (If c12 v12 v13))
--     (If   c2    v2
--                 v3)
--   </pre>
--   
--   &lt;math&gt;
--   
--   To reduce the size of the if-then-else tree to reduce the number of
--   paths to execute, Grisette would merge the branches in a
--   <a>UnionBase</a> container and maintain a representation invariant for
--   them. To perform this merging procedure, Grisette relies on a type
--   class called <a>Mergeable</a> and the merging strategy defined by it.
--   
--   <a>UnionBase</a> is a monad, so we can easily write code with the
--   do-notation and monadic combinators. However, the standard monadic
--   operators cannot resolve any extra constraints, including the
--   <a>Mergeable</a> constraint (see <a>The constrained-monad problem</a>
--   by Sculthorpe et al.). This prevents the standard do-notations to
--   merge the results automatically, and would result in bad performance
--   or very verbose code.
--   
--   To reduce this boilerplate, Grisette provide another monad,
--   <a>Union</a> that would try to cache the merging strategy. The
--   <a>Union</a> has a data constructor (hidden intentionally) that
--   maintains an optional <a>MergingStrategy</a> and a <a>UnionBase</a>.
--   When the optional <a>MergingStrategy</a> presents (printed as
--   <tt>{...}</tt>), the <a>UnionBase</a> must have already been merged.
--   When the optional <a>MergingStrategy</a> is absent (printed as
--   <tt><a>...</a></tt>), the <a>UnionBase</a> does not guarantee to be
--   merged. When used in monadic context, Grisette would try to use this
--   cached merging strategy to merge the result, as the <a>&gt;&gt;=</a>
--   operator itself cannot resolve the <a>Mergeable</a> constraint.
--   
--   <b><i>Examples:</i></b>
--   
--   <a>return</a> cannot resolve the <a>Mergeable</a> constraint.
--   
--   <pre>
--   &gt;&gt;&gt; return 1 :: Union Integer
--   &lt;1&gt;
--   </pre>
--   
--   <a>mrgReturn</a> can resolve the <a>Mergeable</a> constraint.
--   
--   <pre>
--   &gt;&gt;&gt; import Grisette.Lib.Base
--   
--   &gt;&gt;&gt; mrgReturn 1 :: Union Integer
--   {1}
--   </pre>
--   
--   <a>mrgIfPropagatedStrategy</a> does not try to <a>Mergeable</a>
--   constraint.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfPropagatedStrategy "a" (return 1) (mrgIfPropagatedStrategy "b" (return 1) (return 2)) :: Union Integer
--   &lt;If a 1 (If b 1 2)&gt;
--   </pre>
--   
--   But <a>mrgIfPropagatedStrategy</a> is able to merge the result if some
--   of the branches are merged and have a cached merging strategy:
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfPropagatedStrategy "a" (return 1) (mrgIfPropagatedStrategy "b" (mrgReturn 1) (return 2)) :: Union Integer
--   {If (|| a b) 1 2}
--   </pre>
--   
--   The <a>&gt;&gt;=</a> operator uses <a>mrgIfPropagatedStrategy</a>
--   internally. When the final statement in a do-block merges the values,
--   the system can then merge the final result.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     do
--       x &lt;- mrgIfPropagatedStrategy (ssym "a") (return 1) (mrgIfPropagatedStrategy (ssym "b") (return 1) (return 2))
--       mrgSingle $ x + 1 :: Union Integer
--   :}
--   {If (|| a b) 2 3}
--   </pre>
--   
--   Calling a function that merges a result at the last line of a
--   do-notation will also merge the whole block. If you stick to these
--   <tt>mrg*</tt> combinators and all the functions will merge the
--   results, the whole program can be symbolically evaluated efficiently.
--   
--   <pre>
--   &gt;&gt;&gt; f x y = mrgIf "c" x y :: Union Integer
--   
--   &gt;&gt;&gt; :{
--     do
--       x &lt;- mrgIfPropagatedStrategy (ssym "a") (return 1) (mrgIfPropagatedStrategy (ssym "b") (return 1) (return 2))
--       f x (x + 1)
--   :}
--   {If (&amp;&amp; c (|| a b)) 1 (If (|| a (|| b c)) 2 3)}
--   </pre>
--   
--   In <a>Grisette.Lib.Base</a>, <a>Grisette.Lib.Mtl</a>, we also provided
--   more <tt>mrg*</tt> variants of other combinators. You should stick to
--   these combinators to ensure efficient merging by Grisette.
data Union a

-- | <a>Union</a> with identity equality.
type UnionKey = AsKey1 Union

-- | Lift a unary operation to <a>Union</a>.
unionUnaryOp :: (a -> a) -> Union a -> Union a

-- | Lift a binary operation to <a>Union</a>.
unionBinOp :: (a -> a -> a) -> Union a -> Union a -> Union a

-- | The size of a union is defined as the number of branches. For example,
--   
--   <pre>
--   &gt;&gt;&gt; unionSize (return True)
--   1
--   
--   &gt;&gt;&gt; unionSize (mrgIf "a" (return 1) (return 2) :: Union Integer)
--   2
--   
--   &gt;&gt;&gt; unionSize (choose [1..7] "a" :: Union Integer)
--   7
--   </pre>
unionSize :: Union a -> Int

-- | A tag for concrete types.
--   
--   Can be used in code to constrain types to concrete ones. For example,
--   when trying to support hash maps in Grisette, we may want to restrict
--   the key type to be concrete. The <a>Concrete</a> type class is handy.
class Concrete a

-- | Each type is associated with a root merge strategy given by
--   <a>rootStrategy</a>. The root merge strategy should be able to merge
--   every value of the type. Grisette will use the root merge strategy to
--   merge the values of the type in a union.
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving Mergeable via (Default X)
--   </pre>
class Mergeable a

-- | The root merging strategy for the type.
rootStrategy :: Mergeable a => MergingStrategy a
sortIndices :: Mergeable a => a -> [DynamicSortedIdx]

-- | Lifting of the <a>Mergeable</a> class to unary type constructors.
class forall a. Mergeable a => Mergeable u a => Mergeable1 (u :: Type -> Type)

-- | Lift merge strategy through the type constructor.
liftRootStrategy :: Mergeable1 u => MergingStrategy a -> MergingStrategy (u a)

-- | Lift the root merge strategy through the unary type constructor.
rootStrategy1 :: (Mergeable a, Mergeable1 u) => MergingStrategy (u a)

-- | Lifting of the <a>Mergeable</a> class to binary type constructors.
class forall a. Mergeable a => Mergeable1 u a => Mergeable2 (u :: Type -> Type -> Type)

-- | Lift merge strategy through the type constructor.
liftRootStrategy2 :: Mergeable2 u => MergingStrategy a -> MergingStrategy b -> MergingStrategy (u a b)

-- | Lift the root merge strategy through the binary type constructor.
rootStrategy2 :: (Mergeable a, Mergeable b, Mergeable2 u) => MergingStrategy (u a b)

-- | Lifting of the <a>Mergeable</a> class to ternary type constructors.
class forall a. Mergeable a => Mergeable2 u a => Mergeable3 (u :: Type -> Type -> Type -> Type)

-- | Lift merge strategy through the type constructor.
liftRootStrategy3 :: Mergeable3 u => MergingStrategy a -> MergingStrategy b -> MergingStrategy c -> MergingStrategy (u a b c)

-- | Lift the root merge strategy through the binary type constructor.
rootStrategy3 :: (Mergeable a, Mergeable b, Mergeable c, Mergeable3 u) => MergingStrategy (u a b c)

-- | Merging strategies.
--   
--   <b>You probably do not need to know the details of this type if you
--   are only</b> <b>going to use algebraic data types. You can get merging
--   strategies for</b> <b>them with type derivation.</b>
--   
--   In Grisette, a merged union (if-then-else tree) follows the
--   <b><i>hierarchical sorted representation invariant</i></b> with
--   regards to some merging strategy.
--   
--   A merging strategy encodes how to merge a <b><i>subset</i></b> of the
--   values of a given type. We have three types of merging strategies:
--   
--   <ul>
--   <li>Simple strategy</li>
--   <li>Sorted strategy</li>
--   <li>No strategy</li>
--   </ul>
--   
--   The <a>SimpleStrategy</a> merges values with a simple merge function.
--   For example,
--   
--   <ul>
--   <li>the symbolic boolean values can be directly merged with
--   <a>symIte</a>.</li>
--   <li>the set <tt>{1}</tt>, which is a subset of the values of the type
--   <tt>Integer</tt>, can be simply merged as the set contains only a
--   single value.</li>
--   <li>all the <a>Just</a> values of the type <tt>Maybe SymBool</tt> can
--   be simply merged by merging the wrapped symbolic boolean with
--   <a>symIte</a>.</li>
--   </ul>
--   
--   The <a>SortedStrategy</a> merges values by first grouping the values
--   with an indexing function, and the values with the same index will be
--   organized as a sub-tree in the if-then-else structure of
--   <a>UnionBase</a>. Each group (sub-tree) will be further merged with a
--   sub-strategy for the index. The index type should be a totally ordered
--   type (with the <a>Ord</a> type class). Grisette will use the indexing
--   function to partition the values into sub-trees, and organize them in
--   a sorted way. The sub-trees will further be merged with the
--   sub-strategies. For example,
--   
--   <ul>
--   <li>all the integers can be merged with <a>SortedStrategy</a> by
--   indexing with the identity function and use the <a>SimpleStrategy</a>
--   shown before as the sub-strategies.</li>
--   <li>all the <tt>Maybe SymBool</tt> values can be merged with
--   <a>SortedStrategy</a> by indexing with <a>isJust</a>, the
--   <a>Nothing</a> and <a>Just</a> values can then be merged with
--   different simple strategies as sub-strategies.</li>
--   </ul>
--   
--   The <a>NoStrategy</a> does not perform any merging. For example, we
--   cannot merge values with function types that returns concrete lists.
--   
--   For ADTs, we can automatically derive the <a>Mergeable</a> type class,
--   which provides a merging strategy.
--   
--   If the derived version does not work for you, you should determine if
--   your type can be directly merged with a merging function. If so, you
--   can implement the merging strategy as a <a>SimpleStrategy</a>. If the
--   type cannot be directly merged with a merging function, but could be
--   partitioned into subsets of values that can be simply merged with a
--   function, you should implement the merging strategy as a
--   <a>SortedStrategy</a>. For easier building of the merging strategies,
--   check out the combinators like <a>wrapStrategy</a>.
--   
--   For more details, please see the documents of the constructors, or
--   refer to <a>Grisette's paper</a>.
data MergingStrategy a

-- | Simple mergeable strategy.
--   
--   For symbolic booleans, we can implement its merge strategy as follows:
--   
--   <pre>
--   SimpleStrategy symIte :: MergingStrategy SymBool
--   </pre>
[SimpleStrategy] :: forall a. (SymBool -> a -> a -> a) -> MergingStrategy a

-- | Sorted mergeable strategy.
--   
--   For Integers, we can implement its merge strategy as follows:
--   
--   <pre>
--   SortedStrategy id (\_ -&gt; SimpleStrategy $ \_ t _ -&gt; t)
--   </pre>
--   
--   For <tt>Maybe SymBool</tt>, we can implement its merge strategy as
--   follows:
--   
--   <pre>
--   SortedStrategy
--     (\case; Nothing -&gt; False; Just _ -&gt; True)
--     (\idx -&gt;
--        if idx
--          then SimpleStrategy $ \_ t _ -&gt; t
--          else SimpleStrategy $ \cond (Just l) (Just r) -&gt; Just $ symIte cond l r)
--   </pre>
[SortedStrategy] :: forall idx a. MergingIndex idx => (a -> idx) -> (idx -> MergingStrategy a) -> MergingStrategy a

-- | For preventing the merging intentionally. This could be useful for
--   keeping some value concrete and may help generate more efficient
--   formulas.
--   
--   See <a>Grisette's paper</a> for details.
[NoStrategy] :: forall a. MergingStrategy a

-- | For a type to be used as an index in a <a>SortedStrategy</a>, it must
--   be both <a>Ord</a> and <a>Typeable</a>.
type MergingIndex a = (Ord a, Typeable a)

-- | Useful utility function for building merge strategies manually.
--   
--   For example, to build the merge strategy for the just branch of
--   <tt>Maybe a</tt>, one could write
--   
--   <pre>
--   wrapStrategy Just fromMaybe rootStrategy :: MergingStrategy (Maybe a)
--   </pre>
wrapStrategy :: MergingStrategy a -> (a -> b) -> (b -> a) -> MergingStrategy b

-- | Useful utility function for building merge strategies for product
--   types manually.
--   
--   For example, to build the merge strategy for the following product
--   type, one could write
--   
--   <pre>
--   data X = X { x1 :: Int, x2 :: Bool }
--   product2Strategy X (\(X a b) -&gt; (a, b)) rootStrategy rootStrategy
--     :: MergingStrategy X
--   </pre>
product2Strategy :: (a -> b -> r) -> (r -> (a, b)) -> MergingStrategy a -> MergingStrategy b -> MergingStrategy r

-- | Helper type for combining arbitrary number of indices into one. Useful
--   when trying to write efficient merge strategy for lists/vectors.
data DynamicSortedIdx
[DynamicSortedIdx] :: forall idx. MergingIndex idx => idx -> DynamicSortedIdx

-- | Helper type for building efficient merge strategy for list-like
--   containers.
data StrategyList (container :: Type -> Type)
[StrategyList] :: forall a (container :: Type -> Type). container [DynamicSortedIdx] -> container (MergingStrategy a) -> StrategyList container

-- | Helper function for building efficient merge strategy for list-like
--   containers.
buildStrategyList :: forall a container. Functor container => MergingStrategy a -> container a -> StrategyList container

-- | Resolves the indices and the terminal merge strategy for a value of
--   some <a>Mergeable</a> type.
resolveStrategy :: MergingStrategy x -> x -> ([DynamicSortedIdx], MergingStrategy x)

-- | Resolves the indices and the terminal merge strategy for a value given
--   a merge strategy for its type.
resolveStrategy' :: x -> MergingStrategy x -> ([DynamicSortedIdx], MergingStrategy x)

-- | This class indicates that a type has a simple root merge strategy.
--   
--   <b>Note:</b> This type class can be derived for algebraic data types.
--   You may need the <tt>DerivingVia</tt> and <tt>DerivingStrategies</tt>
--   extensions.
--   
--   <pre>
--   data X = ...
--     deriving Generic
--     deriving (Mergeable, SimpleMergeable) via (Default X)
--   </pre>
class Mergeable a => SimpleMergeable a

-- | Performs if-then-else with the simple root merge strategy.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIte "a" "b" "c" :: SymInteger
--   (ite a b c)
--   </pre>
mrgIte :: SimpleMergeable a => SymBool -> a -> a -> a

-- | Lifting of the <a>SimpleMergeable</a> class to unary type
--   constructors.
class (Mergeable1 u, forall a. SimpleMergeable a => SimpleMergeable u a) => SimpleMergeable1 (u :: Type -> Type)

-- | Lift <a>mrgIte</a> through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; liftMrgIte mrgIte "a" (Identity "b") (Identity "c") :: Identity SymInteger
--   Identity (ite a b c)
--   </pre>
liftMrgIte :: SimpleMergeable1 u => (SymBool -> a -> a -> a) -> SymBool -> u a -> u a -> u a

-- | Lift the standard <a>mrgIte</a> function through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIte1 "a" (Identity "b") (Identity "c") :: Identity SymInteger
--   Identity (ite a b c)
--   </pre>
mrgIte1 :: (SimpleMergeable1 u, SimpleMergeable a) => SymBool -> u a -> u a -> u a

-- | Lifting of the <a>SimpleMergeable</a> class to binary type
--   constructors.
class (Mergeable2 u, forall a. SimpleMergeable a => SimpleMergeable1 u a) => SimpleMergeable2 (u :: Type -> Type -> Type)

-- | Lift <a>mrgIte</a> through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; liftMrgIte2 mrgIte mrgIte "a" ("b", "c") ("d", "e") :: (SymInteger, SymBool)
--   ((ite a b d),(ite a c e))
--   </pre>
liftMrgIte2 :: SimpleMergeable2 u => (SymBool -> a -> a -> a) -> (SymBool -> b -> b -> b) -> SymBool -> u a b -> u a b -> u a b

-- | Lift the standard <a>mrgIte</a> function through the type constructor.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIte2 "a" ("b", "c") ("d", "e") :: (SymInteger, SymBool)
--   ((ite a b d),(ite a c e))
--   </pre>
mrgIte2 :: (SimpleMergeable2 u, SimpleMergeable a, SimpleMergeable b) => SymBool -> u a b -> u a b -> u a b

-- | Special case of the <a>Mergeable1</a> and <a>SimpleMergeable1</a>
--   class for type constructors that are <a>SimpleMergeable</a> when
--   applied to any <a>Mergeable</a> types.
--   
--   This type class is used to generalize the <a>mrgIf</a> function to
--   other containers, for example, monad transformer transformed Unions.
class (SimpleMergeable1 u, forall a. Mergeable a => SimpleMergeable u a, TryMerge u) => SymBranching (u :: Type -> Type)

-- | Symbolic <tt>if</tt> control flow with the result merged with some
--   merge strategy.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfWithStrategy rootStrategy "a" (mrgSingle "b") (return "c") :: Union SymInteger
--   {(ite a b c)}
--   </pre>
--   
--   <b>Note:</b> Be careful to call this directly in your code. The
--   supplied merge strategy should be consistent with the type's root
--   merge strategy, or some internal invariants would be broken and the
--   program can crash.
--   
--   This function is to be called when the <a>Mergeable</a> constraint can
--   not be resolved, e.g., the merge strategy for the contained type is
--   given with <a>Mergeable1</a>. In other cases, <a>mrgIf</a> is usually
--   a better alternative.
mrgIfWithStrategy :: SymBranching u => MergingStrategy a -> SymBool -> u a -> u a -> u a

-- | Symbolic <tt>if</tt> control flow with the result.
--   
--   This function does not need a merging strategy, and it will merge the
--   result only if any of the branches is merged.
mrgIfPropagatedStrategy :: SymBranching u => SymBool -> u a -> u a -> u a

-- | Symbolic <tt>if</tt> control flow with the result merged with the
--   type's root merge strategy.
--   
--   Equivalent to <tt><a>mrgIfWithStrategy</a> <a>rootStrategy</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIf "a" (return "b") (return "c") :: Union SymInteger
--   {(ite a b c)}
--   </pre>
mrgIf :: (SymBranching u, Mergeable a) => SymBool -> u a -> u a -> u a

-- | Try to merge the container with a given merge strategy.
mergeWithStrategy :: SymBranching m => MergingStrategy a -> m a -> m a

-- | Try to merge the container with the root strategy.
merge :: (SymBranching m, Mergeable a) => m a -> m a

-- | Class for monads that support union-like operations and
--   <a>Mergeable</a> knowledge propagation.
type MonadUnion (u :: Type -> Type) = (SymBranching u, Monad u)

-- | Alias for a monad type that has <a>TryMerge</a>.
type MonadTryMerge (f :: Type -> Type) = (TryMerge f, Monad f)

-- | A class for containers that may or may not be merged.
--   
--   If the container is capable of multi-path execution, then the
--   <a>tryMergeWithStrategy</a> function should merge the paths according
--   to the supplied strategy.
--   
--   If the container is not capable of multi-path execution, then the
--   <a>tryMergeWithStrategy</a> function should be equivalent to
--   <a>id</a>.
--   
--   Note that this will not necessarily do a recursive merge for the
--   elements.
class TryMerge (m :: Type -> Type)
tryMergeWithStrategy :: TryMerge m => MergingStrategy a -> m a -> m a

-- | Wrap a value in the applicative functor and propagate the type's root
--   merge strategy.
--   
--   Equivalent to <tt><a>mrgSingleWithStrategy</a>
--   <a>rootStrategy</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; mrgSingle "a" :: Union SymInteger
--   {a}
--   </pre>
mrgSingle :: (TryMerge m, Applicative m, Mergeable a) => a -> m a

-- | Wrap a value in the applicative functor and capture the
--   <a>Mergeable</a> knowledge.
--   
--   <pre>
--   &gt;&gt;&gt; mrgSingleWithStrategy rootStrategy "a" :: Union SymInteger
--   {a}
--   </pre>
--   
--   <b>Note:</b> Be careful to call this directly from your code. The
--   supplied merge strategy should be consistent with the type's root
--   merge strategy, or some internal invariants would be broken and the
--   program can crash.
--   
--   This function is to be called when the <a>Mergeable</a> constraint can
--   not be resolved, e.g., the merge strategy for the contained type is
--   given with <a>Mergeable1</a>. In other cases, <a>mrgPure</a> is
--   usually a better alternative.
mrgSingleWithStrategy :: (TryMerge m, Applicative m) => MergingStrategy a -> a -> m a

-- | Try to merge the container with the root strategy.
tryMerge :: (TryMerge m, Mergeable a) => m a -> m a

-- | Containers that can be projected back into single value or if-guarded
--   values. <a>Identity</a> is an instance of this class as we can always
--   project to single value.
class (Applicative u, TryMerge u) => UnionView (u :: Type -> Type)

-- | Pattern match to extract single values.
--   
--   <pre>
--   &gt;&gt;&gt; singleView (return 1 :: Union Integer)
--   Just 1
--   
--   &gt;&gt;&gt; singleView (mrgIfPropagatedStrategy "a" (return 1) (return 2) :: Union Integer)
--   Nothing
--   </pre>
singleView :: UnionView u => u a -> Maybe a

-- | Pattern match to extract if values.
--   
--   <pre>
--   &gt;&gt;&gt; ifView (return 1 :: Union Integer)
--   Nothing
--   
--   &gt;&gt;&gt; ifView (mrgIfPropagatedStrategy "a" (return 1) (return 2) :: Union Integer)
--   Just (IfViewResult a &lt;1&gt; &lt;2&gt;)
--   
--   &gt;&gt;&gt; ifView (mrgIf "a" (return 1) (return 2) :: Union Integer)
--   Just (IfViewResult a {1} {2})
--   </pre>
ifView :: UnionView u => u a -> Maybe (IfViewResult u a)

-- | Convert the union to a guarded list.
--   
--   <pre>
--   &gt;&gt;&gt; toGuardedList (mrgIf "a" (return 1) (mrgIf "b" (return 2) (return 3)) :: Union Integer)
--   [(a,1),((&amp;&amp; b (! a)),2),((! (|| b a)),3)]
--   </pre>
toGuardedList :: UnionView u => u a -> [(SymBool, a)]

-- | Return all possible values in the union. Drop the path conditions.
--   
--   <pre>
--   &gt;&gt;&gt; overestimateUnionValues (return 1 :: Union Integer)
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; overestimateUnionValues (mrgIf "a" (return 1) (return 2) :: Union Integer)
--   [1,2]
--   </pre>
overestimateUnionValues :: (UnionView u, Mergeable a) => u a -> [a]

-- | The result of <a>ifView</a>.
data IfViewResult (u :: Type -> Type) a
[IfViewResult] :: forall (u :: Type -> Type) a. SymBranching u => SymBool -> u a -> u a -> IfViewResult u a

-- | Pattern match to extract single values with <a>singleView</a>.
--   
--   <pre>
--   &gt;&gt;&gt; case (return 1 :: Union Integer) of Single v -&gt; v
--   1
--   </pre>
pattern Single :: (UnionView u, Mergeable a) => a -> u a

-- | Pattern match to extract guard values with <a>ifView</a>
--   
--   <pre>
--   &gt;&gt;&gt; case (mrgIfPropagatedStrategy "a" (return 1) (return 2) :: Union Integer) of If c t f -&gt; (c,t,f)
--   (a,&lt;1&gt;,&lt;2&gt;)
--   </pre>
pattern If :: (UnionView u, Mergeable a) => SymBranching u => SymBool -> u a -> u a -> u a

-- | Merge the simply mergeable values in a union, and extract the merged
--   value.
--   
--   In the following example, <a>mrgIfPropagatedStrategy</a> will not
--   merge the results, and <a>simpleMerge</a> will merge it and extract
--   the single merged value.
--   
--   <pre>
--   &gt;&gt;&gt; mrgIfPropagatedStrategy (ssym "a") (return $ ssym "b") (return $ ssym "c") :: Union SymBool
--   &lt;If a b c&gt;
--   
--   &gt;&gt;&gt; simpleMerge $ (mrgIfPropagatedStrategy (ssym "a") (return $ ssym "b") (return $ ssym "c") :: Union SymBool)
--   (ite a b c)
--   </pre>
simpleMerge :: forall u a. (SimpleMergeable a, UnionView u) => u a -> a

-- | Helper for applying functions on <a>UnionView</a> and
--   <a>SimpleMergeable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Integer -&gt; Union Integer = \x -&gt; mrgIf (ssym "a") (mrgSingle $ x + 1) (mrgSingle $ x + 2)
--   
--   &gt;&gt;&gt; f .# (mrgIf (ssym "b" :: SymBool) (mrgSingle 0) (mrgSingle 2) :: Union Integer)
--   {If (&amp;&amp; b a) 1 (If b 2 (If a 3 4))}
--   </pre>
(.#) :: (Function f a r, SimpleMergeable r, UnionView u) => f -> u a -> r
infixl 9 .#

-- | Lift a function to work on union values.
--   
--   <pre>
--   &gt;&gt;&gt; sumU = onUnion sum :: Union [SymInteger] -&gt; SymInteger
--   
--   &gt;&gt;&gt; sumU (mrgIfPropagatedStrategy "cond" (return ["a"]) (return ["b","c"]) :: Union [SymInteger])
--   (ite cond a (+ b c))
--   </pre>
onUnion :: forall u a r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a) => (a -> r) -> u a -> r

-- | Lift a function to work on union values.
onUnion2 :: forall u a b r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a, Mergeable b) => (a -> b -> r) -> u a -> u b -> r

-- | Lift a function to work on union values.
onUnion3 :: forall u a b c r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a, Mergeable b, Mergeable c) => (a -> b -> c -> r) -> u a -> u b -> u c -> r

-- | Lift a function to work on union values.
onUnion4 :: forall u a b c d r. (SimpleMergeable r, SymBranching u, UnionView u, Mergeable a, Mergeable b, Mergeable c, Mergeable d) => (a -> b -> c -> d -> r) -> u a -> u b -> u c -> u d -> r

-- | Lift the <a>UnionView</a> value to any Applicative
--   <a>SymBranching</a>.
liftUnion :: (Mergeable a, UnionView u, Applicative m, SymBranching m) => u a -> m a

-- | Alias for <a>liftUnion</a>, but for monads.
liftToMonadUnion :: (Mergeable a, UnionView u, Monad m, SymBranching m) => u a -> m a

-- | Pretty printing of values.
--   
--   This class is similar to the <a>Pretty</a> class from the
--   <a>Prettyprinter</a> package, but it also provides pretty printing
--   with a given precedence level.
--   
--   We are able to derive instances of this class for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving PPrint via (Default X)
--   </pre>
--   
--   The derived instance will pretty print the value with a format similar
--   to the one used by ormolu.
class PPrint a
pformat :: PPrint a => a -> Doc ann
pformatPrec :: PPrint a => Int -> a -> Doc ann
pformatList :: PPrint a => [a] -> Doc ann

-- | Convenience function to layout and render a <a>Doc</a> to <a>Text</a>.
--   
--   You can control the layout with <a>LayoutOptions</a>.
docToTextWith :: LayoutOptions -> Doc ann -> Text

-- | Convenience function to layout and render a <a>Doc</a> to <a>Text</a>.
--   
--   You can control the layout with a single number of the width limit.
docToTextWithWidth :: Int -> Doc ann -> Text

-- | Convenience function to layout and render a <a>Doc</a> to <a>Text</a>.
--   
--   The default layout options <a>defaultLayoutOptions</a> are used.
docToText :: Doc ann -> Text

-- | Convenience function to format a value to <a>Text</a>.
--   
--   You can control the layout with <a>LayoutOptions</a>.
pformatTextWith :: PPrint a => LayoutOptions -> a -> Text

-- | Convenience function to format a value to <a>Text</a>.
--   
--   You can control the layout with a single number of the width limit.
pformatTextWithWidth :: PPrint a => Int -> a -> Text

-- | Convenience function to format a value to <a>Text</a>.
--   
--   The default layout options <a>defaultLayoutOptions</a> are used.
pformatText :: PPrint a => a -> Text

-- | Pretty print a value to the standard output.
pprint :: PPrint a => a -> IO ()

-- | Lifting of the <a>PPrint</a> class to unary type constructors.
class forall a. PPrint a => PPrint f a => PPrint1 (f :: Type -> Type)

-- | Lift a pretty-printer to a unary type constructor.
liftPFormatPrec :: PPrint1 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> Int -> f a -> Doc ann

-- | Lift a pretty-printer to list of values with unary type constructors.
liftPFormatList :: PPrint1 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> [f a] -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to unary type constructors.
pformatPrec1 :: (PPrint1 f, PPrint a) => Int -> f a -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to list of values with unary type constructors.
pformatList1 :: (PPrint1 f, PPrint a) => [f a] -> Doc ann

-- | Lifting of the <a>PPrint</a> class to binary type constructors.
class (forall a. PPrint a => PPrint1 f a, forall a b. (PPrint a, PPrint b) => PPrint f a b) => PPrint2 (f :: Type -> Type -> Type)

-- | Lift two pretty-printers to a binary type constructor.
liftPFormatPrec2 :: PPrint2 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> (Int -> b -> Doc ann) -> ([b] -> Doc ann) -> Int -> f a b -> Doc ann

-- | Lift two pretty-printers to list of values with binary type
--   constructors.
liftPFormatList2 :: PPrint2 f => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> (Int -> b -> Doc ann) -> ([b] -> Doc ann) -> [f a b] -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to binary type constructors.
pformatPrec2 :: (PPrint2 f, PPrint a, PPrint b) => Int -> f a b -> Doc ann

-- | Lift the standard pretty-printer (<a>pformatPrec</a>,
--   <a>pformatList</a>) to list of values with binary type constructors.
pformatList2 :: (PPrint2 f, PPrint a, PPrint b) => [f a b] -> Doc ann

-- | Enclose a document with left and right documents.
--   
--   The pretty printer will try to layout the document in a single line,
--   but the right document may be split to a newline.
groupedEnclose :: Doc ann -> Doc ann -> Doc ann -> Doc ann

-- | Conditionally enclose a document with left and right documents.
--   
--   If the condition is <a>True</a>, then this function is equivalent to
--   <a>groupedEnclose</a>.
condEnclose :: Bool -> Doc ann -> Doc ann -> Doc ann -> Doc ann

-- | Pretty print a list of fields with a constructor.
--   
--   Aligns the fields and nests them by 2 spaces.
pformatWithConstructor :: Int -> Doc ann -> [Doc ann] -> Doc ann

-- | Pretty print a list of fields with a constructor without alignment.
pformatWithConstructorNoAlign :: Int -> Doc ann -> [Doc ann] -> Doc ann

-- | Pretty print a value using <a>showsPrec</a>.
viaShowsPrec :: (Int -> a -> ShowS) -> Int -> a -> Doc ann

-- | Index type used for <a>GenSym</a>.
--   
--   To generate fresh variables, a monadic stateful context will be
--   maintained. The index should be increased every time a new symbolic
--   constant is generated.
newtype FreshIndex
FreshIndex :: Int -> FreshIndex

-- | Monad class for fresh symbolic value generation.
--   
--   The monad should be a reader monad for the <a>Identifier</a> and a
--   state monad for the <a>FreshIndex</a>.
class Monad m => MonadFresh (m :: Type -> Type)

-- | Get the current index for fresh variable generation.
getFreshIndex :: MonadFresh m => m FreshIndex

-- | Set the current index for fresh variable generation.
setFreshIndex :: MonadFresh m => FreshIndex -> m ()

-- | Get the identifier.
getIdentifier :: MonadFresh m => m Identifier

-- | Change the identifier locally and use a new index from 0 locally.
localIdentifier :: MonadFresh m => (Identifier -> Identifier) -> m a -> m a

-- | Get the next fresh index and increase the current index.
nextFreshIndex :: MonadFresh m => m FreshIndex

-- | Lifts an <tt><a>Fresh</a> a</tt> into any <a>MonadFresh</a>.
liftFresh :: MonadFresh m => Fresh a -> m a

-- | <a>FreshT</a> specialized with Identity.
type Fresh = FreshT Identity

-- | A symbolic generation monad transformer.
--   
--   It is a reader monad transformer for an identifier and a state monad
--   transformer for indices.
--   
--   Each time a fresh symbolic variable is generated, the index should be
--   increased.
newtype FreshT (m :: Type -> Type) a
FreshT :: (Identifier -> FreshIndex -> m (a, FreshIndex)) -> FreshT (m :: Type -> Type) a
[runFreshTFromIndex] :: FreshT (m :: Type -> Type) a -> Identifier -> FreshIndex -> m (a, FreshIndex)

-- | Run the symbolic generation with the given identifier and 0 as the
--   initial index.
runFresh :: Fresh a -> Identifier -> a

-- | Run the symbolic generation with the given identifier and 0 as the
--   initial index.
runFreshT :: Monad m => FreshT m a -> Identifier -> m a

-- | Run the symbolic generation with the given identifier and 0 as the
--   initial index, and try to merge the result.
mrgRunFreshT :: (Monad m, TryMerge m, Mergeable a) => FreshT m a -> Identifier -> m a

-- | Generate a fresh string with the given postfix.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (freshString "b") "a" :: String
--   "a@0[b]"
--   </pre>
freshString :: (MonadFresh m, IsString s) => String -> m s

-- | Class of types in which symbolic values can be generated with respect
--   to some specification.
--   
--   The result will be wrapped in a union-like monad. This ensures that we
--   can generate those types with complex merging rules.
--   
--   The uniqueness of symbolic constants is managed with the a monadic
--   context. <a>Fresh</a> and <a>FreshT</a> can be useful.
class Mergeable a => GenSym spec a

-- | Generate a symbolic value given some specification. Within a single
--   <a>MonadFresh</a> context, calls to <a>fresh</a> would generate unique
--   symbolic constants.
--   
--   The following example generates a symbolic boolean. No specification
--   is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh ()) "a" :: Union SymBool
--   {a@0}
--   </pre>
--   
--   The following example generates booleans, which cannot be merged into
--   a single value with type <a>Bool</a>. No specification is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh ()) "a" :: Union Bool
--   {If a@0 False True}
--   </pre>
--   
--   The following example generates <tt>Maybe Bool</tt>s. There are more
--   than one symbolic constants introduced, and their uniqueness is
--   ensured. No specification is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh ()) "a" :: Union (Maybe Bool)
--   {If a@0 Nothing (If a@1 (Just False) (Just True))}
--   </pre>
--   
--   The following example generates lists of symbolic booleans with length
--   1 to 2.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (ListSpec 1 2 ())) "a" :: Union [SymBool]
--   {If a@2 [a@1] [a@0,a@1]}
--   </pre>
--   
--   When multiple symbolic values are generated, there will not be any
--   identifier collision
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (do; a &lt;- fresh (); b &lt;- fresh (); return (a, b)) "a" :: (Union SymBool, Union SymBool)
--   ({a@0},{a@1})
--   </pre>
fresh :: (GenSym spec a, MonadFresh m) => spec -> m (Union a)
($dmfresh) :: (GenSym spec a, GenSymSimple spec a, MonadFresh m) => spec -> m (Union a)

-- | Class of types in which symbolic values can be generated with respect
--   to some specification.
--   
--   The result will <b><i>not</i></b> be wrapped in a union-like monad.
--   
--   The uniqueness of symbolic constants is managed with the a monadic
--   context. <a>Fresh</a> and <a>FreshT</a> can be useful.
class GenSymSimple spec a

-- | Generate a symbolic value given some specification. The uniqueness is
--   ensured.
--   
--   The following example generates a symbolic boolean. No specification
--   is needed.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (simpleFresh ()) "a" :: SymBool
--   a@0
--   </pre>
--   
--   The following code generates list of symbolic boolean with length 2.
--   As the length is fixed, we don't have to wrap the result in unions.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (simpleFresh (SimpleListSpec 2 ())) "a" :: [SymBool]
--   [a@0,a@1]
--   </pre>
simpleFresh :: (GenSymSimple spec a, MonadFresh m) => spec -> m a

-- | Generate a symbolic variable wrapped in a Union without the monadic
--   context. A globally unique identifier should be supplied to ensure the
--   uniqueness of symbolic constants in the generated symbolic values.
--   
--   <pre>
--   &gt;&gt;&gt; genSym (ListSpec 1 2 ()) "a" :: Union [SymBool]
--   {If a@2 [a@1] [a@0,a@1]}
--   </pre>
genSym :: GenSym spec a => spec -> Identifier -> Union a

-- | Generate a simple symbolic variable wrapped in a Union without the
--   monadic context. A globally unique identifier should be supplied to
--   ensure the uniqueness of symbolic constants in the generated symbolic
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; genSymSimple (SimpleListSpec 2 ()) "a" :: [SymBool]
--   [a@0,a@1]
--   </pre>
genSymSimple :: GenSymSimple spec a => spec -> Identifier -> a

-- | We cannot provide DerivingVia style derivation for <a>GenSym</a>,
--   while you can use this <a>fresh</a> implementation to implement
--   <a>GenSym</a> for your own types.
--   
--   This <a>fresh</a> implementation is for the types that does not need
--   any specification. It will generate product types by generating each
--   fields with <tt>()</tt> as specification, and generate all possible
--   values for a sum type.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedNoSpecFresh :: (Generic a, GenSymNoSpec (Rep a), Mergeable a, MonadFresh m) => () -> m (Union a)

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimple</a>, while you can use this <a>simpleFresh</a>
--   implementation to implement <a>GenSymSimple</a> fo your own types.
--   
--   This <a>simpleFresh</a> implementation is for the types that does not
--   need any specification. It will generate product types by generating
--   each fields with <tt>()</tt> as specification. It will not work on sum
--   types.
--   
--   <b>Note:</b> <b>Never</b> use on recursive types.
derivedNoSpecSimpleFresh :: (Generic a, GenSymSimpleNoSpec (Rep a), MonadFresh m) => () -> m a

-- | We cannot provide DerivingVia style derivation for
--   <a>GenSymSimple</a>, while you can use this <a>simpleFresh</a>
--   implementation to implement <a>GenSymSimple</a> fo your own types.
--   
--   This <a>simpleFresh</a> implementation is for the types that can be
--   generated with a reference value of the same type.
--   
--   For sum types, it will generate the result with the same data
--   constructor. For product types, it will generate the result by
--   generating each field with the corresponding reference value.
--   
--   <b>Note:</b> <b>Can</b> be used on recursive types.
derivedSameShapeSimpleFresh :: (Generic a, GenSymSameShape (Rep a), MonadFresh m) => a -> m a

-- | Symbolically chooses one of the provided values. The procedure creates
--   <tt>n - 1</tt> fresh symbolic boolean variables every time it is
--   evaluated, and use these variables to conditionally select one of the
--   <tt>n</tt> provided expressions.
--   
--   The result will be wrapped in a union-like monad, and also a monad
--   maintaining the <a>MonadFresh</a> context.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (chooseFresh [1,2,3]) "a" :: Union Integer
--   {If a@0 1 (If a@1 2 3)}
--   </pre>
chooseFresh :: (Mergeable a, MonadFresh m) => [a] -> m (Union a)

-- | Symbolically chooses one of the provided values. The procedure creates
--   <tt>n - 1</tt> fresh symbolic boolean variables every time it is
--   evaluated, and use these variables to conditionally select one of the
--   <tt>n</tt> provided expressions.
--   
--   The result will <b><i>not</i></b> be wrapped in a union-like monad,
--   but will be wrapped in a monad maintaining the <a>Fresh</a> context.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; runFresh (chooseSimpleFresh [ssym "b", ssym "c", ssym "d"]) "a" :: SymInteger
--   (ite a@0 b (ite a@1 c d))
--   </pre>
chooseSimpleFresh :: (SimpleMergeable a, MonadFresh m) => [a] -> m a

-- | Symbolically chooses one of the provided values wrapped in union-like
--   monads. The procedure creates <tt>n - 1</tt> fresh symbolic boolean
--   variables every time it is evaluated, and use these variables to
--   conditionally select one of the <tt>n</tt> provided expressions.
--   
--   The result will be wrapped in a union-like monad, and also a monad
--   maintaining the <a>Fresh</a> context.
--   
--   <pre>
--   &gt;&gt;&gt; let a = runFresh (chooseFresh [1, 2]) "a" :: Union Integer
--   
--   &gt;&gt;&gt; let b = runFresh (chooseFresh [2, 3]) "b" :: Union Integer
--   
--   &gt;&gt;&gt; runFresh (chooseUnionFresh [a, b]) "c" :: Union Integer
--   {If (&amp;&amp; c@0 a@0) 1 (If (|| c@0 b@0) 2 3)}
--   </pre>
chooseUnionFresh :: (Mergeable a, MonadFresh m) => [Union a] -> m (Union a)

-- | A wrapper for <a>chooseFresh</a> that executes the <a>MonadFresh</a>
--   context. A globally unique identifier should be supplied to ensure the
--   uniqueness of symbolic constants in the generated symbolic values.
choose :: Mergeable a => [a] -> Identifier -> Union a

-- | A wrapper for <a>chooseSimpleFresh</a> that executes the
--   <a>MonadFresh</a> context. A globally unique identifier should be
--   supplied to ensure the uniqueness of symbolic constants in the
--   generated symbolic values.
chooseSimple :: SimpleMergeable a => [a] -> Identifier -> a

-- | A wrapper for <a>chooseUnionFresh</a> that executes the
--   <a>MonadFresh</a> context. A globally unique identifier should be
--   supplied to ensure the uniqueness of symbolic constants in the
--   generated symbolic values.
chooseUnion :: Mergeable a => [Union a] -> Identifier -> Union a

-- | Specification for numbers with lower bound (inclusive) and upper bound
--   (exclusive)
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (EnumGenBound @Integer 0 4)) "c" :: Union Integer
--   {If c@0 0 (If c@1 1 (If c@2 2 3))}
--   </pre>
data EnumGenBound a
EnumGenBound :: a -> a -> EnumGenBound a

-- | Specification for enum values with upper bound (exclusive). The result
--   would chosen from [0 .. upperbound].
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (EnumGenUpperBound @Integer 4)) "c" :: Union Integer
--   {If c@0 0 (If c@1 1 (If c@2 2 3))}
--   </pre>
newtype EnumGenUpperBound a
EnumGenUpperBound :: a -> EnumGenUpperBound a

-- | Specification for list generation.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (ListSpec 0 2 ())) "c" :: Union [SymBool]
--   {If c@2 [] (If c@3 [c@1] [c@0,c@1])}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (fresh (ListSpec 0 2 (SimpleListSpec 1 ()))) "c" :: Union [[SymBool]]
--   {If c@2 [] (If c@3 [[c@1]] [[c@0],[c@1]])}
--   </pre>
data ListSpec spec
ListSpec :: Int -> Int -> spec -> ListSpec spec

-- | The minimum length of the generated lists
[genListMinLength] :: ListSpec spec -> Int

-- | The maximum length of the generated lists
[genListMaxLength] :: ListSpec spec -> Int

-- | Each element in the lists will be generated with the sub-specification
[genListSubSpec] :: ListSpec spec -> spec

-- | Specification for list generation of a specific length.
--   
--   <pre>
--   &gt;&gt;&gt; runFresh (simpleFresh (SimpleListSpec 2 ())) "c" :: [SymBool]
--   [c@0,c@1]
--   </pre>
data SimpleListSpec spec
SimpleListSpec :: Int -> spec -> SimpleListSpec spec

-- | The length of the generated list
[genSimpleListLength] :: SimpleListSpec spec -> Int

-- | Each element in the list will be generated with the sub-specification
[genSimpleListSubSpec] :: SimpleListSpec spec -> spec

-- | Assertion error.
data AssertionError
AssertionError :: AssertionError

-- | Verification conditions. A crashed program path can terminate with
--   either assertion violation errors or assumption violation errors.
data VerificationConditions
AssertionViolation :: VerificationConditions
AssumptionViolation :: VerificationConditions

-- | This class indicates that the error type <tt>to</tt> can always
--   represent the error type <tt>from</tt>.
--   
--   This is useful in implementing generic procedures that may throw
--   errors. For example, we support symbolic division and modulo
--   operations. These operations should throw an error when the divisor is
--   zero, and we use the standard error type <a>ArithException</a> for
--   this purpose. However, the user may use other type to represent
--   errors, so we need this type class to transform the
--   <a>ArithException</a> to the user-defined types.
--   
--   Another example of these generic procedures is the <a>symAssert</a>
--   and <a>symAssume</a> functions. They can be used with any error types
--   that are compatible with the <a>AssertionError</a> and
--   <a>VerificationConditions</a> types, respectively.
class TransformError from to

-- | Transforms an error with type <tt>from</tt> to an error with type
--   <tt>to</tt>.
transformError :: TransformError from to => from -> to

-- | Used within a monadic multi path computation to begin exception
--   processing.
--   
--   Checks the condition passed to the function. The current execution
--   path will be terminated with assertion error if the condition is
--   false.
--   
--   If the condition is symbolic, Grisette will split the execution into
--   two paths based on the condition. The symbolic execution will continue
--   on the then-branch, where the condition is true. For the else branch,
--   where the condition is false, the execution will be terminated.
--   
--   The resulting monadic environment should be compatible with the
--   <a>AssertionError</a> error type. See <a>TransformError</a> type class
--   for details.
--   
--   <b><i>Examples</i></b>:
--   
--   Terminates the execution if the condition is false. Note that we may
--   lose the <a>Mergeable</a> knowledge here if no possible execution path
--   is viable. This may affect the efficiency in theory, but in practice
--   this should not be a problem as all paths are terminated and no
--   further evaluation would be performed.
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (con False) :: ExceptT AssertionError Union ()
--   ExceptT {Left AssertionError}
--   
--   &gt;&gt;&gt; do; symAssert (con False); mrgReturn 1 :: ExceptT AssertionError Union Integer
--   ExceptT &lt;Left AssertionError&gt;
--   </pre>
--   
--   No effect if the condition is true:
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (con True) :: ExceptT AssertionError Union ()
--   ExceptT {Right ()}
--   
--   &gt;&gt;&gt; do; symAssert (con True); mrgReturn 1 :: ExceptT AssertionError Union Integer
--   ExceptT {Right 1}
--   </pre>
--   
--   Splitting the path and terminate one of them when the condition is
--   symbolic.
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (ssym "a") :: ExceptT AssertionError Union ()
--   ExceptT {If (! a) (Left AssertionError) (Right ())}
--   
--   &gt;&gt;&gt; do; symAssert (ssym "a"); mrgReturn 1 :: ExceptT AssertionError Union Integer
--   ExceptT {If (! a) (Left AssertionError) (Right 1)}
--   </pre>
--   
--   <a>AssertionError</a> is compatible with
--   <a>VerificationConditions</a>:
--   
--   <pre>
--   &gt;&gt;&gt; symAssert (ssym "a") :: ExceptT VerificationConditions Union ()
--   ExceptT {If (! a) (Left AssertionViolation) (Right ())}
--   </pre>
symAssert :: (TransformError AssertionError to, Mergeable to, MonadError to erm, MonadUnion erm) => SymBool -> erm ()

-- | Used within a monadic multi path computation to begin exception
--   processing.
--   
--   Similar to <a>symAssert</a>, but terminates the execution path with
--   <a>AssumptionViolation</a> error.
--   
--   <i>Examples</i>:
--   
--   <pre>
--   &gt;&gt;&gt; symAssume (ssym "a") :: ExceptT VerificationConditions Union ()
--   ExceptT {If (! a) (Left AssumptionViolation) (Right ())}
--   </pre>
symAssume :: (TransformError VerificationConditions to, Mergeable to, MonadError to erm, MonadUnion erm) => SymBool -> erm ()

-- | Symbolic assertion with a custom error.
symAssertWith :: (Mergeable e, MonadError e erm, MonadUnion erm) => e -> SymBool -> erm ()

-- | Used within a monadic multi path computation for exception processing.
--   
--   Terminate the current execution path with the specified error if the
--   condition does not hold. Compatible error can be transformed.
--   
--   <pre>
--   &gt;&gt;&gt; let assert = symAssertTransformableError AssertionError :: SymBool -&gt; ExceptT AssertionError Union ()
--   
--   &gt;&gt;&gt; assert "a"
--   ExceptT {If (! a) (Left AssertionError) (Right ())}
--   </pre>
symAssertTransformableError :: (Mergeable to, TransformError from to, MonadError to erm, MonadUnion erm) => from -> SymBool -> erm ()

-- | Used within a monadic multi path computation to begin exception
--   processing.
--   
--   Terminate the current execution path with the specified error.
--   Compatible errors can be transformed.
--   
--   <pre>
--   &gt;&gt;&gt; symThrowTransformableError Overflow :: ExceptT AssertionError Union ()
--   ExceptT {Left AssertionError}
--   </pre>
symThrowTransformableError :: (Mergeable to, Mergeable a, TransformError from to, MonadError to erm, MonadUnion erm) => from -> erm a

-- | A wrapper type for <a>Either</a>. Uses different merging strategies.
newtype CBMCEither a b
CBMCEither :: Either a b -> CBMCEither a b
[runCBMCEither] :: CBMCEither a b -> Either a b

-- | Similar to <a>ExceptT</a>, but with different error handling
--   mechanism.
newtype CBMCExceptT e (m :: Type -> Type) a
CBMCExceptT :: m (CBMCEither e a) -> CBMCExceptT e (m :: Type -> Type) a
[runCBMCExceptT] :: CBMCExceptT e (m :: Type -> Type) a -> m (CBMCEither e a)

-- | Wrap an <a>Either</a> value in <a>CBMCExceptT</a>
cbmcExcept :: forall (m :: Type -> Type) e a. Monad m => Either e a -> CBMCExceptT e m a

-- | Map the error and values in a <a>CBMCExceptT</a>
mapCBMCExceptT :: (m (Either e a) -> n (Either e' b)) -> CBMCExceptT e m a -> CBMCExceptT e' n b

-- | Map the error in a <a>CBMCExceptT</a>
withCBMCExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> CBMCExceptT e m a -> CBMCExceptT e' m a

-- | The current failures that can be returned by the solver.
data SolvingFailure

-- | Unsatisfiable: No model is available.
Unsat :: SolvingFailure

-- | Unknown: The solver cannot determine whether the formula is
--   satisfiable.
Unk :: SolvingFailure

-- | The solver has reached the maximum number of models to return.
ResultNumLimitReached :: SolvingFailure

-- | The solver has encountered an error.
SolvingError :: Text -> SolvingFailure

-- | The solver has been terminated.
Terminated :: SolvingFailure

-- | A monadic solver interface.
--   
--   This interface abstract the monadic interface of a solver. All the
--   operations performed in the monad are using a single solver instance.
--   The solver instance is management by the monad's <tt>run</tt>
--   function.
class Monad m => MonadicSolver (m :: Type -> Type)
monadicSolverPush :: MonadicSolver m => Int -> m ()
monadicSolverPop :: MonadicSolver m => Int -> m ()
monadicSolverResetAssertions :: MonadicSolver m => m ()
monadicSolverAssert :: MonadicSolver m => SymBool -> m ()
monadicSolverCheckSat :: MonadicSolver m => m (Either SolvingFailure Model)

-- | Solve a single formula with a monadic solver. Find an assignment to it
--   to make it true.
monadicSolverSolve :: MonadicSolver m => SymBool -> m (Either SolvingFailure Model)

-- | The commands that can be sent to a solver.
data SolverCommand
SolverAssert :: !SymBool -> SolverCommand
SolverCheckSat :: SolverCommand
SolverPush :: Int -> SolverCommand
SolverPop :: Int -> SolverCommand
SolverResetAssertions :: SolverCommand
SolverTerminate :: SolverCommand

-- | A class that abstracts the creation of a solver instance based on a
--   configuration.
--   
--   The solver instance will need to be terminated by the user, with the
--   solver interface.
class Solver handle => ConfigurableSolver config handle | config -> handle
newSolver :: ConfigurableSolver config handle => config -> IO handle

-- | A class that abstracts the solver interface.
class Solver handle

-- | Run a solver command.
solverRunCommand :: Solver handle => (handle -> IO (Either SolvingFailure a)) -> handle -> SolverCommand -> IO (Either SolvingFailure a)

-- | Assert a formula.
solverAssert :: Solver handle => handle -> SymBool -> IO (Either SolvingFailure ())

-- | Solve a formula.
solverCheckSat :: Solver handle => handle -> IO (Either SolvingFailure Model)

-- | Push <tt>n</tt> levels.
solverPush :: Solver handle => handle -> Int -> IO (Either SolvingFailure ())

-- | Pop <tt>n</tt> levels.
solverPop :: Solver handle => handle -> Int -> IO (Either SolvingFailure ())

-- | Reset all assertions in the solver.
--   
--   The solver keeps all the assertions used in the previous commands:
--   
--   <pre>
--   &gt;&gt;&gt; solver &lt;- newSolver z3
--   
--   &gt;&gt;&gt; solverSolve solver "a"
--   Right (Model {a -&gt; true :: Bool})
--   
--   &gt;&gt;&gt; solverSolve solver $ symNot "a"
--   Left Unsat
--   </pre>
--   
--   You can clear the assertions using <tt>solverResetAssertions</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; solverResetAssertions solver
--   Right ()
--   
--   &gt;&gt;&gt; solverSolve solver $ symNot "a"
--   Right (Model {a -&gt; false :: Bool})
--   </pre>
solverResetAssertions :: Solver handle => handle -> IO (Either SolvingFailure ())

-- | Terminate the solver, wait until the last command is finished.
solverTerminate :: Solver handle => handle -> IO ()

-- | Force terminate the solver, do not wait for the last command to
--   finish.
solverForceTerminate :: Solver handle => handle -> IO ()

-- | Solve a single formula. Find an assignment to it to make it true.
solverSolve :: Solver handle => handle -> SymBool -> IO (Either SolvingFailure Model)

-- | Start a solver, run a computation with the solver, and terminate the
--   solver after the computation finishes.
--   
--   When an exception happens, this will forcibly terminate the solver.
--   
--   Note: if Grisette is compiled with sbv &lt; 10.10, the solver likely
--   won't be really terminated until it has finished the last action, and
--   this will result in long-running or zombie solver instances.
--   
--   This was due to a bug in sbv, which is fixed in
--   <a>https://github.com/LeventErkok/sbv/pull/695</a>.
withSolver :: ConfigurableSolver config handle => config -> (handle -> IO a) -> IO a

-- | Solve a single formula. Find an assignment to it to make it true.
--   
--   <pre>
--   &gt;&gt;&gt; solve z3 ("a" .&amp;&amp; ("b" :: SymInteger) .== 1)
--   Right (Model {a -&gt; true :: Bool, b -&gt; 1 :: Integer})
--   
--   &gt;&gt;&gt; solve z3 ("a" .&amp;&amp; symNot "a")
--   Left Unsat
--   </pre>
solve :: ConfigurableSolver config handle => config -> SymBool -> IO (Either SolvingFailure Model)

-- | Solve a single formula while returning multiple models to make it
--   true. The maximum number of desired models are given.
solverSolveMulti :: Solver handle => handle -> Int -> SymBool -> IO ([Model], SolvingFailure)

-- | Solve a single formula while returning multiple models to make it
--   true. The maximum number of desired models are given.
--   
--   <pre>
--   &gt;&gt;&gt; solveMulti z3 4 ("a" .|| "b")
--   [Model {a -&gt; True :: Bool, b -&gt; False :: Bool},Model {a -&gt; False :: Bool, b -&gt; True :: Bool},Model {a -&gt; True :: Bool, b -&gt; True :: Bool}]
--   </pre>
solveMulti :: ConfigurableSolver config handle => config -> Int -> SymBool -> IO ([Model], SolvingFailure)

-- | A class that abstracts the union-like structures that contains
--   exceptions.
class UnionWithExcept t (u :: Type -> Type) e v | t -> u e v

-- | Extract a union of exceptions and values from the structure.
extractUnionExcept :: UnionWithExcept t u e v => t -> u (Either e v)

-- | Solver procedure for programs with error handling.
solverSolveExcept :: forall t (u :: Type -> Type) e v handle. (UnionWithExcept t u e v, UnionView u, Functor u, Solver handle) => handle -> (Either e v -> SymBool) -> t -> IO (Either SolvingFailure Model)

-- | Solver procedure for programs with error handling.
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   
--   &gt;&gt;&gt; let x = "x" :: SymInteger
--   
--   &gt;&gt;&gt; :{
--     res :: ExceptT AssertionError Union ()
--     res = do
--       symAssert $ x .&gt; 0       -- constrain that x is positive
--       symAssert $ x .&lt; 2       -- constrain that x is less than 2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     translate (Left _) = con False -- errors are not desirable
--     translate _ = con True         -- non-errors are desirable
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solveExcept z3 translate res
--   Right (Model {x -&gt; 1 :: Integer})
--   </pre>
solveExcept :: forall t (u :: Type -> Type) e v config handle. (UnionWithExcept t u e v, UnionView u, Functor u, ConfigurableSolver config handle) => config -> (Either e v -> SymBool) -> t -> IO (Either SolvingFailure Model)

-- | Solver procedure for programs with error handling. Would return
--   multiple models if possible.
solverSolveMultiExcept :: forall t (u :: Type -> Type) e v handle. (UnionWithExcept t u e v, UnionView u, Functor u, Solver handle) => handle -> Int -> (Either e v -> SymBool) -> t -> IO ([Model], SolvingFailure)

-- | Solver procedure for programs with error handling. Would return
--   multiple models if possible.
solveMultiExcept :: forall t (u :: Type -> Type) e v config handle. (UnionWithExcept t u e v, UnionView u, Functor u, ConfigurableSolver config handle) => config -> Int -> (Either e v -> SymBool) -> t -> IO ([Model], SolvingFailure)

-- | The response from a verifier.
data VerifierResult cex exception
CEGISVerifierFoundCex :: cex -> VerifierResult cex exception

-- | True indicates that the verifier is sure that there is no
--   counter-example, while False indicates that the verifier is not sure,
--   but it cannot find a counter-example.
CEGISVerifierNoCex :: Bool -> VerifierResult cex exception
CEGISVerifierException :: exception -> VerifierResult cex exception

-- | Build the synthesizer constraint from the verfication result. The
--   first argument will be guaranteed to be distinct during each
--   invocation of the function in the CEGIS algorithm, so it can be used
--   to instantiate the identifiers for fresh variables.
type SynthesisConstraintFun cex = cex -> IO SymBool

-- | The verifier.
type VerifierFun cex exception = Model -> IO VerifierResult cex exception

-- | The result of the CEGIS procedure.
data CEGISResult exception
CEGISSuccess :: Model -> CEGISResult exception
CEGISVerifierFailure :: exception -> CEGISResult exception
CEGISSolverFailure :: SolvingFailure -> CEGISResult exception

-- | Generic CEGIS procedure. See <a>genericCEGIS</a> for more details.
--   
--   The difference from <a>genericCEGIS</a> is that this function accepts
--   a solver handle for the synthesizer, instead of a solver
--   configuration.
solverGenericCEGIS :: Solver handle => handle -> Bool -> SymBool -> SynthesisConstraintFun input -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | Generic CEGIS procedure with refinement. See
--   <a>genericCEGISWithRefinement</a> for more details.
--   
--   The difference from <a>genericCEGISWithRefinement</a> is that this
--   function accepts a solver handle for the synthesizer, instead of a
--   solver configuration.
solverGenericCEGISWithRefinement :: Solver handle => handle -> Bool -> SymBool -> SynthesisConstraintFun input -> Maybe RefinementConditionFun -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | Generic CEGIS procedure.
--   
--   The CEGIS procedure will try to find a model that satisfies the
--   initial synthesis constraint, and satisfies all the inputs generated
--   by the verifier.
genericCEGIS :: ConfigurableSolver config handle => config -> Bool -> SymBool -> SynthesisConstraintFun input -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | Generic CEGIS procedure.
--   
--   The CEGIS procedure will try to find a model that satisfies the
--   initial synthesis constraint, and satisfies all the inputs generated
--   by the verifier.
genericCEGISWithRefinement :: ConfigurableSolver config handle => config -> Bool -> SymBool -> SynthesisConstraintFun input -> Maybe RefinementConditionFun -> [VerifierFun input exception] -> IO ([input], CEGISResult exception)

-- | The condition for CEGIS to solve.
--   
--   The first argument is the pre-condition, and the second argument is
--   the post-condition.
--   
--   The CEGIS procedures would try to find a model for the formula
--   
--   &lt;math&gt;
--   
--   In program synthesis tasks, &lt;math&gt; is the symbolic constants in
--   the symbolic program, and &lt;math&gt; is the input. The pre-condition
--   is used to restrict the search space of the program. The procedure
--   would only return programs that meets the pre-conditions on every
--   possible inputs, and there are at least one possible input. The
--   post-condition is used to specify the desired program behaviors.
data CEGISCondition
CEGISCondition :: SymBool -> SymBool -> CEGISCondition

-- | CEGIS with multiple (possibly symbolic) inputs. See
--   <a>cegisMultiInputs</a> for more details.
--   
--   The difference from <a>cegisMultiInputs</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisMultiInputs :: (EvalSym input, ExtractSym input, Solver handle) => handle -> handle -> [input] -> (input -> CEGISCondition) -> IO ([input], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs. See
--   <a>cegis</a> for more details.
--   
--   The difference from <a>cegis</a> is that this function accepts two
--   solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegis :: (Solver handle, EvalSym inputs, ExtractSym inputs, SymEq inputs) => handle -> handle -> inputs -> (inputs -> CEGISCondition) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs. See <a>cegisExcept</a>
--   for more details.
--   
--   The difference from <a>cegisExcept</a> is that this function accepts
--   two solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExcept :: forall t (u :: Type -> Type) e v inputs handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs. See
--   <a>cegisExceptStdVC</a> for more details.
--   
--   The difference from <a>cegisExceptStdVC</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptStdVC :: forall t (u :: Type -> Type) inputs handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
--   
--   The difference from <a>cegisExceptVC</a> is that this function accepts
--   two solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
--   
--   The difference from <a>cegisExceptMultiInputs</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptMultiInputs :: forall handle inputs t (u :: Type -> Type) e v. (Solver handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => handle -> handle -> [inputs] -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs. See
--   <a>cegisExceptStdVCMultiInputs</a> for more details.
--   
--   The difference from <a>cegisExceptStdVCMultiInputs</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptStdVCMultiInputs :: forall handle inputs t (u :: Type -> Type). (Solver handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u VerificationConditions (), UnionView u, Monad u) => handle -> handle -> [inputs] -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
--   
--   The difference from <a>cegisExceptVCMultiInputs</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisExceptVCMultiInputs :: (Solver handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => handle -> handle -> [inputs] -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs. See
--   <a>cegisForAll</a> for more details.
--   
--   The difference from <a>cegisForAll</a> is that this function accepts
--   two solver handles, one for the synthesizer and one for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAll :: (ExtractSym forallInput, Solver handle) => handle -> handle -> forallInput -> CEGISCondition -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAllExcept</a>, <a>cegisForAll</a> and
--   <a>cegisExcept</a>.
--   
--   The difference from <a>cegisForAllExcept</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAllExcept :: forall t (u :: Type -> Type) e v inputs handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> CEGISCondition) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAllExceptStdVC</a> <a>cegisForAll</a> and
--   <a>cegisExceptStdVC</a>.
--   
--   The difference from <a>cegisForAllExceptStdVC</a> is that this
--   function accepts two solver handles, one for the synthesizer and one
--   for the verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAllExceptStdVC :: forall t (u :: Type -> Type) inputs handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAllExceptVC</a> <a>cegisForAll</a> and
--   <a>cegisExceptVC</a>.
--   
--   The difference from <a>cegisForAllExceptVC</a> is that this function
--   accepts two solver handles, one for the synthesizer and one for the
--   verifier.
--   
--   The synthesizer solver will **not** be reset, while the verifier
--   solver will be reset after each iteration.
solverCegisForAllExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, Solver handle, SymEq inputs) => handle -> handle -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | Construct a CEGIS condition with only a post-condition. The
--   pre-condition would be set to true, meaning that all programs in the
--   program space are allowed.
cegisPostCond :: SymBool -> CEGISCondition

-- | Construct a CEGIS condition with both pre- and post-conditions.
cegisPrePost :: SymBool -> SymBool -> CEGISCondition

-- | CEGIS with multiple (possibly symbolic) inputs. Solves the following
--   formula (see <a>CEGISCondition</a> for details).
--   
--   &lt;math&gt;
--   
--   For simpler queries, where the inputs are representable by a single
--   symbolic value, you may want to use <a>cegis</a> or <a>cegisExcept</a>
--   instead. We have an example for the <a>cegis</a> call.
cegisMultiInputs :: (EvalSym input, ExtractSym input, ConfigurableSolver config handle) => config -> [input] -> (input -> CEGISCondition) -> IO ([input], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> clause is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; cegis z3 x (\x -&gt; cegisPrePost (x .&gt; 0) (x * c .&lt; 0 .&amp;&amp; c .&gt; -2))
--   (...,CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegis :: (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, SymEq inputs) => config -> inputs -> (inputs -> CEGISCondition) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs.
--   
--   <a>cegisExcept</a> is particularly useful when custom error types are
--   used. With <a>cegisExcept</a>, you define how the errors are
--   interpreted to the CEGIS conditions after the symbolic evaluation.
--   This could increase the readability and modularity of the code.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> assertion is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; import Control.Monad.Except
--   
--   &gt;&gt;&gt; :{
--     res :: SymInteger -&gt; ExceptT VerificationConditions Union ()
--     res x = do
--       symAssume $ x .&gt; 0
--       symAssert $ x * c .&lt; 0
--       symAssert $ c .&gt; -2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     translation (Left AssumptionViolation) = cegisPrePost (con False) (con True)
--     translation (Left AssertionViolation) = cegisPostCond (con False)
--     translation _ = cegisPostCond (con True)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cegisExcept z3 x translation res
--   ([...],CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegisExcept :: forall t (u :: Type -> Type) e v inputs config handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs. This function saves the
--   efforts to implement the translation function for the standard error
--   type <a>VerificationConditions</a>, and the standard result type
--   <tt>()</tt>.
--   
--   This function translates assumption violations to failed
--   pre-conditions, and translates assertion violations to failed
--   post-conditions. The <tt>()</tt> result will not fail any conditions.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> assertion is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; import Control.Monad.Except
--   
--   &gt;&gt;&gt; :{
--     res :: SymInteger -&gt; ExceptT VerificationConditions Union ()
--     res x = do
--       symAssume $ x .&gt; 0
--       symAssert $ x * c .&lt; 0
--       symAssert $ c .&gt; -2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cegisExceptStdVC z3 x res
--   ([...],CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegisExceptStdVC :: forall t (u :: Type -> Type) inputs config handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using a single
--   symbolic input to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
cegisExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
cegisExceptMultiInputs :: forall config handle inputs t (u :: Type -> Type) e v. (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => config -> [inputs] -> (Either e v -> CEGISCondition) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs. This function
--   saves the efforts to implement the translation function for the
--   standard error type <a>VerificationConditions</a>, and the standard
--   result type <tt>()</tt>.
--   
--   This function translates assumption violations to failed
--   pre-conditions, and translates assertion violations to failed
--   post-conditions. The <tt>()</tt> result will not fail any conditions.
cegisExceptStdVCMultiInputs :: forall config handle inputs t (u :: Type -> Type). (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u VerificationConditions (), UnionView u, Monad u) => config -> [inputs] -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, using multiple
--   (possibly symbolic) inputs to represent a set of inputs.
--   
--   The errors should be translated to assertion or assumption violations.
cegisExceptVCMultiInputs :: (ConfigurableSolver config handle, EvalSym inputs, ExtractSym inputs, UnionWithExcept t u e v, UnionView u, Monad u) => config -> [inputs] -> (Either e v -> u (Either VerificationConditions ())) -> (inputs -> t) -> IO ([inputs], CEGISResult SolvingFailure)

-- | CEGIS with a single symbolic input to represent a set of inputs.
--   
--   The following example tries to find the value of <tt>c</tt> such that
--   for all positive <tt>x</tt>, <tt>x * c <a>&amp;&amp; c</a> -2</tt>.
--   The <tt>c .&gt; -2</tt> clause is used to make the solution unique.
--   
--   <pre>
--   &gt;&gt;&gt; let [x,c] = ["x","c"] :: [SymInteger]
--   
--   &gt;&gt;&gt; cegisForAll z3 x $ cegisPrePost (x .&gt; 0) (x * c .&lt; 0 .&amp;&amp; c .&gt; -2)
--   (...,CEGISSuccess (Model {c -&gt; -1 :: Integer}))
--   </pre>
cegisForAll :: (ExtractSym forallInput, ConfigurableSolver config handle) => config -> forallInput -> CEGISCondition -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAll</a> and <a>cegisExcept</a>.
cegisForAllExcept :: forall t (u :: Type -> Type) e v inputs config handle. (UnionWithExcept t u e v, UnionView u, Functor u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> CEGISCondition) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAll</a> and <a>cegisExceptStdVC</a>.
cegisForAllExceptStdVC :: forall t (u :: Type -> Type) inputs config handle. (UnionWithExcept t u VerificationConditions (), UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | CEGIS for symbolic programs with error handling, with a forall
--   variable.
--   
--   See <a>cegisForAll</a> and <a>cegisExceptVC</a>.
cegisForAllExceptVC :: (UnionWithExcept t u e v, UnionView u, Monad u, EvalSym inputs, ExtractSym inputs, ConfigurableSolver config handle, SymEq inputs) => config -> inputs -> (Either e v -> u (Either VerificationConditions ())) -> t -> IO ([Model], CEGISResult SolvingFailure)

-- | The operations on symbolic constant sets
--   
--   Note that symbolic constants with different types are considered
--   different.
--   
--   <pre>
--   &gt;&gt;&gt; let aBool = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let bBool = "b" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let cBool = "c" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let aInteger = "a" :: TypedAnySymbol Integer
--   
--   &gt;&gt;&gt; emptySet :: AnySymbolSet
--   SymbolSet {}
--   
--   &gt;&gt;&gt; containsSymbol aBool (buildSymbolSet aBool :: AnySymbolSet)
--   True
--   
--   &gt;&gt;&gt; containsSymbol bBool (buildSymbolSet aBool :: AnySymbolSet)
--   False
--   
--   &gt;&gt;&gt; insertSymbol aBool (buildSymbolSet aBool :: AnySymbolSet)
--   SymbolSet {a :: Bool}
--   
--   &gt;&gt;&gt; insertSymbol aInteger (buildSymbolSet aBool :: AnySymbolSet)
--   SymbolSet {a :: Bool, a :: Integer}
--   
--   &gt;&gt;&gt; let abSet = buildSymbolSet (aBool, bBool) :: AnySymbolSet
--   
--   &gt;&gt;&gt; let acSet = buildSymbolSet (aBool, cBool) :: AnySymbolSet
--   
--   &gt;&gt;&gt; intersectionSet abSet acSet
--   SymbolSet {a :: Bool}
--   
--   &gt;&gt;&gt; unionSet abSet acSet
--   SymbolSet {a :: Bool, b :: Bool, c :: Bool}
--   
--   &gt;&gt;&gt; differenceSet abSet acSet
--   SymbolSet {b :: Bool}
--   </pre>
class Monoid symbolSet => SymbolSetOps symbolSet (typedSymbol :: Type -> Type) | symbolSet -> typedSymbol

-- | Construct an empty set
emptySet :: SymbolSetOps symbolSet typedSymbol => symbolSet

-- | Check if the set is empty
isEmptySet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> Bool

-- | Check if the set contains the given symbol
containsSymbol :: SymbolSetOps symbolSet typedSymbol => typedSymbol a -> symbolSet -> Bool

-- | Insert a symbol into the set
insertSymbol :: SymbolSetOps symbolSet typedSymbol => typedSymbol a -> symbolSet -> symbolSet

-- | Set intersection
intersectionSet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> symbolSet -> symbolSet

-- | Set union
unionSet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> symbolSet -> symbolSet

-- | Set difference
differenceSet :: SymbolSetOps symbolSet typedSymbol => symbolSet -> symbolSet -> symbolSet

-- | A type class for building a symbolic constant set manually from a
--   symbolic constant set representation
--   
--   <pre>
--   &gt;&gt;&gt; buildSymbolSet ("a" :: TypedAnySymbol Bool, "b" :: TypedAnySymbol Bool) :: AnySymbolSet
--   SymbolSet {a :: Bool, b :: Bool}
--   </pre>
class SymbolSetOps symbolSet typedSymbol => SymbolSetRep rep symbolSet (typedSymbol :: Type -> Type)

-- | Build a symbolic constant set
buildSymbolSet :: SymbolSetRep rep symbolSet typedSymbol => rep -> symbolSet

-- | Extracts all the symbols (symbolic constants) that are transitively
--   contained in the given value.
--   
--   <pre>
--   &gt;&gt;&gt; extractSym ("a" :: SymBool)
--   SymbolSet {a :: Bool}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractSym (mrgIf "a" (mrgReturn ["b"]) (mrgReturn ["c", "d"]) :: Union [SymBool])
--   SymbolSet {a :: Bool, b :: Bool, c :: Bool, d :: Bool}
--   </pre>
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving ExtractSym via (Default X)
--   </pre>
class ExtractSym a
extractSym :: ExtractSym a => a -> AnySymbolSet
extractSymMaybe :: forall (knd :: SymbolKind). (ExtractSym a, IsSymbolKind knd) => a -> Maybe (SymbolSet knd)

-- | Lifting of <a>ExtractSym</a> to unary type constructors.
class forall a. ExtractSym a => ExtractSym f a => ExtractSym1 (f :: Type -> Type)

-- | Lifts the <a>extractSymMaybe</a> function to unary type constructors.
liftExtractSymMaybe :: forall (knd :: SymbolKind) a. (ExtractSym1 f, IsSymbolKind knd) => (a -> Maybe (SymbolSet knd)) -> f a -> Maybe (SymbolSet knd)

-- | Lift the standard <a>extractSym</a> to unary type constructors.
extractSym1 :: forall f a (knd :: SymbolKind). (ExtractSym1 f, ExtractSym a, IsSymbolKind knd) => f a -> SymbolSet knd

-- | Lift the standard <a>extractSymMaybe</a> to unary type constructors.
extractSymMaybe1 :: forall f a (knd :: SymbolKind). (ExtractSym1 f, ExtractSym a, IsSymbolKind knd) => f a -> Maybe (SymbolSet knd)

-- | Lifting of <a>ExtractSym</a> to binary type constructors.
class forall a. ExtractSym a => ExtractSym1 f a => ExtractSym2 (f :: Type -> Type -> Type)

-- | Lifts the <a>extractSymMaybe</a> function to binary type constructors.
liftExtractSymMaybe2 :: forall (knd :: SymbolKind) a b. (ExtractSym2 f, IsSymbolKind knd) => (a -> Maybe (SymbolSet knd)) -> (b -> Maybe (SymbolSet knd)) -> f a b -> Maybe (SymbolSet knd)

-- | Lift the standard <a>extractSym</a> to binary type constructors.
extractSym2 :: forall f a b (knd :: SymbolKind). (ExtractSym2 f, ExtractSym a, ExtractSym b, IsSymbolKind knd) => f a b -> SymbolSet knd

-- | Lift the standard <a>extractSymMaybe</a> to binary type constructors.
extractSymMaybe2 :: forall f a b (knd :: SymbolKind). (ExtractSym2 f, ExtractSym a, ExtractSym b, IsSymbolKind knd) => f a b -> Maybe (SymbolSet knd)

-- | The operations on Models.
--   
--   Note that symbolic constants with different types are considered
--   different.
--   
--   <pre>
--   &gt;&gt;&gt; let aBool = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let bBool = "b" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let cBool = "c" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let aInteger = "a" :: TypedAnySymbol Integer
--   
--   &gt;&gt;&gt; emptyModel :: Model
--   Model {}
--   
--   &gt;&gt;&gt; valueOf aBool (buildModel (aBool ::= True) :: Model)
--   Just True
--   
--   &gt;&gt;&gt; valueOf bBool (buildModel (aBool ::= True) :: Model)
--   Nothing
--   
--   &gt;&gt;&gt; insertValue bBool False (buildModel (aBool ::= True) :: Model)
--   Model {a -&gt; true :: Bool, b -&gt; false :: Bool}
--   
--   &gt;&gt;&gt; let abModel = buildModel (aBool ::= True, bBool ::= False) :: Model
--   
--   &gt;&gt;&gt; let acSet = buildSymbolSet (aBool, cBool) :: AnySymbolSet
--   
--   &gt;&gt;&gt; exceptFor acSet abModel
--   Model {b -&gt; false :: Bool}
--   
--   &gt;&gt;&gt; restrictTo acSet abModel
--   Model {a -&gt; true :: Bool}
--   
--   &gt;&gt;&gt; extendTo acSet abModel
--   Model {a -&gt; true :: Bool, b -&gt; false :: Bool, c -&gt; false :: Bool}
--   
--   &gt;&gt;&gt; exact acSet abModel
--   Model {a -&gt; true :: Bool, c -&gt; false :: Bool}
--   </pre>
class SymbolSetOps symbolSet typedSymbol => ModelOps model symbolSet (typedSymbol :: Type -> Type) | model -> symbolSet typedSymbol

-- | Construct an empty model
emptyModel :: ModelOps model symbolSet typedSymbol => model

-- | Check if the model is empty
isEmptyModel :: ModelOps model symbolSet typedSymbol => model -> Bool

-- | Check if the model contains the given symbol
modelContains :: ModelOps model symbolSet typedSymbol => typedSymbol a -> model -> Bool

-- | Extract the assigned value for a given symbolic constant
valueOf :: ModelOps model symbolSet typedSymbol => typedSymbol t -> model -> Maybe t

-- | Insert an assignment into the model
insertValue :: ModelOps model symbolSet typedSymbol => typedSymbol t -> t -> model -> model

-- | Returns a model that removed all the assignments for the symbolic
--   constants in the set
exceptFor :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | Returns a model that removed the assignments for the symbolic
--   constants
exceptFor' :: ModelOps model symbolSet typedSymbol => typedSymbol t -> model -> model

-- | Returns a model that only keeps the assignments for the symbolic
--   constants in the set
restrictTo :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | Returns a model that extends the assignments for the symbolic
--   constants in the set by assigning default values to them
extendTo :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | Returns a model that contains the assignments for exactly the symbolic
--   constants in the set by removing assignments for the symbolic
--   constants that are not in the set and add assignments for the missing
--   symbolic constants by assigning default values to them.
exact :: ModelOps model symbolSet typedSymbol => symbolSet -> model -> model

-- | A type class for building a model manually from a model representation
class ModelRep rep model | rep -> model

-- | Build a model
--   
--   <pre>
--   &gt;&gt;&gt; let aBool = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; let bBool = "b" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; buildModel (aBool ::= True, bBool ::= False) :: Model
--   Model {a -&gt; true :: Bool, b -&gt; false :: Bool}
--   </pre>
buildModel :: ModelRep rep model => rep -> model

-- | Evaluating symbolic values with some model. This would substitute the
--   symbols (symbolic constants) with the values in the model.
--   
--   <pre>
--   &gt;&gt;&gt; let model = insertValue "a" (1 :: Integer) emptyModel :: Model
--   
--   &gt;&gt;&gt; evalSym False model ([ssym "a", ssym "b"] :: [SymInteger])
--   [1,b]
--   </pre>
--   
--   If we set the first argument true, the missing symbols will be filled
--   in with some default values:
--   
--   <pre>
--   &gt;&gt;&gt; evalSym True model ([ssym "a", ssym "b"] :: [SymInteger])
--   [1,0]
--   </pre>
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving EvalSym via (Default X)
--   </pre>
class EvalSym a

-- | Evaluate a symbolic value with some model, possibly fill in values for
--   the missing symbols.
evalSym :: EvalSym a => Bool -> Model -> a -> a

-- | Evaluate a symbolic value with some model, fill in values for the
--   missing symbols, and convert the result to a concrete value.
--   
--   <pre>
--   &gt;&gt;&gt; let model = insertValue "a" (1 :: Integer) emptyModel :: Model
--   
--   &gt;&gt;&gt; evalSymToCon model ([ssym "a", ssym "b"] :: [SymInteger]) :: [Integer]
--   [1,0]
--   </pre>
evalSymToCon :: (ToCon a b, EvalSym a) => Model -> a -> b

-- | Lifting of <a>EvalSym</a> to unary type constructors.
class forall a. EvalSym a => EvalSym f a => EvalSym1 (f :: Type -> Type)

-- | Lift the <a>evalSym</a> function to unary type constructors.
liftEvalSym :: EvalSym1 f => (Bool -> Model -> a -> a) -> Bool -> Model -> f a -> f a

-- | Lifting the standard <a>evalSym</a> to unary type constructors.
evalSym1 :: (EvalSym1 f, EvalSym a) => Bool -> Model -> f a -> f a

-- | Evaluate and convert to concrete values with lifted standard
--   <a>evalSym</a> for unary type constructors. See <a>evalSymToCon</a>.
evalSymToCon1 :: (EvalSym1 f, EvalSym a, ToCon1 f g, ToCon a b) => Model -> f a -> g b

-- | Lifting of <a>EvalSym1</a> to binary type constructors.
class forall a. EvalSym a => EvalSym1 f a => EvalSym2 (f :: Type -> Type -> Type)

-- | Lift the <a>evalSym</a> function to binary type constructors.
liftEvalSym2 :: EvalSym2 f => (Bool -> Model -> a -> a) -> (Bool -> Model -> b -> b) -> Bool -> Model -> f a b -> f a b

-- | Lifting the standard <a>evalSym</a> to binary type constructors.
evalSym2 :: (EvalSym2 f, EvalSym a, EvalSym b) => Bool -> Model -> f a b -> f a b

-- | Evaluate and convert to concrete values with lifted standard
--   <a>evalSym</a> for binary type constructors. See <a>evalSymToCon</a>.
evalSymToCon2 :: (EvalSym2 f, EvalSym a, EvalSym c, ToCon2 f g, ToCon a b, ToCon c d) => Model -> f a c -> g b d

-- | Substitution of symbols (symbolic constants) to a symbolic value.
--   
--   <pre>
--   &gt;&gt;&gt; a = "a" :: TypedAnySymbol Bool
--   
--   &gt;&gt;&gt; v = "x" .&amp;&amp; "y" :: SymBool
--   
--   &gt;&gt;&gt; substSym a v (["a" .&amp;&amp; "b", "a"] :: [SymBool])
--   [(&amp;&amp; (&amp;&amp; x y) b),(&amp;&amp; x y)]
--   </pre>
--   
--   <b>Note 1:</b> This type class can be derived for algebraic data
--   types. You may need the <tt>DerivingVia</tt> and
--   <tt>DerivingStrategies</tt> extensions.
--   
--   <pre>
--   data X = ... deriving Generic deriving SubstSym via (Default X)
--   </pre>
class SubstSym a
substSym :: forall cb sb (knd :: SymbolKind). (SubstSym a, LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> a -> a

-- | Lifting of <a>SubstSym</a> to unary type constructors.
class forall a. SubstSym a => SubstSym f a => SubstSym1 (f :: Type -> Type)

-- | Lift a symbol substitution function to unary type constructors.
liftSubstSym :: forall cb sb (knd :: SymbolKind) a. (SubstSym1 f, LinkedRep cb sb, IsSymbolKind knd) => (TypedSymbol knd cb -> sb -> a -> a) -> TypedSymbol knd cb -> sb -> f a -> f a

-- | Lifting the standard <a>substSym</a> to unary type constructors.
substSym1 :: forall f a cb sb (knd :: SymbolKind). (SubstSym1 f, SubstSym a, LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> f a -> f a

-- | Lifting of <a>SubstSym</a> to binary type constructors.
class forall a. SubstSym a => SubstSym1 f a => SubstSym2 (f :: Type -> Type -> Type)

-- | Lift a symbol substitution function to binary type constructors.
liftSubstSym2 :: forall cb sb (knd :: SymbolKind) a b. (SubstSym2 f, LinkedRep cb sb, IsSymbolKind knd) => (TypedSymbol knd cb -> sb -> a -> a) -> (TypedSymbol knd cb -> sb -> b -> b) -> TypedSymbol knd cb -> sb -> f a b -> f a b

-- | Lifting the standard <a>substSym</a> to binary type constructors.
substSym2 :: forall f a b cb sb (knd :: SymbolKind). (SubstSym2 f, SubstSym a, SubstSym b, LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> f a b -> f a b

-- | Memoize a unary function.
stableMemo :: (a -> b) -> a -> b

-- | Curried memoization to share partial evaluation
stableMemo2 :: (a -> b -> c) -> a -> b -> c

-- | Curried memoization to share partial evaluation
stableMemo3 :: (a -> b -> c -> d) -> a -> b -> c -> d

-- | Lift a memoizer to work with one more argument.
stableMup :: (b -> c) -> (a -> b) -> a -> c

-- | Memoizing recursion. Use like <a>fix</a>.
stableMemoFix :: ((a -> b) -> a -> b) -> a -> b

-- | Memoize a unary function.
weakStableMemo :: (a -> b) -> a -> b

-- | Curried memoization to share partial evaluation
weakStableMemo2 :: (a -> b -> c) -> a -> b -> c

-- | Curried memoization to share partial evaluation
weakStableMemo3 :: (a -> b -> c -> d) -> a -> b -> c -> d

-- | Lift a memoizer to work with one more argument.
weakStableMup :: (b -> c) -> (a -> b) -> a -> c

-- | Memoizing recursion. Use like <a>fix</a>.
weakStableMemoFix :: ((a -> b) -> a -> b) -> a -> b

-- | Function memoizer with mutable hash table.
htmemo :: (Eq k, Hashable k) => (k -> a) -> k -> a

-- | Function memoizer with mutable hash table. Works on binary functions.
htmemo2 :: (Eq k1, Hashable k1, Eq k2, Hashable k2) => (k1 -> k2 -> a) -> k1 -> k2 -> a

-- | Function memoizer with mutable hash table. Works on ternary functions.
htmemo3 :: (Eq k1, Hashable k1, Eq k2, Hashable k2, Eq k3, Hashable k3) => (k1 -> k2 -> k3 -> a) -> k1 -> k2 -> k3 -> a

-- | Memoizing recursion. Use like <a>fix</a>.
htmemoFix :: (Eq k, Hashable k) => ((k -> a) -> k -> a) -> k -> a

-- | Lift a memoizer to work with one more argument.
htmup :: (Eq k, Hashable k) => (b -> c) -> (k -> b) -> k -> c

-- | This newtype wrapper can be used to derive default instances for
--   classes taking an argument of kind <a>Type</a>.
newtype Default a
Default :: a -> Default a
[unDefault] :: Default a -> a

-- | This newtype wrapper can be used to derive default instances for
--   classes taking an argument of kind <tt><a>Type</a> -&gt;
--   <a>Type</a></tt>.
newtype Default1 (f :: Type -> Type) a
Default1 :: f a -> Default1 (f :: Type -> Type) a
[unDefault1] :: Default1 (f :: Type -> Type) a -> f a

-- | The arguments to the generic equality function.
data family SymEqArgs arity a b

-- | The class of types that can be generically compared for symbolic
--   equality.
class GSymEq arity (f :: Type -> Type)
gsymEq :: GSymEq arity f => SymEqArgs arity a b -> f a -> f b -> SymBool

-- | Generic <tt>(<a>.==</a>)</tt> function.
genericSymEq :: (Generic a, GSymEq Arity0 (Rep a)) => a -> a -> SymBool

-- | Generic <a>liftSymEq</a> function.
genericLiftSymEq :: (Generic1 f, GSymEq Arity1 (Rep1 f)) => (a -> b -> SymBool) -> f a -> f b -> SymBool

-- | The arguments to the generic comparison function.
data family SymOrdArgs arity a b

-- | The class of types that can be generically symbolically compared.
class GSymOrd arity (f :: Type -> Type)
gsymCompare :: GSymOrd arity f => SymOrdArgs arity a b -> f a -> f b -> Union Ordering

-- | Generic <a>symCompare</a> function.
genericSymCompare :: (Generic a, GSymOrd Arity0 (Rep a)) => a -> a -> Union Ordering

-- | Generic <a>liftSymCompare</a> function.
genericLiftSymCompare :: (Generic1 f, GSymOrd Arity1 (Rep1 f)) => (a -> b -> Union Ordering) -> f a -> f b -> Union Ordering

-- | The arguments to the generic merging strategy function.
data family MergeableArgs arity a

-- | The class of types that can be generically merged.
class GMergeable arity (f :: Type -> Type)
grootStrategy :: GMergeable arity f => MergeableArgs arity a -> MergingStrategy (f a)

-- | Generic <a>rootStrategy</a>.
genericRootStrategy :: (Generic a, GMergeable Arity0 (Rep a)) => MergingStrategy a

-- | Generic <a>liftRootStrategy</a>.
genericLiftRootStrategy :: (Generic1 f, GMergeable Arity1 (Rep1 f)) => MergingStrategy a -> MergingStrategy (f a)

-- | The arguments to the generic simple merging function.
data family SimpleMergeableArgs arity a

-- | Generic <a>SimpleMergeable</a> class.
class GSimpleMergeable arity (f :: Type -> Type)
gmrgIte :: GSimpleMergeable arity f => SimpleMergeableArgs arity a -> SymBool -> f a -> f a -> f a

-- | Generic <a>mrgIte</a> function.
genericMrgIte :: (Generic a, GSimpleMergeable Arity0 (Rep a)) => SymBool -> a -> a -> a

-- | Generic <a>liftMrgIte</a> function.
genericLiftMrgIte :: (Generic1 f, GSimpleMergeable Arity1 (Rep1 f)) => (SymBool -> a -> a -> a) -> SymBool -> f a -> f a -> f a

-- | The arguments to the generic <a>toCon</a> function.
data family ToConArgs arity a b

-- | The class of types that can be generically converted to concrete
--   values.
class GToCon arity (f1 :: Type -> Type) (f2 :: Type -> Type)
gtoCon :: GToCon arity f1 f2 => ToConArgs arity a b -> f1 a -> Maybe (f2 b)

-- | Generic <a>toCon</a> function.
genericToCon :: (Generic a, Generic b, GToCon Arity0 (Rep a) (Rep b)) => a -> Maybe b

-- | Generic <a>liftToCon</a> function.
genericLiftToCon :: (Generic1 f1, Generic1 f2, GToCon Arity1 (Rep1 f1) (Rep1 f2)) => (a -> Maybe b) -> f1 a -> Maybe (f2 b)

-- | Convert a plain union to concrete values.
--   
--   <pre>
--   &gt;&gt;&gt; unionToCon (return 1 :: Union SymInteger) :: Maybe Integer
--   Just 1
--   
--   &gt;&gt;&gt; unionToCon (mrgIf "a" (return 1) (return 2) :: Union SymInteger) :: Maybe Integer
--   Nothing
--   
--   &gt;&gt;&gt; unionToCon (return "a" :: Union SymInteger) :: Maybe Integer
--   Nothing
--   </pre>
unionToCon :: (ToCon a b, UnionView u) => u a -> Maybe b

-- | The arguments to the generic <a>toSym</a> function.
data family ToSymArgs arity a b

-- | The class of types that can be generically converted to symbolic
--   values.
class GToSym arity (f1 :: Type -> Type) (f2 :: Type -> Type)
gtoSym :: GToSym arity f1 f2 => ToSymArgs arity a b -> f1 a -> f2 b

-- | Generic <a>toSym</a> function.
genericToSym :: (Generic a, Generic b, GToSym Arity0 (Rep a) (Rep b)) => a -> b

-- | Generic <a>liftToSym</a> function.
genericLiftToSym :: (Generic1 f1, Generic1 f2, GToSym Arity1 (Rep1 f1) (Rep1 f2)) => (a -> b) -> f1 a -> f2 b

-- | Convert a value to symbolic value and wrap it with a mergeable
--   container.
--   
--   This is a synonym for <a>toUnionSym</a>.
mrgToSym :: (ToSym a b, Mergeable b, TryMerge m, Applicative m) => a -> m b

-- | Convert a value to symbolic value and wrap it with a mergeable
--   container.
--   
--   This is a synonym for <a>toUnionSym</a>.
toUnionSym :: (ToSym a b, Mergeable b, TryMerge m, Applicative m) => a -> m b

-- | The arguments to the generic <a>evalSym</a> function.
data family EvalSymArgs arity a

-- | The class of types that can be generically evaluated.
class GEvalSym arity (f :: Type -> Type)
gevalSym :: GEvalSym arity f => EvalSymArgs arity a -> Bool -> Model -> f a -> f a

-- | Generic <a>evalSym</a> function.
genericEvalSym :: (Generic a, GEvalSym Arity0 (Rep a)) => Bool -> Model -> a -> a

-- | Generic <a>liftEvalSym</a> function.
genericLiftEvalSym :: (Generic1 f, GEvalSym Arity1 (Rep1 f)) => (Bool -> Model -> a -> a) -> Bool -> Model -> f a -> f a

-- | The arguments to the generic <a>extractSym</a> function.
data family ExtractSymArgs arity (knd :: SymbolKind) a

-- | The class of types that can generically extract the symbols.
class GExtractSym arity (f :: Type -> Type)
gextractSymMaybe :: forall (knd :: SymbolKind) a. (GExtractSym arity f, IsSymbolKind knd) => ExtractSymArgs arity knd a -> f a -> Maybe (SymbolSet knd)

-- | Generic <a>extractSym</a> function.
genericExtractSymMaybe :: forall a (knd :: SymbolKind). (Generic a, GExtractSym Arity0 (Rep a), IsSymbolKind knd) => a -> Maybe (SymbolSet knd)

-- | Generic <a>liftExtractSymMaybe</a> function.
genericLiftExtractSymMaybe :: forall f (knd :: SymbolKind) a. (Generic1 f, GExtractSym Arity1 (Rep1 f), IsSymbolKind knd) => (a -> Maybe (SymbolSet knd)) -> f a -> Maybe (SymbolSet knd)

-- | The arguments to the generic <a>substSym</a> function.
data family SubstSymArgs arity (knd :: SymbolKind) a cb sb

-- | The class of types where we can generically substitute the symbols in
--   a value.
class GSubstSym arity (f :: Type -> Type)
gsubstSym :: forall cb sb (knd :: SymbolKind) a. (GSubstSym arity f, LinkedRep cb sb, IsSymbolKind knd) => SubstSymArgs arity knd a cb sb -> TypedSymbol knd cb -> sb -> f a -> f a

-- | Generic <a>substSym</a> function.
genericSubstSym :: forall a cb sb (knd :: SymbolKind). (Generic a, GSubstSym Arity0 (Rep a), LinkedRep cb sb, IsSymbolKind knd) => TypedSymbol knd cb -> sb -> a -> a

-- | Generic <a>liftSubstSym</a> function.
genericLiftSubstSym :: forall f cb sb (knd :: SymbolKind) a. (Generic1 f, GSubstSym Arity1 (Rep1 f), LinkedRep cb sb, IsSymbolKind knd) => (TypedSymbol knd cb -> sb -> a -> a) -> TypedSymbol knd cb -> sb -> f a -> f a

-- | Generic <a>pformatPrec</a> function.
genericPFormatPrec :: (Generic a, GPPrint Arity0 (Rep a)) => Int -> a -> Doc ann

-- | Generic <a>liftPFormatPrec</a> function.
genericLiftPFormatPrec :: (Generic1 f, GPPrint Arity1 (Rep1 f)) => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> Int -> f a -> Doc ann

-- | Generic <a>pformatList</a> function.
genericPFormatList :: (Generic a, GPPrint Arity0 (Rep a)) => [a] -> Doc ann

-- | Generic <a>liftPFormatList</a> function.
genericLiftPFormatList :: (Generic1 f, GPPrint Arity1 (Rep1 f)) => (Int -> a -> Doc ann) -> ([a] -> Doc ann) -> [f a] -> Doc ann

-- | The arguments to the generic <a>PPrint</a> class.
data family PPrintArgs arity a ann

-- | Generic <a>PPrint</a> class.
class GPPrint arity (f :: Type -> Type)
gpformatPrec :: GPPrint arity f => PPrintArgs arity a ann -> PPrintType -> Int -> f a -> Doc ann
gpformatList :: (GPPrint arity f, HasCallStack) => PPrintArgs arity a ann -> [f a] -> Doc ann
gisNullary :: (GPPrint arity f, HasCallStack) => PPrintArgs arity a ann -> f a -> Bool

-- | Controls how to pretty-print a generic representation.
data PPrintType
Rec :: PPrintType
Tup :: PPrintType
Pref :: PPrintType
Inf :: String -> Int -> PPrintType


module Grisette.Utils

-- | Assert a proof of equality between two types. This is unsafe if used
--   improperly, so use this with caution!
unsafeAxiom :: forall {k} (a :: k) (b :: k). a :~: b

-- | A runtime representation of type-level natural numbers. This can be
--   used for performing dynamic checks on type-level natural numbers.
data NatRepr (n :: Nat)

-- | The underlying runtime natural number value of a type-level natural
--   number.
natValue :: forall (n :: Nat). NatRepr n -> Natural

-- | Construct a runtime representation of a type-level natural number when
--   its runtime value is known.
natRepr :: forall (n :: Nat). KnownNat n => NatRepr n

-- | Decrement a <a>NatRepr</a> by 1.
decNat :: forall (n :: Natural). 1 <= n => NatRepr n -> NatRepr (n - 1)

-- | Predecessor of a <a>NatRepr</a>
predNat :: forall (n :: Natural). NatRepr (n + 1) -> NatRepr n

-- | Increment a <a>NatRepr</a> by 1.
incNat :: forall (n :: Nat). NatRepr n -> NatRepr (n + 1)

-- | Addition of two <a>NatRepr</a>s.
addNat :: forall (m :: Nat) (n :: Nat). NatRepr m -> NatRepr n -> NatRepr (m + n)

-- | Subtraction of two <a>NatRepr</a>s.
subNat :: forall (n :: Nat) (m :: Nat). n <= m => NatRepr m -> NatRepr n -> NatRepr (m - n)

-- | Division of two <a>NatRepr</a>s.
divNat :: forall (n :: Natural) (m :: Nat). 1 <= n => NatRepr m -> NatRepr n -> NatRepr (Div m n)

-- | Half of a <a>NatRepr</a>.
halfNat :: forall (n :: Natural). NatRepr (n + n) -> NatRepr n

-- | <tt>'KnownProof n'</tt> is a type whose values are only inhabited when
--   <tt>n</tt> has a known runtime value.
data KnownProof (n :: Nat)
[KnownProof] :: forall (n :: Nat). KnownNat n => KnownProof n

-- | Construct a <a>KnownProof</a> given the runtime representation.
hasRepr :: forall (n :: Nat). NatRepr n -> KnownProof n

-- | Introduces the <a>KnownNat</a> constraint when it's proven.
withKnownProof :: forall (n :: Nat) r. KnownProof n -> (KnownNat n => r) -> r

-- | Construct a <a>KnownProof</a> given the runtime value.
--   
--   <b>Note:</b> This function is unsafe, as it does not check that the
--   runtime representation is consistent with the type-level
--   representation. You should ensure the consistency yourself or the
--   program can crash or generate incorrect results.
unsafeKnownProof :: forall (n :: Nat). Natural -> KnownProof n

-- | Adding two type-level natural numbers with known runtime values gives
--   a type-level natural number with a known runtime value.
knownAdd :: forall (m :: Nat) (n :: Nat). KnownProof m -> KnownProof n -> KnownProof (m + n)

-- | <tt>'LeqProof m n'</tt> is a type whose values are only inhabited when
--   <tt>m &lt;= n</tt>.
data LeqProof (m :: Nat) (n :: Nat)
[LeqProof] :: forall (m :: Nat) (n :: Nat). m <= n => LeqProof m n

-- | Introduces the <tt>m &lt;= n</tt> constraint when it's proven.
withLeqProof :: forall (m :: Nat) (n :: Nat) r. LeqProof m n -> (m <= n => r) -> r

-- | Construct a <a>LeqProof</a>.
--   
--   <b>Note:</b> This function is unsafe, as it does not check that the
--   left-hand side is less than or equal to the right-hand side. You
--   should ensure the consistency yourself or the program can crash or
--   generate incorrect results.
unsafeLeqProof :: forall (m :: Nat) (n :: Nat). LeqProof m n

-- | Checks if a <a>NatRepr</a> is less than or equal to another
--   <a>NatRepr</a>.
testLeq :: forall (m :: Nat) (n :: Nat). NatRepr m -> NatRepr n -> Maybe (LeqProof m n)

-- | Apply reflexivity to <a>LeqProof</a>.
leqRefl :: forall f (n :: Nat). f n -> LeqProof n n

-- | A natural number is less than or equal to its successor.
leqSucc :: forall f (n :: Nat). f n -> LeqProof n (n + 1)

-- | Apply transitivity to <a>LeqProof</a>.
leqTrans :: forall (a :: Nat) (b :: Nat) (c :: Nat). LeqProof a b -> LeqProof b c -> LeqProof a c

-- | Zero is less than or equal to any natural number.
leqZero :: forall (n :: Nat). LeqProof 0 n

-- | Add both sides of two inequalities.
leqAdd2 :: forall (xl :: Nat) (xh :: Nat) (yl :: Nat) (yh :: Nat). LeqProof xl xh -> LeqProof yl yh -> LeqProof (xl + yl) (xh + yh)

-- | Produce proof that adding a value to the larger element in an
--   <a>LeqProof</a> is larger.
leqAdd :: forall (m :: Nat) (n :: Nat) f (o :: Natural). LeqProof m n -> f o -> LeqProof m (n + o)

-- | Adding two positive natural numbers is positive.
leqAddPos :: forall (m :: Natural) (n :: Natural) p q. (1 <= m, 1 <= n) => p m -> q n -> LeqProof 1 (m + n)


module Grisette
