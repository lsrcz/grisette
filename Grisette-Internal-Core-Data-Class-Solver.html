<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Grisette.Internal.Core.Data.Class.Solver</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">grisette-0.11.0.0: Symbolic evaluation as a library</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Grisette.Internal.Core.Data.Class.Solver.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Sirui Lu 2021-2023</td></tr><tr><th>License</th><td>BSD-3-Clause (see the LICENSE file)</td></tr><tr><th>Maintainer</th><td>siruilu@cs.washington.edu</td></tr><tr><th>Stability</th><td>Experimental</td></tr><tr><th>Portability</th><td>GHC only</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Grisette.Internal.Core.Data.Class.Solver</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Note for the examples</a></li><li><a href="#g:2">Solver interfaces</a></li><li><a href="#g:3">Union with exceptions</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:SolvingFailure">SolvingFailure</a><ul class="subs"><li>= <a href="#v:Unsat">Unsat</a></li><li>| <a href="#v:Unk">Unk</a></li><li>| <a href="#v:ResultNumLimitReached">ResultNumLimitReached</a></li><li>| <a href="#v:SolvingError">SolvingError</a> <a href="https://hackage.haskell.org/package/text-2.1.1/docs/Data-Text.html#t:Text" title="Data.Text">Text</a></li><li>| <a href="#v:Terminated">Terminated</a></li></ul></li><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="#t:MonadicSolver">MonadicSolver</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:monadicSolverPush">monadicSolverPush</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m ()</li><li><a href="#v:monadicSolverPop">monadicSolverPop</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m ()</li><li><a href="#v:monadicSolverResetAssertions">monadicSolverResetAssertions</a> :: m ()</li><li><a href="#v:monadicSolverAssert">monadicSolverAssert</a> :: <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; m ()</li><li><a href="#v:monadicSolverCheckSat">monadicSolverCheckSat</a> :: m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li></ul></li><li class="src short"><a href="#v:monadicSolverSolve">monadicSolverSolve</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:MonadicSolver" title="Grisette.Internal.Core.Data.Class.Solver">MonadicSolver</a> m =&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:SolverCommand">SolverCommand</a><ul class="subs"><li>= <a href="#v:SolverAssert">SolverAssert</a> !<a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a></li><li>| <a href="#v:SolverCheckSat">SolverCheckSat</a></li><li>| <a href="#v:SolverPush">SolverPush</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li>| <a href="#v:SolverPop">SolverPop</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li>| <a href="#v:SolverResetAssertions">SolverResetAssertions</a></li><li>| <a href="#v:SolverTerminate">SolverTerminate</a></li></ul></li><li class="src short"><span class="keyword">class</span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle =&gt; <a href="#t:ConfigurableSolver">ConfigurableSolver</a> config handle | config -&gt; handle <span class="keyword">where</span><ul class="subs"><li><a href="#v:newSolver">newSolver</a> :: config -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> handle</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:Solver">Solver</a> handle <span class="keyword">where</span><ul class="subs"><li><a href="#v:solverRunCommand">solverRunCommand</a> :: (handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> a)) -&gt; handle -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolverCommand" title="Grisette.Internal.Core.Data.Class.Solver">SolverCommand</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> a)</li><li><a href="#v:solverAssert">solverAssert</a> :: handle -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ())</li><li><a href="#v:solverCheckSat">solverCheckSat</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li><li><a href="#v:solverPush">solverPush</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ())</li><li><a href="#v:solverPop">solverPop</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ())</li><li><a href="#v:solverResetAssertions">solverResetAssertions</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ())</li><li><a href="#v:solverTerminate">solverTerminate</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ()</li><li><a href="#v:solverForceTerminate">solverForceTerminate</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ()</li></ul></li><li class="src short"><a href="#v:solverSolve">solverSolve</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle =&gt; handle -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li><li class="src short"><a href="#v:withSolver">withSolver</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle =&gt; config -&gt; (handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> a) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> a</li><li class="src short"><a href="#v:solve">solve</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle =&gt; config -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li><li class="src short"><a href="#v:solverSolveMulti">solverSolveMulti</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle =&gt; handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</li><li class="src short"><a href="#v:solveMulti">solveMulti</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle =&gt; config -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</li><li class="src short"><span class="keyword">class</span> <a href="#t:UnionWithExcept">UnionWithExcept</a> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v | t -&gt; u e v <span class="keyword">where</span><ul class="subs"><li><a href="#v:extractUnionExcept">extractUnionExcept</a> :: t -&gt; u (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v)</li></ul></li><li class="src short"><a href="#v:solverSolveExcept">solverSolveExcept</a> :: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle) =&gt; handle -&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>) -&gt; t -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li><li class="src short"><a href="#v:solveExcept">solveExcept</a> :: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v config handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle) =&gt; config -&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>) -&gt; t -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</li><li class="src short"><a href="#v:solverSolveMultiExcept">solverSolveMultiExcept</a> :: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle) =&gt; handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>) -&gt; t -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</li><li class="src short"><a href="#v:solveMultiExcept">solveMultiExcept</a> :: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v config handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle) =&gt; config -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>) -&gt; t -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Note for the examples</h1></a><div class="doc"><p>The examples assumes that the <a href="https://github.com/Z3Prover/z3">z3</a>
 solver is available in <code>PATH</code>.</p></div><a href="#g:2" id="g:2"><h1>Solver interfaces</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SolvingFailure" class="def">SolvingFailure</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#SolvingFailure" class="link">Source</a> <a href="#t:SolvingFailure" class="selflink">#</a></p><div class="doc"><p>The current failures that can be returned by the solver.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Unsat" class="def">Unsat</a></td><td class="doc"><p>Unsatisfiable: No model is available.</p></td></tr><tr><td class="src"><a id="v:Unk" class="def">Unk</a></td><td class="doc"><p>Unknown: The solver cannot determine whether the formula is
 satisfiable.</p></td></tr><tr><td class="src"><a id="v:ResultNumLimitReached" class="def">ResultNumLimitReached</a></td><td class="doc"><p>The solver has reached the maximum number of models to return.</p></td></tr><tr><td class="src"><a id="v:SolvingError" class="def">SolvingError</a> <a href="https://hackage.haskell.org/package/text-2.1.1/docs/Data-Text.html#t:Text" title="Data.Text">Text</a></td><td class="doc"><p>The solver has encountered an error.</p></td></tr><tr><td class="src"><a id="v:Terminated" class="def">Terminated</a></td><td class="doc"><p>The solver has been terminated.</p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:SolvingFailure">Instances</h4><details id="i:SolvingFailure" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Binary:1"></span> <a href="https://hackage.haskell.org/package/binary-0.8.9.2/docs/Data-Binary.html#t:Binary" title="Data.Binary">Binary</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-61" class="link">Source</a> <a href="#t:Binary" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Binary:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:put">put</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/binary-0.8.9.2/docs/Data-Binary-Put.html#t:Put" title="Data.Binary.Put">Put</a> <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:get">get</a> :: <a href="https://hackage.haskell.org/package/binary-0.8.9.2/docs/Data-Binary-Get-Internal.html#t:Get" title="Data.Binary.Get.Internal">Get</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:putList">putList</a> :: [<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>] -&gt; <a href="https://hackage.haskell.org/package/binary-0.8.9.2/docs/Data-Binary-Put.html#t:Put" title="Data.Binary.Put">Put</a> <a href="#v:putList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Serial:2"></span> <a href="https://hackage.haskell.org/package/bytes-0.17.3/docs/Data-Bytes-Serial.html#t:Serial" title="Data.Bytes.Serial">Serial</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-47" class="link">Source</a> <a href="#t:Serial" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Serial:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:serialize">serialize</a> :: <a href="https://hackage.haskell.org/package/bytes-0.17.3/docs/Data-Bytes-Put.html#t:MonadPut" title="Data.Bytes.Put">MonadPut</a> m =&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; m () <a href="#v:serialize" class="selflink">#</a></p><p class="src"><a href="#v:deserialize">deserialize</a> :: <a href="https://hackage.haskell.org/package/bytes-0.17.3/docs/Data-Bytes-Get.html#t:MonadGet" title="Data.Bytes.Get">MonadGet</a> m =&gt; m <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="#v:deserialize" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Serialize:3"></span> <a href="https://hackage.haskell.org/package/cereal-0.5.8.3/docs/Data-Serialize.html#t:Serialize" title="Data.Serialize">Serialize</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-57" class="link">Source</a> <a href="#t:Serialize" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Serialize:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:put">put</a> :: <a href="https://hackage.haskell.org/package/cereal-0.5.8.3/docs/Data-Serialize-Put.html#t:Putter" title="Data.Serialize.Put">Putter</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:get">get</a> :: <a href="https://hackage.haskell.org/package/cereal-0.5.8.3/docs/Data-Serialize-Get.html#t:Get" title="Data.Serialize.Get">Get</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="#v:get" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:NFData:4"></span> <a href="https://hackage.haskell.org/package/deepseq-1.5.0.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-47" class="link">Source</a> <a href="#t:NFData" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:NFData:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:rnf">rnf</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; () <a href="#v:rnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Show:5"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-47" class="link">Source</a> <a href="#t:Show" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Show:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Eq:6"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-47" class="link">Source</a> <a href="#t:Eq" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Eq:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:PPrint:7"></span> <a href="Grisette-Internal-Core-Data-Class-PPrint.html#t:PPrint" title="Grisette.Internal.Core.Data.Class.PPrint">PPrint</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-47" class="link">Source</a> <a href="#t:PPrint" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:PPrint:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pformat">pformat</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/prettyprinter-1.7.1/docs/Prettyprinter.html#t:Doc" title="Prettyprinter">Doc</a> ann <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.html#pformat" class="link">Source</a> <a href="#v:pformat" class="selflink">#</a></p><p class="src"><a href="#v:pformatPrec">pformatPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/prettyprinter-1.7.1/docs/Prettyprinter.html#t:Doc" title="Prettyprinter">Doc</a> ann <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.html#pformatPrec" class="link">Source</a> <a href="#v:pformatPrec" class="selflink">#</a></p><p class="src"><a href="#v:pformatList">pformatList</a> :: [<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>] -&gt; <a href="https://hackage.haskell.org/package/prettyprinter-1.7.1/docs/Prettyprinter.html#t:Doc" title="Prettyprinter">Doc</a> ann <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.PPrint.html#pformatList" class="link">Source</a> <a href="#v:pformatList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Hashable:8"></span> <a href="https://hackage.haskell.org/package/hashable-1.4.7.0/docs/Data-Hashable.html#t:Hashable" title="Data.Hashable">Hashable</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Impl.Core.Data.Class.Solver.html#line-47" class="link">Source</a> <a href="#t:Hashable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Hashable:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Impl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:hashWithSalt">hashWithSalt</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="#v:hashWithSalt" class="selflink">#</a></p><p class="src"><a href="#v:hash">hash</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="#v:hash" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SolvingFailure:Lift:9"></span> <a href="https://hackage.haskell.org/package/template-haskell-2.22.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a></span> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#line-108" class="link">Source</a> <a href="#t:SolvingFailure" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SolvingFailure:Lift:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Decl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Decl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/template-haskell-2.22.0.0/docs/Language-Haskell-TH-Syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; m <a href="https://hackage.haskell.org/package/template-haskell-2.22.0.0/docs/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="#v:lift" class="selflink">#</a></p><p class="src"><a href="#v:liftTyped">liftTyped</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/template-haskell-2.22.0.0/docs/Language-Haskell-TH-Syntax.html#t:Quote" title="Language.Haskell.TH.Syntax">Quote</a> m =&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> -&gt; <a href="https://hackage.haskell.org/package/template-haskell-2.22.0.0/docs/Language-Haskell-TH-Syntax.html#t:Code" title="Language.Haskell.TH.Syntax">Code</a> m <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="#v:liftTyped" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a id="t:MonadicSolver" class="def">MonadicSolver</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#MonadicSolver" class="link">Source</a> <a href="#t:MonadicSolver" class="selflink">#</a></p><div class="doc"><p>A monadic solver interface.</p><p>This interface abstract the monadic interface of a solver. All the operations
 performed in the monad are using a single solver instance. The solver
 instance is management by the monad's <code>run</code> function.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:monadicSolverPush" class="def">monadicSolverPush</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverPush" class="link">Source</a> <a href="#v:monadicSolverPush" class="selflink">#</a></p><p class="src"><a id="v:monadicSolverPop" class="def">monadicSolverPop</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverPop" class="link">Source</a> <a href="#v:monadicSolverPop" class="selflink">#</a></p><p class="src"><a id="v:monadicSolverResetAssertions" class="def">monadicSolverResetAssertions</a> :: m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverResetAssertions" class="link">Source</a> <a href="#v:monadicSolverResetAssertions" class="selflink">#</a></p><p class="src"><a id="v:monadicSolverAssert" class="def">monadicSolverAssert</a> :: <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverAssert" class="link">Source</a> <a href="#v:monadicSolverAssert" class="selflink">#</a></p><p class="src"><a id="v:monadicSolverCheckSat" class="def">monadicSolverCheckSat</a> :: m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverCheckSat" class="link">Source</a> <a href="#v:monadicSolverCheckSat" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadicSolver">Instances</h4><details id="i:MonadicSolver" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadicSolver:MonadicSolver:1"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:MonadicSolver" title="Grisette.Internal.Core.Data.Class.Solver">MonadicSolver</a> (<a href="Grisette-Internal-Backend-Solving.html#t:SBVIncrementalT" title="Grisette.Internal.Backend.Solving">SBVIncrementalT</a> m)</span> <a href="src/Grisette.Internal.Backend.Solving.html#line-384" class="link">Source</a> <a href="#t:MonadicSolver" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadicSolver:MonadicSolver:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Backend-Solving.html">Grisette.Internal.Backend.Solving</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:monadicSolverPush">monadicSolverPush</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-Backend-Solving.html#t:SBVIncrementalT" title="Grisette.Internal.Backend.Solving">SBVIncrementalT</a> m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverPush" class="link">Source</a> <a href="#v:monadicSolverPush" class="selflink">#</a></p><p class="src"><a href="#v:monadicSolverPop">monadicSolverPop</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Grisette-Internal-Backend-Solving.html#t:SBVIncrementalT" title="Grisette.Internal.Backend.Solving">SBVIncrementalT</a> m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverPop" class="link">Source</a> <a href="#v:monadicSolverPop" class="selflink">#</a></p><p class="src"><a href="#v:monadicSolverResetAssertions">monadicSolverResetAssertions</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVIncrementalT" title="Grisette.Internal.Backend.Solving">SBVIncrementalT</a> m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverResetAssertions" class="link">Source</a> <a href="#v:monadicSolverResetAssertions" class="selflink">#</a></p><p class="src"><a href="#v:monadicSolverAssert">monadicSolverAssert</a> :: <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="Grisette-Internal-Backend-Solving.html#t:SBVIncrementalT" title="Grisette.Internal.Backend.Solving">SBVIncrementalT</a> m () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverAssert" class="link">Source</a> <a href="#v:monadicSolverAssert" class="selflink">#</a></p><p class="src"><a href="#v:monadicSolverCheckSat">monadicSolverCheckSat</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVIncrementalT" title="Grisette.Internal.Backend.Solving">SBVIncrementalT</a> m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverCheckSat" class="link">Source</a> <a href="#v:monadicSolverCheckSat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:monadicSolverSolve" class="def">monadicSolverSolve</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:MonadicSolver" title="Grisette.Internal.Core.Data.Class.Solver">MonadicSolver</a> m =&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#monadicSolverSolve" class="link">Source</a> <a href="#v:monadicSolverSolve" class="selflink">#</a></p><div class="doc"><p>Solve a single formula with a monadic solver. Find an assignment to it to
 make it true.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SolverCommand" class="def">SolverCommand</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#SolverCommand" class="link">Source</a> <a href="#t:SolverCommand" class="selflink">#</a></p><div class="doc"><p>The commands that can be sent to a solver.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:SolverAssert" class="def">SolverAssert</a> !<a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SolverCheckSat" class="def">SolverCheckSat</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SolverPush" class="def">SolverPush</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SolverPop" class="def">SolverPop</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SolverResetAssertions" class="def">SolverResetAssertions</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SolverTerminate" class="def">SolverTerminate</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle =&gt; <a id="t:ConfigurableSolver" class="def">ConfigurableSolver</a> config handle | config -&gt; handle <span class="keyword">where</span> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#ConfigurableSolver" class="link">Source</a> <a href="#t:ConfigurableSolver" class="selflink">#</a></p><div class="doc"><p>A class that abstracts the creation of a solver instance based on a
 configuration.</p><p>The solver instance will need to be terminated by the user, with the solver
 interface.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:newSolver" class="def">newSolver</a> :: config -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> handle <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#newSolver" class="link">Source</a> <a href="#v:newSolver" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ConfigurableSolver">Instances</h4><details id="i:ConfigurableSolver" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:ConfigurableSolver:ConfigurableSolver:1"></span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> <a href="Grisette-Internal-Backend-Solving.html#t:GrisetteSMTConfig" title="Grisette.Internal.Backend.Solving">GrisetteSMTConfig</a> <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a></span> <a href="src/Grisette.Internal.Backend.Solving.html#line-423" class="link">Source</a> <a href="#t:ConfigurableSolver" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:ConfigurableSolver:ConfigurableSolver:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Backend-Solving.html">Grisette.Internal.Backend.Solving</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:newSolver">newSolver</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:GrisetteSMTConfig" title="Grisette.Internal.Backend.Solving">GrisetteSMTConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#newSolver" class="link">Source</a> <a href="#v:newSolver" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Solver" class="def">Solver</a> handle <span class="keyword">where</span> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#Solver" class="link">Source</a> <a href="#t:Solver" class="selflink">#</a></p><div class="doc"><p>A class that abstracts the solver interface.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Grisette-Internal-Core-Data-Class-Solver.html#v:solverRunCommand" title="Grisette.Internal.Core.Data.Class.Solver">solverRunCommand</a>, <a href="Grisette-Internal-Core-Data-Class-Solver.html#v:solverCheckSat" title="Grisette.Internal.Core.Data.Class.Solver">solverCheckSat</a>, <a href="Grisette-Internal-Core-Data-Class-Solver.html#v:solverTerminate" title="Grisette.Internal.Core.Data.Class.Solver">solverTerminate</a>, <a href="Grisette-Internal-Core-Data-Class-Solver.html#v:solverForceTerminate" title="Grisette.Internal.Core.Data.Class.Solver">solverForceTerminate</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:solverRunCommand" class="def">solverRunCommand</a> :: (handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> a)) -&gt; handle -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolverCommand" title="Grisette.Internal.Core.Data.Class.Solver">SolverCommand</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> a) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverRunCommand" class="link">Source</a> <a href="#v:solverRunCommand" class="selflink">#</a></p><div class="doc"><p>Run a solver command.</p></div><p class="src"><a id="v:solverAssert" class="def">solverAssert</a> :: handle -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverAssert" class="link">Source</a> <a href="#v:solverAssert" class="selflink">#</a></p><div class="doc"><p>Assert a formula.</p></div><p class="src"><a id="v:solverCheckSat" class="def">solverCheckSat</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverCheckSat" class="link">Source</a> <a href="#v:solverCheckSat" class="selflink">#</a></p><div class="doc"><p>Solve a formula.</p></div><p class="src"><a id="v:solverPush" class="def">solverPush</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverPush" class="link">Source</a> <a href="#v:solverPush" class="selflink">#</a></p><div class="doc"><p>Push <code>n</code> levels.</p></div><p class="src"><a id="v:solverPop" class="def">solverPop</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverPop" class="link">Source</a> <a href="#v:solverPop" class="selflink">#</a></p><div class="doc"><p>Pop <code>n</code> levels.</p></div><p class="src"><a id="v:solverResetAssertions" class="def">solverResetAssertions</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverResetAssertions" class="link">Source</a> <a href="#v:solverResetAssertions" class="selflink">#</a></p><div class="doc"><p>Reset all assertions in the solver.</p><p>The solver keeps all the assertions used in the previous commands:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solver &lt;- newSolver z3
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solverSolve solver &quot;a&quot;
</code></strong>Right (Model {a -&gt; true :: Bool})
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solverSolve solver $ symNot &quot;a&quot;
</code></strong>Left Unsat
</pre><p>You can clear the assertions using <code>solverResetAssertions</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solverResetAssertions solver
</code></strong>Right ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solverSolve solver $ symNot &quot;a&quot;
</code></strong>Right (Model {a -&gt; false :: Bool})
</pre></div><p class="src"><a id="v:solverTerminate" class="def">solverTerminate</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverTerminate" class="link">Source</a> <a href="#v:solverTerminate" class="selflink">#</a></p><div class="doc"><p>Terminate the solver, wait until the last command is finished.</p></div><p class="src"><a id="v:solverForceTerminate" class="def">solverForceTerminate</a> :: handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverForceTerminate" class="link">Source</a> <a href="#v:solverForceTerminate" class="selflink">#</a></p><div class="doc"><p>Force terminate the solver, do not wait for the last command to finish.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Solver">Instances</h4><details id="i:Solver" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Solver:Solver:1"></span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a></span> <a href="src/Grisette.Internal.Backend.Solving.html#line-458" class="link">Source</a> <a href="#t:Solver" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Solver:Solver:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Backend-Solving.html">Grisette.Internal.Backend.Solving</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:solverRunCommand">solverRunCommand</a> :: (<a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> a)) -&gt; <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolverCommand" title="Grisette.Internal.Core.Data.Class.Solver">SolverCommand</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> a) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverRunCommand" class="link">Source</a> <a href="#v:solverRunCommand" class="selflink">#</a></p><p class="src"><a href="#v:solverAssert">solverAssert</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverAssert" class="link">Source</a> <a href="#v:solverAssert" class="selflink">#</a></p><p class="src"><a href="#v:solverCheckSat">solverCheckSat</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverCheckSat" class="link">Source</a> <a href="#v:solverCheckSat" class="selflink">#</a></p><p class="src"><a href="#v:solverPush">solverPush</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverPush" class="link">Source</a> <a href="#v:solverPush" class="selflink">#</a></p><p class="src"><a href="#v:solverPop">solverPop</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverPop" class="link">Source</a> <a href="#v:solverPop" class="selflink">#</a></p><p class="src"><a href="#v:solverResetAssertions">solverResetAssertions</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> ()) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverResetAssertions" class="link">Source</a> <a href="#v:solverResetAssertions" class="selflink">#</a></p><p class="src"><a href="#v:solverTerminate">solverTerminate</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverTerminate" class="link">Source</a> <a href="#v:solverTerminate" class="selflink">#</a></p><p class="src"><a href="#v:solverForceTerminate">solverForceTerminate</a> :: <a href="Grisette-Internal-Backend-Solving.html#t:SBVSolverHandle" title="Grisette.Internal.Backend.Solving">SBVSolverHandle</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> () <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverForceTerminate" class="link">Source</a> <a href="#v:solverForceTerminate" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:solverSolve" class="def">solverSolve</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle =&gt; handle -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverSolve" class="link">Source</a> <a href="#v:solverSolve" class="selflink">#</a></p><div class="doc"><p>Solve a single formula. Find an assignment to it to make it true.</p></div></div><div class="top"><p class="src"><a id="v:withSolver" class="def">withSolver</a> :: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle =&gt; config -&gt; (handle -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> a) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> a <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#withSolver" class="link">Source</a> <a href="#v:withSolver" class="selflink">#</a></p><div class="doc"><p>Start a solver, run a computation with the solver, and terminate the
 solver after the computation finishes.</p><p>When an exception happens, this will forcibly terminate the solver.</p><p>Note: if Grisette is compiled with sbv &lt; 10.10, the solver likely won't be
 really terminated until it has finished the last action, and this will
 result in long-running or zombie solver instances.</p><p>This was due to a bug in sbv, which is fixed in
 <a href="https://github.com/LeventErkok/sbv/pull/695">https://github.com/LeventErkok/sbv/pull/695</a>.</p></div></div><div class="top"><p class="src"><a id="v:solve" class="def">solve</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solve" class="link">Source</a> <a href="#v:solve" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; config</td><td class="doc"><p>solver configuration</p></td></tr><tr><td class="src">-&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a></td><td class="doc"><p>formula to solve, the solver will try to make it true</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solve a single formula. Find an assignment to it to make it true.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solve z3 (&quot;a&quot; .&amp;&amp; (&quot;b&quot; :: SymInteger) .== 1)
</code></strong>Right (Model {a -&gt; true :: Bool, b -&gt; 1 :: Integer})
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solve z3 (&quot;a&quot; .&amp;&amp; symNot &quot;a&quot;)
</code></strong>Left Unsat
</pre></div></div><div class="top"><p class="src"><a id="v:solverSolveMulti" class="def">solverSolveMulti</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverSolveMulti" class="link">Source</a> <a href="#v:solverSolveMulti" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; handle</td><td class="doc"><p>solver handle</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>maximum number of models to return</p></td></tr><tr><td class="src">-&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a></td><td class="doc"><p>formula to solve, the solver will try to make it true</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solve a single formula while returning multiple models to make it true.
 The maximum number of desired models are given.</p></div></div><div class="top"><p class="src"><a id="v:solveMulti" class="def">solveMulti</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solveMulti" class="link">Source</a> <a href="#v:solveMulti" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; config</td><td class="doc"><p>solver configuration</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>maximum number of models to return</p></td></tr><tr><td class="src">-&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a></td><td class="doc"><p>formula to solve, the solver will try to make it true</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solve a single formula while returning multiple models to make it true.
 The maximum number of desired models are given.</p><pre>&gt;&gt;&gt; solveMulti z3 4 (&quot;a&quot; .|| &quot;b&quot;)
[Model {a -&gt; True :: Bool, b -&gt; False :: Bool},Model {a -&gt; False :: Bool, b -&gt; True :: Bool},Model {a -&gt; True :: Bool, b -&gt; True :: Bool}]</pre></div></div><a href="#g:3" id="g:3"><h1>Union with exceptions</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:UnionWithExcept" class="def">UnionWithExcept</a> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v | t -&gt; u e v <span class="keyword">where</span> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#UnionWithExcept" class="link">Source</a> <a href="#t:UnionWithExcept" class="selflink">#</a></p><div class="doc"><p>A class that abstracts the union-like structures that contains exceptions.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:extractUnionExcept" class="def">extractUnionExcept</a> :: t -&gt; u (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#extractUnionExcept" class="link">Source</a> <a href="#v:extractUnionExcept" class="selflink">#</a></p><div class="doc"><p>Extract a union of exceptions and values from the structure.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:UnionWithExcept">Instances</h4><details id="i:UnionWithExcept" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:UnionWithExcept:UnionWithExcept:1"></span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> (<a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v)) <a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> e v</span> <a href="src/Grisette.Internal.Internal.Impl.Core.Control.Monad.Union.html#line-479" class="link">Source</a> <a href="#t:UnionWithExcept" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:UnionWithExcept:UnionWithExcept:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Impl-Core-Control-Monad-Union.html">Grisette.Internal.Internal.Impl.Core.Control.Monad.Union</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extractUnionExcept">extractUnionExcept</a> :: <a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v) -&gt; <a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#extractUnionExcept" class="link">Source</a> <a href="#v:extractUnionExcept" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:UnionWithExcept:UnionWithExcept:2"></span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> (<a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> (<a href="Grisette-Internal-Core-Control-Monad-CBMCExcept.html#t:CBMCEither" title="Grisette.Internal.Core.Control.Monad.CBMCExcept">CBMCEither</a> e v)) <a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> e v</span> <a href="src/Grisette.Internal.Core.Control.Monad.CBMCExcept.html#line-480" class="link">Source</a> <a href="#t:UnionWithExcept" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:UnionWithExcept:UnionWithExcept:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Core-Control-Monad-CBMCExcept.html">Grisette.Internal.Core.Control.Monad.CBMCExcept</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extractUnionExcept">extractUnionExcept</a> :: <a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> (<a href="Grisette-Internal-Core-Control-Monad-CBMCExcept.html#t:CBMCEither" title="Grisette.Internal.Core.Control.Monad.CBMCExcept">CBMCEither</a> e v) -&gt; <a href="Grisette-Internal-Core-Control-Monad-Union.html#t:Union" title="Grisette.Internal.Core.Control.Monad.Union">Union</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#extractUnionExcept" class="link">Source</a> <a href="#v:extractUnionExcept" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:UnionWithExcept:UnionWithExcept:3"></span> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> u, <a href="Grisette-Internal-Core-Data-Class-TryMerge.html#t:TryMerge" title="Grisette.Internal.Core.Data.Class.TryMerge">TryMerge</a> u, <a href="Grisette-Internal-Core-Data-Class-Mergeable.html#t:Mergeable" title="Grisette.Internal.Core.Data.Class.Mergeable">Mergeable</a> e, <a href="Grisette-Internal-Core-Data-Class-Mergeable.html#t:Mergeable" title="Grisette.Internal.Core.Data.Class.Mergeable">Mergeable</a> v) =&gt; <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> (<a href="Grisette-Internal-Core-Control-Monad-CBMCExcept.html#t:CBMCExceptT" title="Grisette.Internal.Core.Control.Monad.CBMCExcept">CBMCExceptT</a> e u v) u e v</span> <a href="src/Grisette.Internal.Core.Control.Monad.CBMCExcept.html#line-475" class="link">Source</a> <a href="#t:UnionWithExcept" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:UnionWithExcept:UnionWithExcept:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Core-Control-Monad-CBMCExcept.html">Grisette.Internal.Core.Control.Monad.CBMCExcept</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extractUnionExcept">extractUnionExcept</a> :: <a href="Grisette-Internal-Core-Control-Monad-CBMCExcept.html#t:CBMCExceptT" title="Grisette.Internal.Core.Control.Monad.CBMCExcept">CBMCExceptT</a> e u v -&gt; u (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#extractUnionExcept" class="link">Source</a> <a href="#v:extractUnionExcept" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:UnionWithExcept:UnionWithExcept:4"></span> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> (<a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Except.html#t:ExceptT" title="Control.Monad.Except">ExceptT</a> e u v) u e v</span> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#line-353" class="link">Source</a> <a href="#t:UnionWithExcept" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:UnionWithExcept:UnionWithExcept:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Grisette-Internal-Internal-Decl-Core-Data-Class-Solver.html">Grisette.Internal.Internal.Decl.Core.Data.Class.Solver</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extractUnionExcept">extractUnionExcept</a> :: <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Except.html#t:ExceptT" title="Control.Monad.Except">ExceptT</a> e u v -&gt; u (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v) <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#extractUnionExcept" class="link">Source</a> <a href="#v:extractUnionExcept" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:solverSolveExcept" class="def">solverSolveExcept</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverSolveExcept" class="link">Source</a> <a href="#v:solverSolveExcept" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; handle</td><td class="doc"><p>solver handle</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>)</td><td class="doc"><p>mapping the results to symbolic boolean formulas, the solver would try to
 find a model to make the formula true</p></td></tr><tr><td class="src">-&gt; t</td><td class="doc"><p>the program to be solved, should be a union of exception and values</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solver procedure for programs with error handling.</p></div></div><div class="top"><p class="src"><a id="v:solveExcept" class="def">solveExcept</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solveExcept" class="link">Source</a> <a href="#v:solveExcept" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v config handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; config</td><td class="doc"><p>solver configuration</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>)</td><td class="doc"><p>mapping the results to symbolic boolean formulas, the solver would try to
 find a model to make the formula true</p></td></tr><tr><td class="src">-&gt; t</td><td class="doc"><p>the program to be solved, should be a union of exception and values</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a> <a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solver procedure for programs with error handling.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Control.Monad.Except
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = &quot;x&quot; :: SymInteger
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  res :: ExceptT AssertionError Union ()
  res = do
    symAssert $ x .&gt; 0       -- constrain that x is positive
    symAssert $ x .&lt; 2       -- constrain that x is less than 2
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>  translate (Left _) = con False -- errors are not desirable
  translate _ = con True         -- non-errors are desirable
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>solveExcept z3 translate res
</code></strong>Right (Model {x -&gt; 1 :: Integer})
</pre></div></div><div class="top"><p class="src"><a id="v:solverSolveMultiExcept" class="def">solverSolveMultiExcept</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solverSolveMultiExcept" class="link">Source</a> <a href="#v:solverSolveMultiExcept" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:Solver" title="Grisette.Internal.Core.Data.Class.Solver">Solver</a> handle)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; handle</td><td class="doc"><p>solver configuration</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>maximum number of models to return</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>)</td><td class="doc"><p>mapping the results to symbolic boolean formulas, the solver would try to
 find a model to make the formula true</p></td></tr><tr><td class="src">-&gt; t</td><td class="doc"><p>the program to be solved, should be a union of exception and values</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solver procedure for programs with error handling. Would return multiple
 models if possible.</p></div></div><div class="top"><p class="src"><a id="v:solveMultiExcept" class="def">solveMultiExcept</a> <a href="src/Grisette.Internal.Internal.Decl.Core.Data.Class.Solver.html#solveMultiExcept" class="link">Source</a> <a href="#v:solveMultiExcept" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> t (u :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) e v config handle. (<a href="Grisette-Internal-Core-Data-Class-Solver.html#t:UnionWithExcept" title="Grisette.Internal.Core.Data.Class.Solver">UnionWithExcept</a> t u e v, <a href="Grisette-Internal-Core-Data-Class-PlainUnion.html#t:PlainUnion" title="Grisette.Internal.Core.Data.Class.PlainUnion">PlainUnion</a> u, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> u, <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:ConfigurableSolver" title="Grisette.Internal.Core.Data.Class.Solver">ConfigurableSolver</a> config handle)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; config</td><td class="doc"><p>solver configuration</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>maximum number of models to return</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e v -&gt; <a href="Grisette-Internal-SymPrim-SymBool.html#t:SymBool" title="Grisette.Internal.SymPrim.SymBool">SymBool</a>)</td><td class="doc"><p>mapping the results to symbolic boolean formulas, the solver would try to
 find a model to make the formula true</p></td></tr><tr><td class="src">-&gt; t</td><td class="doc"><p>the program to be solved, should be a union of exception and values</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ([<a href="Grisette-Internal-SymPrim-Prim-Model.html#t:Model" title="Grisette.Internal.SymPrim.Prim.Model">Model</a>], <a href="Grisette-Internal-Core-Data-Class-Solver.html#t:SolvingFailure" title="Grisette.Internal.Core.Data.Class.Solver">SolvingFailure</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Solver procedure for programs with error handling. Would return multiple
 models if possible.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>